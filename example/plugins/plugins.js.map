{"version":3,"file":"plugins.js","sources":["webpack://TaroTrackPlugins/webpack/bootstrap","webpack://TaroTrackPlugins/./node_modules/@kiner/taro-track-common/es/index.js","webpack://TaroTrackPlugins/./node_modules/@kiner/taro-track-common/es/src/config.js","webpack://TaroTrackPlugins/./node_modules/@kiner/taro-track-corejs/es/index.js","webpack://TaroTrackPlugins/./node_modules/@kiner/taro-track-corejs/es/src/DoubleLinkedList.js","webpack://TaroTrackPlugins/./node_modules/@kiner/taro-track-corejs/es/src/IteratorProtocol.js","webpack://TaroTrackPlugins/./node_modules/@kiner/taro-track-corejs/es/src/Logger4Node.js","webpack://TaroTrackPlugins/./node_modules/@kiner/taro-track-corejs/es/src/Queue.js","webpack://TaroTrackPlugins/./node_modules/@kiner/taro-track-corejs/es/src/base64.js","webpack://TaroTrackPlugins/./node_modules/@kiner/taro-track-corejs/es/src/base64/decode.js","webpack://TaroTrackPlugins/./node_modules/@kiner/taro-track-corejs/es/src/base64/encode.js","webpack://TaroTrackPlugins/./node_modules/@kiner/taro-track-corejs/es/src/base64/mark.js","webpack://TaroTrackPlugins/./node_modules/@kiner/taro-track-corejs/es/src/guid.js","webpack://TaroTrackPlugins/./node_modules/@kiner/taro-track-corejs/es/src/logger.js","webpack://TaroTrackPlugins/./node_modules/@kiner/taro-track-corejs/es/src/tools.js","webpack://TaroTrackPlugins/./node_modules/@kiner/taro-track-corejs/es/src/wx-revise-timer.js","webpack://TaroTrackPlugins/./node_modules/@kiner/taro-track-corejs/es/src/wx-tools.js","webpack://TaroTrackPlugins/./node_modules/@kiner/taro-track-datasource/es/index.js","webpack://TaroTrackPlugins/./node_modules/@kiner/taro-track-datasource/es/src/OverrideWechatApp.js","webpack://TaroTrackPlugins/./node_modules/@kiner/taro-track-datasource/es/src/OverrideWechatPage.js","webpack://TaroTrackPlugins/./node_modules/@kiner/taro-track-datasource/es/src/WechatDownload.js","webpack://TaroTrackPlugins/./node_modules/@kiner/taro-track-datasource/es/src/WechatMonitor.js","webpack://TaroTrackPlugins/./node_modules/@kiner/taro-track-datasource/es/src/WechatRequest.js","webpack://TaroTrackPlugins/./node_modules/@kiner/taro-track-datasource/es/src/WechatUpload.js","webpack://TaroTrackPlugins/./node_modules/@kiner/taro-track-datasource/es/src/impl/BaseFields.js","webpack://TaroTrackPlugins/./node_modules/@kiner/taro-track-datasource/es/src/impl/Constant.js","webpack://TaroTrackPlugins/./node_modules/@kiner/taro-track-datasource/es/src/impl/Queue.js","webpack://TaroTrackPlugins/./node_modules/@kiner/taro-track-datasource/es/src/impl/WechatListener.js","webpack://TaroTrackPlugins/./node_modules/@kiner/taro-track-datasource/es/src/impl/index.js","webpack://TaroTrackPlugins/./node_modules/@kiner/taro-track-datasource/es/src/inter/index.js","webpack://TaroTrackPlugins/./node_modules/@kiner/taro-track-datasource/es/src/inter/listener.js","webpack://TaroTrackPlugins/./node_modules/@kiner/taro-track-datasource/es/src/inter/monitor.js","webpack://TaroTrackPlugins/./node_modules/@kiner/taro-track-datasource/es/src/inter/network.js","webpack://TaroTrackPlugins/./node_modules/@kiner/taro-track-datasource/es/src/inter/pageLife.js","webpack://TaroTrackPlugins/./node_modules/@kiner/taro-track-datasource/es/src/performance/Performance.js","webpack://TaroTrackPlugins/./node_modules/@kiner/taro-track-datasource/es/src/user-behavior/Track.js","webpack://TaroTrackPlugins/./node_modules/@kiner/taro-track-datasource/es/src/user-behavior/UserBehavior.js","webpack://TaroTrackPlugins/./node_modules/@kiner/taro-track-datasource/es/src/user-behavior/helper.js","webpack://TaroTrackPlugins/./node_modules/@kiner/taro-track-datasource/es/src/user-behavior/wrapper.js","webpack://TaroTrackPlugins/./node_modules/@kiner/taro-track-entrypoint/es/index.js","webpack://TaroTrackPlugins/./node_modules/@kiner/taro-track-transporter/es/index.js","webpack://TaroTrackPlugins/./node_modules/@kiner/taro-track-transporter/es/src/TransportConsole.js","webpack://TaroTrackPlugins/./node_modules/@kiner/taro-track-transporter/es/src/TransportElk.js","webpack://TaroTrackPlugins/./node_modules/@kiner/taro-track-transporter/es/src/config.js","webpack://TaroTrackPlugins/./node_modules/@kiner/taro-track-transporter/es/src/utils/encode-elk.js","webpack://TaroTrackPlugins/./node_modules/at-least-node/index.js","webpack://TaroTrackPlugins/./node_modules/balanced-match/index.js","webpack://TaroTrackPlugins/./node_modules/brace-expansion/index.js","webpack://TaroTrackPlugins/./node_modules/colors/lib/colors.js","webpack://TaroTrackPlugins/./node_modules/colors/lib/custom/trap.js","webpack://TaroTrackPlugins/./node_modules/colors/lib/custom/zalgo.js","webpack://TaroTrackPlugins/./node_modules/colors/lib/extendStringPrototype.js","webpack://TaroTrackPlugins/./node_modules/colors/lib/index.js","webpack://TaroTrackPlugins/./node_modules/colors/lib/maps/america.js","webpack://TaroTrackPlugins/./node_modules/colors/lib/maps/rainbow.js","webpack://TaroTrackPlugins/./node_modules/colors/lib/maps/random.js","webpack://TaroTrackPlugins/./node_modules/colors/lib/maps/zebra.js","webpack://TaroTrackPlugins/./node_modules/colors/lib/styles.js","webpack://TaroTrackPlugins/./node_modules/colors/lib/system/has-flag.js","webpack://TaroTrackPlugins/./node_modules/colors/lib/system/supports-colors.js","webpack://TaroTrackPlugins/./node_modules/concat-map/index.js","webpack://TaroTrackPlugins/./node_modules/crc32/lib/crc32.js","webpack://TaroTrackPlugins/./node_modules/deflate-js/index.js","webpack://TaroTrackPlugins/./node_modules/deflate-js/lib/rawdeflate.js","webpack://TaroTrackPlugins/./node_modules/deflate-js/lib/rawinflate.js","webpack://TaroTrackPlugins/./node_modules/fs-extra/lib/copy-sync/copy-sync.js","webpack://TaroTrackPlugins/./node_modules/fs-extra/lib/copy-sync/index.js","webpack://TaroTrackPlugins/./node_modules/fs-extra/lib/copy/copy.js","webpack://TaroTrackPlugins/./node_modules/fs-extra/lib/copy/index.js","webpack://TaroTrackPlugins/./node_modules/fs-extra/lib/empty/index.js","webpack://TaroTrackPlugins/./node_modules/fs-extra/lib/ensure/file.js","webpack://TaroTrackPlugins/./node_modules/fs-extra/lib/ensure/index.js","webpack://TaroTrackPlugins/./node_modules/fs-extra/lib/ensure/link.js","webpack://TaroTrackPlugins/./node_modules/fs-extra/lib/ensure/symlink-paths.js","webpack://TaroTrackPlugins/./node_modules/fs-extra/lib/ensure/symlink-type.js","webpack://TaroTrackPlugins/./node_modules/fs-extra/lib/ensure/symlink.js","webpack://TaroTrackPlugins/./node_modules/fs-extra/lib/fs/index.js","webpack://TaroTrackPlugins/./node_modules/fs-extra/lib/index.js","webpack://TaroTrackPlugins/./node_modules/fs-extra/lib/json/index.js","webpack://TaroTrackPlugins/./node_modules/fs-extra/lib/json/jsonfile.js","webpack://TaroTrackPlugins/./node_modules/fs-extra/lib/json/output-json-sync.js","webpack://TaroTrackPlugins/./node_modules/fs-extra/lib/json/output-json.js","webpack://TaroTrackPlugins/./node_modules/fs-extra/lib/mkdirs/index.js","webpack://TaroTrackPlugins/./node_modules/fs-extra/lib/mkdirs/make-dir.js","webpack://TaroTrackPlugins/./node_modules/fs-extra/lib/move-sync/index.js","webpack://TaroTrackPlugins/./node_modules/fs-extra/lib/move-sync/move-sync.js","webpack://TaroTrackPlugins/./node_modules/fs-extra/lib/move/index.js","webpack://TaroTrackPlugins/./node_modules/fs-extra/lib/move/move.js","webpack://TaroTrackPlugins/./node_modules/fs-extra/lib/output/index.js","webpack://TaroTrackPlugins/./node_modules/fs-extra/lib/path-exists/index.js","webpack://TaroTrackPlugins/./node_modules/fs-extra/lib/remove/index.js","webpack://TaroTrackPlugins/./node_modules/fs-extra/lib/remove/rimraf.js","webpack://TaroTrackPlugins/./node_modules/fs-extra/lib/util/stat.js","webpack://TaroTrackPlugins/./node_modules/fs-extra/lib/util/utimes.js","webpack://TaroTrackPlugins/./node_modules/fs.realpath/index.js","webpack://TaroTrackPlugins/./node_modules/fs.realpath/old.js","webpack://TaroTrackPlugins/./node_modules/glob/common.js","webpack://TaroTrackPlugins/./node_modules/glob/glob.js","webpack://TaroTrackPlugins/./node_modules/glob/sync.js","webpack://TaroTrackPlugins/./node_modules/graceful-fs/clone.js","webpack://TaroTrackPlugins/./node_modules/graceful-fs/graceful-fs.js","webpack://TaroTrackPlugins/./node_modules/graceful-fs/legacy-streams.js","webpack://TaroTrackPlugins/./node_modules/graceful-fs/polyfills.js","webpack://TaroTrackPlugins/./node_modules/gzip-js/lib/gzip.js","webpack://TaroTrackPlugins/./node_modules/inflight/inflight.js","webpack://TaroTrackPlugins/./node_modules/inherits/inherits.js","webpack://TaroTrackPlugins/./node_modules/inherits/inherits_browser.js","webpack://TaroTrackPlugins/./node_modules/jsonfile/index.js","webpack://TaroTrackPlugins/./node_modules/jsonfile/node_modules/universalify/index.js","webpack://TaroTrackPlugins/./node_modules/jsonfile/utils.js","webpack://TaroTrackPlugins/./node_modules/minimatch/minimatch.js","webpack://TaroTrackPlugins/./node_modules/once/once.js","webpack://TaroTrackPlugins/./node_modules/path-is-absolute/index.js","webpack://TaroTrackPlugins/./node_modules/shelljs/commands.js","webpack://TaroTrackPlugins/./node_modules/shelljs/shell.js","webpack://TaroTrackPlugins/./node_modules/shelljs/src sync ^\\.\\/.*$","webpack://TaroTrackPlugins/./node_modules/shelljs/src/cat.js","webpack://TaroTrackPlugins/./node_modules/shelljs/src/cd.js","webpack://TaroTrackPlugins/./node_modules/shelljs/src/chmod.js","webpack://TaroTrackPlugins/./node_modules/shelljs/src/common.js","webpack://TaroTrackPlugins/./node_modules/shelljs/src/cp.js","webpack://TaroTrackPlugins/./node_modules/shelljs/src/dirs.js","webpack://TaroTrackPlugins/./node_modules/shelljs/src/echo.js","webpack://TaroTrackPlugins/./node_modules/shelljs/src/error.js","webpack://TaroTrackPlugins/./node_modules/shelljs/src/exec-child.js","webpack://TaroTrackPlugins/./node_modules/shelljs/src/exec.js","webpack://TaroTrackPlugins/./node_modules/shelljs/src/find.js","webpack://TaroTrackPlugins/./node_modules/shelljs/src/grep.js","webpack://TaroTrackPlugins/./node_modules/shelljs/src/head.js","webpack://TaroTrackPlugins/./node_modules/shelljs/src/ln.js","webpack://TaroTrackPlugins/./node_modules/shelljs/src/ls.js","webpack://TaroTrackPlugins/./node_modules/shelljs/src/mkdir.js","webpack://TaroTrackPlugins/./node_modules/shelljs/src/mv.js","webpack://TaroTrackPlugins/./node_modules/shelljs/src/popd.js","webpack://TaroTrackPlugins/./node_modules/shelljs/src/pushd.js","webpack://TaroTrackPlugins/./node_modules/shelljs/src/pwd.js","webpack://TaroTrackPlugins/./node_modules/shelljs/src/rm.js","webpack://TaroTrackPlugins/./node_modules/shelljs/src/sed.js","webpack://TaroTrackPlugins/./node_modules/shelljs/src/set.js","webpack://TaroTrackPlugins/./node_modules/shelljs/src/sort.js","webpack://TaroTrackPlugins/./node_modules/shelljs/src/tail.js","webpack://TaroTrackPlugins/./node_modules/shelljs/src/tempdir.js","webpack://TaroTrackPlugins/./node_modules/shelljs/src/test.js","webpack://TaroTrackPlugins/./node_modules/shelljs/src/to.js","webpack://TaroTrackPlugins/./node_modules/shelljs/src/toEnd.js","webpack://TaroTrackPlugins/./node_modules/shelljs/src/touch.js","webpack://TaroTrackPlugins/./node_modules/shelljs/src/uniq.js","webpack://TaroTrackPlugins/./node_modules/shelljs/src/which.js","webpack://TaroTrackPlugins/./node_modules/uglify-js/lib/ast.js","webpack://TaroTrackPlugins/./node_modules/uglify-js/lib/compress.js","webpack://TaroTrackPlugins/./node_modules/uglify-js/lib/minify.js","webpack://TaroTrackPlugins/./node_modules/uglify-js/lib/mozilla-ast.js","webpack://TaroTrackPlugins/./node_modules/uglify-js/lib/output.js","webpack://TaroTrackPlugins/./node_modules/uglify-js/lib/parse.js","webpack://TaroTrackPlugins/./node_modules/uglify-js/lib/propmangle.js","webpack://TaroTrackPlugins/./node_modules/uglify-js/lib/scope.js","webpack://TaroTrackPlugins/./node_modules/uglify-js/lib/sourcemap.js","webpack://TaroTrackPlugins/./node_modules/uglify-js/lib/transform.js","webpack://TaroTrackPlugins/./node_modules/uglify-js/lib/utils.js","webpack://TaroTrackPlugins/./node_modules/uglify-js/tools/exports.js","webpack://TaroTrackPlugins/./node_modules/uglify-js/tools/node.js","webpack://TaroTrackPlugins/./node_modules/universalify/index.js","webpack://TaroTrackPlugins/(webpack)/buildin/module.js","webpack://TaroTrackPlugins/./node_modules/wrappy/wrappy.js","webpack://TaroTrackPlugins/./node_modules/wxml2json/index.js","webpack://TaroTrackPlugins/./node_modules/wxml2json/lib/Pure-JavaScript-HTML5-Parser/wxmlparser.js","webpack://TaroTrackPlugins/./node_modules/wxml2json/src/wxml2json.js","webpack://TaroTrackPlugins/./src/plugins/index.ts","webpack://TaroTrackPlugins/./src/plugins/src/index.ts","webpack://TaroTrackPlugins/./src/plugins/src/taro/TaroFileManager.ts","webpack://TaroTrackPlugins/./src/plugins/src/taro/TaroTrackInjectLib.ts","webpack://TaroTrackPlugins/./src/plugins/src/taro/TaroTrackPlugin.ts","webpack://TaroTrackPlugins/./src/plugins/src/taro/TaroTrackSourceInjector.ts","webpack://TaroTrackPlugins/./src/plugins/src/taro/WXMLHelper.ts","webpack://TaroTrackPlugins/./src/plugins/src/taro/WxMoudleSourceFragment.ts","webpack://TaroTrackPlugins/./src/plugins/src/taro/config/index.ts","webpack://TaroTrackPlugins/./src/plugins/src/taro/index.ts","webpack://TaroTrackPlugins/./src/plugins/src/taro/tools/htmlParser.ts","webpack://TaroTrackPlugins/./src/plugins/src/taro/tools/wxml2json.ts","webpack://TaroTrackPlugins/external \"assert\"","webpack://TaroTrackPlugins/external \"child_process\"","webpack://TaroTrackPlugins/external \"constants\"","webpack://TaroTrackPlugins/external \"crypto\"","webpack://TaroTrackPlugins/external \"events\"","webpack://TaroTrackPlugins/external \"fs\"","webpack://TaroTrackPlugins/external \"os\"","webpack://TaroTrackPlugins/external \"path\"","webpack://TaroTrackPlugins/external \"stream\"","webpack://TaroTrackPlugins/external \"util\""],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/plugins/index.ts\");\n","export * from \"./src/common\";\nexport * from \"./src/config\";\n","export const TaroTrackLoggerNamespace = 'TaroTrack';\nexport const TaroTrackElementClassName = 'taro-track-element';\nexport const captorEventName = 'TaroTrackTap';\nexport const imageLoadedHandlerName = 'TaroTrackImageLoaded';\nexport const imageErrorHandlerName = 'TaroTrackImageError';\nexport const inputInputHandlerName = 'TaroTrackInputHandler';\nexport const inputFocusHandlerName = 'TaroTrackFocusHandler';\nexport const inputBlurHandlerName = 'TaroTrackBlurHandler';\nexport const inputConfirmHandlerName = 'TaroTrackConfirmHandler';\nexport const inputKeyboardHeightChangeHandlerName = 'TaroTrackKeyboardHeightChangeHandler';\nexport const TaroTrackLibName = 'TaroTrackLib';\nexport const TaroTrackPageEvent = {\n    \"capture-bind:tap\": captorEventName,\n    \"bindload\": imageLoadedHandlerName,\n    \"binderror\": imageErrorHandlerName,\n    \"bindinput\": inputInputHandlerName,\n    \"bindfocus\": inputFocusHandlerName,\n    \"bindblur\": inputBlurHandlerName,\n    \"bindconfirm\": inputConfirmHandlerName,\n    \"bindkeyboardheightchange\": inputKeyboardHeightChangeHandlerName,\n};\n","export { DoubleLinkedList, Node } from \"./src/DoubleLinkedList\";\nexport { guid, shortid } from \"./src/guid\";\nexport { NextableIteratorProtocolWrapper } from \"./src/IteratorProtocol\";\nexport { Logger } from \"./src/logger\";\nexport { Queue, QueueIterator } from \"./src/Queue\";\nexport { WxReviseTimer, getPageVisibilityProps } from \"./src/wx-revise-timer\";\nexport { encode, decode } from \"./src/base64\";\nexport * from \"./src/tools\";\nexport * from \"./src/wx-tools\";\nexport * from \"./src/Logger4Node\";\n","import { NextableIteratorProtocolWrapper } from \"./IteratorProtocol\";\nexport class Node {\n    constructor(data, prev, next) {\n        this.data = data;\n        this.prev = prev;\n        this.next = next;\n    }\n}\nexport class DoubleLinkedList {\n    constructor() {\n        this.header = null;\n        this.tail = null;\n        this.size = 0;\n    }\n    getByIndex(index) {\n        if (index < 0 || index > this.size - 1) {\n            return null;\n        }\n        const n = this.size / 2;\n        if (index <= n) {\n            let current = this.header;\n            for (let i = 0; i <= n && current !== null; i++, current = current.next) {\n                if (i === index) {\n                    return current;\n                }\n            }\n        }\n        else {\n            let current = this.tail;\n            for (let i = this.size - 1; i > n && current !== null; i--, current = current.prev) {\n                if (i === index) {\n                    return current;\n                }\n            }\n        }\n        return null;\n    }\n    length() {\n        return this.size;\n    }\n    get(index) {\n        const node = this.getByIndex(index);\n        return node ? node.data : null;\n    }\n    getNode(index) {\n        return this.getByIndex(index);\n    }\n    locate(element) {\n        let current = this.header;\n        for (let i = 0; i < this.size && current !== null; i++, current = current.next) {\n            if (current.data === element) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    add(element) {\n        if (this.header === null) {\n            this.header = new Node(element, null, null);\n            this.tail = this.header;\n        }\n        else {\n            const node = new Node(element, this.tail, null);\n            this.tail.next = node;\n            this.tail = node;\n        }\n        this.size++;\n    }\n    addAtHeader(element) {\n        const newHead = new Node(element, null, this.header);\n        this.header.prev = newHead;\n        this.header = newHead;\n        if (this.tail === null) {\n            this.tail = this.header;\n        }\n        this.size++;\n    }\n    insert(element, index) {\n        if (index < 0 || index > this.size) {\n            return;\n        }\n        if (this.header === null) {\n            this.add(element);\n        }\n        else {\n            if (index === 0) {\n                this.addAtHeader(element);\n            }\n            else {\n                const prev = this.getByIndex(index - 1);\n                const next = prev.next;\n                const node = new Node(element, prev, next);\n                prev.next = node;\n                next.prev = node;\n                this.size++;\n            }\n        }\n    }\n    delete(index) {\n        if (index < 0 || index > this.size - 1) {\n            return null;\n        }\n        let node = null;\n        if (index === 0) {\n            node = this.header;\n            this.header = this.header ? this.header.next : null;\n            if (this.header !== null) {\n                this.header.prev = null;\n            }\n        }\n        else {\n            const prev = this.getByIndex(index - 1);\n            node = prev.next;\n            prev.next = node.next;\n            if (node.next !== null) {\n                node.next.prev = prev;\n            }\n            if (this.tail === node) {\n                this.tail = prev;\n            }\n            node.prev = null;\n            node.next = null;\n        }\n        this.size--;\n        return node.data;\n    }\n    remove() {\n        return this.delete(this.size - 1);\n    }\n    empty() {\n        return this.size === 0;\n    }\n    toArray() {\n        const list = [];\n        for (const item of this) {\n            list.push(item);\n        }\n        return list;\n    }\n    clear() {\n        this.header = null;\n        this.tail = null;\n        this.size = 0;\n    }\n    display() { }\n    iterator() {\n        return new NextableIteratorProtocolWrapper(this.header);\n    }\n    [Symbol.iterator]() {\n        return this.iterator();\n    }\n}\n","export class NextableIteratorProtocolWrapper {\n    constructor(node) {\n        this.node = node;\n    }\n    next() {\n        const c = this.node;\n        if (c === null) {\n            return { done: true, value: null };\n        }\n        this.node = c.next;\n        return {\n            done: false,\n            value: c.data\n        };\n    }\n}\n","import { blue, white, green, red, yellow, cyan, bold } from 'colors';\nimport { TaroTrackLoggerNamespace } from '@kiner/taro-track-common';\nexport var Logger4NodeType;\n(function (Logger4NodeType) {\n    Logger4NodeType[Logger4NodeType[\"log\"] = 0] = \"log\";\n    Logger4NodeType[Logger4NodeType[\"warn\"] = 1] = \"warn\";\n    Logger4NodeType[Logger4NodeType[\"info\"] = 2] = \"info\";\n    Logger4NodeType[Logger4NodeType[\"error\"] = 3] = \"error\";\n    Logger4NodeType[Logger4NodeType[\"success\"] = 4] = \"success\";\n    Logger4NodeType[Logger4NodeType[\"loading\"] = 5] = \"loading\";\n})(Logger4NodeType || (Logger4NodeType = {}));\nexport class Logger4Node {\n    constructor(namespace = TaroTrackLoggerNamespace, options = { groupCollapsed: false, showLog: true }) {\n        this.namespace = namespace;\n        this.options = options;\n    }\n    static create(namespace = TaroTrackLoggerNamespace, options) {\n        return new Logger4Node(namespace, options);\n    }\n    addColor(args, colorMethod) {\n        return args.map(arg => {\n            if (typeof arg === \"string\") {\n                return colorMethod(arg);\n            }\n            else {\n                return arg;\n            }\n        });\n    }\n    baseLog(type, ...rest) {\n        const [msg, ...args] = rest;\n        if (this.options.showLog === false) {\n            return;\n        }\n        let colorMethod;\n        switch (type) {\n            case Logger4NodeType.log:\n                colorMethod = white;\n                break;\n            case Logger4NodeType.info:\n                colorMethod = green;\n                break;\n            case Logger4NodeType.warn:\n                colorMethod = yellow;\n                break;\n            case Logger4NodeType.error:\n                colorMethod = red;\n                break;\n            case Logger4NodeType.success:\n                colorMethod = blue;\n                break;\n            case Logger4NodeType.loading:\n                colorMethod = cyan;\n                break;\n        }\n        if (this.options.groupCollapsed === true) {\n            const label = `[${this.namespace}:${msg}]`;\n            console.group(label);\n            args.forEach(item => {\n                console.log(item);\n            });\n            console.groupEnd();\n        }\n        else {\n            console.log.apply(console, [bold(white(`[${this.namespace}]`))].concat(this.addColor(rest, colorMethod)));\n        }\n    }\n    log(...args) {\n        this.baseLog(Logger4NodeType.log, ...args);\n    }\n    info(...args) {\n        this.baseLog(Logger4NodeType.info, ...args);\n    }\n    warn(...args) {\n        this.baseLog(Logger4NodeType.warn, ...args);\n    }\n    error(...args) {\n        this.baseLog(Logger4NodeType.error, ...args);\n    }\n    success(...args) {\n        this.baseLog(Logger4NodeType.success, ...args);\n    }\n    loading(...args) {\n        this.baseLog(Logger4NodeType.loading, ...args);\n    }\n}\n","import { NextableIteratorProtocolWrapper } from \"./IteratorProtocol\";\nexport class QueueIterator {\n    constructor(node) {\n        this.current = node;\n    }\n    hasNext() {\n        return this.current !== null;\n    }\n    next() {\n        if (!this.hasNext()) {\n            return null;\n        }\n        const item = this.current.item;\n        this.current = this.current.next;\n        return item;\n    }\n}\nexport class Queue {\n    constructor(limit) {\n        this.first = null;\n        this.last = null;\n        this.count = 0;\n        this.limit = limit || 16;\n    }\n    empty() {\n        return this.first === null;\n    }\n    length() {\n        return this.count;\n    }\n    size() {\n        return this.count;\n    }\n    clear() {\n        this.first = null;\n        this.last = null;\n        this.count = 0;\n    }\n    enqueue(item) {\n        if (this.size() >= this.limit) {\n            this.dequeue();\n        }\n        const node = {\n            item,\n            data: item,\n            next: null\n        };\n        if (this.empty()) {\n            this.first = node;\n            this.last = node;\n        }\n        else {\n            this.last.next = node;\n            this.last = node;\n        }\n        this.count = this.count + 1;\n    }\n    dequeue() {\n        if (this.empty()) {\n            return null;\n        }\n        const item = this.first.item;\n        this.first = this.first.next;\n        this.count = this.count - 1;\n        return item;\n    }\n    peek() {\n        if (this.empty()) {\n            return null;\n        }\n        return this.first.item;\n    }\n    iterator() {\n        return new QueueIterator(this.first);\n    }\n    iterable() {\n        return new NextableIteratorProtocolWrapper(this.first);\n    }\n    [Symbol.iterator]() {\n        return this.iterable();\n    }\n}\n","import decode from \"./base64/decode\";\nimport encode from \"./base64/encode\";\nexport { decode, encode };\n","import Marker from './mark';\nexport default function (input) {\n    const output = [];\n    let chr1, chr2, chr3;\n    let enc1, enc2, enc3, enc4;\n    let i = 0;\n    input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \"\");\n    while (i < input.length) {\n        enc1 = Marker.indexOf(input.charAt(i++));\n        enc2 = Marker.indexOf(input.charAt(i++));\n        enc3 = Marker.indexOf(input.charAt(i++));\n        enc4 = Marker.indexOf(input.charAt(i++));\n        chr1 = (enc1 << 2) | (enc2 >> 4);\n        chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);\n        chr3 = ((enc3 & 3) << 6) | enc4;\n        output.push(chr1);\n        if (enc3 !== 64) {\n            output.push(chr2);\n        }\n        if (enc4 !== 64) {\n            output.push(chr3);\n        }\n    }\n    return output;\n}\n","import Marker from \"./mark\";\nexport default function (array) {\n    if (array.length < 1) {\n        return \"\";\n    }\n    let o1;\n    let o2;\n    let o3;\n    let h1;\n    let h2;\n    let h3;\n    let h4;\n    let bits;\n    let i = 0;\n    let ac = 0;\n    let enc = \"\";\n    let tmp_arr = [];\n    do {\n        o1 = array[i++];\n        o2 = array[i++];\n        o3 = array[i++];\n        bits = o1 << 16 | o2 << 8 | o3;\n        h1 = bits >> 18 & 0x3f;\n        h2 = bits >> 12 & 0x3f;\n        h3 = bits >> 6 & 0x3f;\n        h4 = bits & 0x3f;\n        tmp_arr[ac++] = Marker.charAt(h1) + Marker.charAt(h2) + Marker.charAt(h3) + Marker.charAt(h4);\n    } while (i < array.length);\n    enc = tmp_arr.join(\"\");\n    switch (array.length % 3) {\n        case 1:\n            enc = enc.slice(0, -2) + \"==\";\n            break;\n        case 2:\n            enc = enc.slice(0, -1) + \"=\";\n            break;\n    }\n    return enc;\n}\n","export default \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n","function random(c) {\n    const r = Math.random() * 16 | 0;\n    const v = c === \"x\" ? r : (r & 0x3 | 0x8);\n    return v.toString(16);\n}\nexport function guid() {\n    return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, random);\n}\nexport function shortid() {\n    return \"xxxx-4xxx-yxxx\".replace(/[xy]/g, random);\n}\n","import { TaroTrackLoggerNamespace } from '@kiner/taro-track-common';\nexport class Logger {\n    constructor(namespace) {\n        this.namespace = namespace;\n        Logger.logTpl = `${Logger.logTpl}(${namespace}):`;\n    }\n    static getMessage(message) {\n        return `${Logger.logTpl}${message}`;\n    }\n    log(message, ...args) {\n        if (!Logger.showLog)\n            return;\n        console.groupCollapsed(Logger.getMessage(message));\n        console.log(...args);\n        console.groupEnd();\n    }\n    error(message, ...args) {\n        if (!Logger.showLog)\n            return;\n        console.groupCollapsed(Logger.getMessage(message));\n        console.error(...args);\n        console.groupEnd();\n    }\n    info(message, ...args) {\n        if (!Logger.showLog)\n            return;\n        console.groupCollapsed(Logger.getMessage(message));\n        console.info(...args);\n        console.groupEnd();\n    }\n    warn(message, ...args) {\n        if (!Logger.showLog)\n            return;\n        console.groupCollapsed(Logger.getMessage(message));\n        console.warn(...args);\n        console.groupEnd();\n    }\n}\nLogger.logTpl = `[${TaroTrackLoggerNamespace}]`;\nLogger.showLog = true;\n","const ObjectProto = Object.prototype;\n;\nexport function validatorFactory(type) {\n    return function (value) {\n        return ObjectProto.toString.call(value) === `[object ${type}]`;\n    };\n}\nconst isFunction = validatorFactory(\"Function\");\nconst isString = validatorFactory(\"String\");\nconst isArray = validatorFactory(\"isArray\");\nconst isObject = validatorFactory(\"Object\");\nfunction range(min, max) {\n    return Math.floor(Math.random() * (max - min)) + min;\n}\nfunction serialized(data, encode) {\n    if (!isObject(data)) {\n        return \"\";\n    }\n    return Object.keys(data).map(function (key) {\n        const str = isString(data[key]) ? data[key] : JSON.stringify(data[key]);\n        return `${key}=${encode ? encodeURIComponent(str) : str}`;\n    }).join(\"&\");\n}\nfunction now() {\n    return Date.now();\n}\nfunction isRequired(value) {\n    if (value === void 0 || value === null || value !== value) {\n        return false;\n    }\n    if (typeof value === \"string\") {\n        return value.length > 0;\n    }\n    return true;\n}\nfunction noop() { }\nexport { isFunction, isString, isArray, isObject, range, serialized, now, noop, isRequired };\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nexport function getPageVisibilityProps() {\n    return __awaiter(this, void 0, void 0, function* () {\n        return new Promise(resolve => {\n            wx.onAppHide(() => {\n                resolve({\n                    hidden: true,\n                    event: 'onAppHide'\n                });\n            });\n        });\n    });\n}\nexport class WxReviseTimer {\n    static each(handle) {\n        for (const id in WxReviseTimer.ReviseTimerStore) {\n            if (WxReviseTimer.ReviseTimerStore.hasOwnProperty(id)) {\n                handle(WxReviseTimer.ReviseTimerStore[id]);\n            }\n        }\n    }\n    static reviser() {\n        if (!WxReviseTimer.ReviseTimerSupported) {\n            return;\n        }\n        const time = Date.now();\n        wx.onAppHide(() => {\n            WxReviseTimer.HiddenStatus = true;\n            WxReviseTimer.each(function (counter) {\n                counter.prev = time;\n            });\n        });\n        wx.onAppShow(() => {\n            WxReviseTimer.HiddenStatus = false;\n            WxReviseTimer.each(function (counter) {\n                counter.counter = counter.counter + time - counter.prev;\n                counter.prev = time;\n            });\n        });\n        WxReviseTimer.emit();\n    }\n    static emit() {\n        WxReviseTimer.EndCallbacks.forEach(function (record) {\n            const time = Date.now();\n            const id = record[0];\n            const callback = record[1];\n            if (!WxReviseTimer.ReviseTimerStore[id]) {\n                callback(-1);\n                return;\n            }\n            if (!WxReviseTimer.ReviseTimerSupported) {\n                callback(time - WxReviseTimer.ReviseTimerStore[id].begin);\n                return;\n            }\n            const counter = WxReviseTimer.ReviseTimerStore[id];\n            const value = time - counter.begin - counter.counter;\n            delete WxReviseTimer.ReviseTimerStore[id];\n            callback(value);\n        });\n        WxReviseTimer.EndCallbacks = [];\n    }\n    static start() {\n        const id = WxReviseTimer.ReviseTimerIds++;\n        const time = Date.now();\n        const counter = {\n            begin: time,\n            prev: time,\n            counter: 0\n        };\n        WxReviseTimer.ReviseTimerPCSCounter++;\n        WxReviseTimer.ReviseTimerStore[id] = counter;\n        if (!WxReviseTimer.ReviseTimerSupported) {\n            return id;\n        }\n        if (!WxReviseTimer.ListenerBinded) {\n            wx.onAppHide(() => {\n                WxReviseTimer.reviser();\n            });\n            WxReviseTimer.ListenerBinded = true;\n        }\n        return id;\n    }\n    static end(id, callback) {\n        WxReviseTimer.EndCallbacks.push([id, callback]);\n        if (!WxReviseTimer.HiddenStatus) {\n            WxReviseTimer.emit();\n        }\n        return;\n    }\n}\nWxReviseTimer.ReviseTimerSupported = true;\nWxReviseTimer.ReviseTimerStore = {};\nWxReviseTimer.ReviseTimerIds = 0;\nWxReviseTimer.ReviseTimerPCSCounter = 0;\nWxReviseTimer.ListenerBinded = false;\nWxReviseTimer.EndCallbacks = [];\n","import { Logger } from '..';\nconst logger = new Logger(\"code/wx-tools\");\nexport function getWxReferrer() {\n    const pages = getCurrentPages().map(item => item.route);\n    logger.info(`taro-track:getWxReferrer`, pages);\n    return pages.length === 1 ? '' : pages[pages.length - 2];\n}\nexport function getWxCurrentHref() {\n    const pages = getCurrentPages().map(item => item.route);\n    return pages[pages.length - 1];\n}\nexport function getWxCurrentPagesStack() {\n    return getCurrentPages();\n}\nexport function getWxNetwork() {\n    return new Promise(resolve => {\n        wx.getNetworkType({\n            success(result) {\n                resolve(result.networkType);\n            }\n        });\n    });\n}\nexport function getWxSystemInfo() {\n    let os = wx.getSystemInfoSync();\n    return {\n        osInfo: function () {\n            return `${os.system}`;\n        },\n        wechatInfo: function () {\n            return `${os.version} ${os.SDKVersion}`;\n        },\n        langInfo: function () {\n            return `${os.language}`;\n        },\n        originalOs: os\n    };\n}\nexport function storage(key, val) {\n    if (val === undefined) {\n        return wx.getStorageSync(key);\n    }\n    else {\n        wx.setStorageSync(key, val);\n    }\n}\nexport const sessionStorageTimeKey = 'SESSION_STORAGE_DATE_';\nexport const sessionStorageKey = 'SESSION_STORAGE_';\nexport function sessionStorage(key, val, expired) {\n    const expiredKey = `${sessionStorageTimeKey}${key}`;\n    const valKey = `${sessionStorageKey}${key}`;\n    if (val === undefined) {\n        const expiredTime = storage(expiredKey);\n        if (expiredTime) {\n            const date = new Date();\n            date.setTime(parseInt(expiredTime));\n            if (date.getTime() - Date.now() <= 0) {\n                storage.remove(valKey);\n                storage.remove(expiredKey);\n                return null;\n            }\n            return storage(valKey);\n        }\n        return storage(valKey);\n    }\n    else {\n        storage(valKey, val);\n        storage(expiredKey, expired);\n    }\n}\nstorage.remove = function (key) {\n    wx.removeStorageSync(key);\n};\nlet fsm;\nexport function getFileSystemManager() {\n    return fsm ? fsm : (fsm = wx.getFileSystemManager());\n}\nexport function toggleAppShow(cb) {\n    return new Promise(resolve => {\n        wx.onAppShow(() => {\n            cb(true);\n            resolve(true);\n        });\n        wx.onAppShow(() => {\n            cb(true);\n            resolve(false);\n        });\n    });\n}\nlet wxRequest, wxUpload, wxDownload;\nexport function getWxRequest() {\n    return wxRequest ? wxRequest : (wxRequest = wx.request);\n}\nexport function overrideWxRequest(newRequest) {\n    Object.defineProperty(wx, \"request\", { value: newRequest });\n}\nexport function getWxUpload() {\n    return wxUpload ? wxUpload : (wxUpload = wx.uploadFile);\n}\nexport function overrideWxUpload(newUpload) {\n    Object.defineProperty(wx, \"uploadFile\", { value: newUpload });\n}\nexport function getWxDownload() {\n    return wxDownload ? wxDownload : (wxDownload = wx.downloadFile);\n}\nexport function overrideWxDownload(newDownload) {\n    Object.defineProperty(wx, \"downloadFile\", { value: newDownload });\n}\nexport function getWxNetworkType(options) {\n    return new Promise((resolve, reject) => {\n        wx.getNetworkType({\n            success(opts) {\n                resolve(opts);\n                options && options.success(opts);\n            },\n            fail(opts) {\n                reject(opts);\n                options && options.fail(opts);\n            }\n        });\n    });\n}\nexport function onWxNetworkStatusChange(cb) {\n    wx.onNetworkStatusChange(result => {\n        cb(result);\n    });\n}\nconst lineAndColNumReg = /\\(.*\\:(\\d+)\\:(\\d+)\\)$/gi;\nexport function resolveErrorMessageLineAndColNum(str) {\n    const res = lineAndColNumReg.exec(str);\n    if (res) {\n        return {\n            line: parseInt(res[1]),\n            column: parseInt(res[2])\n        };\n    }\n    else {\n        return {\n            line: -1,\n            column: -1\n        };\n    }\n}\nexport function parseErrorMessage(error) {\n    if (!error || !error.split) {\n        return {\n            message: error,\n            source: error,\n            line: -1,\n            column: -1\n        };\n    }\n    const errors = error.split('\\n');\n    const { line, column } = resolveErrorMessageLineAndColNum(errors.filter(item => item.match(/\\S*at/))[0]);\n    let message = errors[0];\n    let source = error;\n    return {\n        message,\n        source,\n        line,\n        column\n    };\n}\nexport function compareVersion(v1, v2) {\n    const v1Arr = v1.split('.');\n    const v2Arr = v2.split('.');\n    const len = Math.max(v1Arr.length, v2Arr.length);\n    while (v1Arr.length < len) {\n        v1Arr.push('0');\n    }\n    while (v2.length < len) {\n        v2Arr.push('0');\n    }\n    for (let i = 0; i < len; i++) {\n        const num1 = parseInt(v1Arr[i]);\n        const num2 = parseInt(v2Arr[i]);\n        if (num1 > num2) {\n            return 1;\n        }\n        else if (num1 < num2) {\n            return -1;\n        }\n    }\n    return 0;\n}\nexport function canIUse(targetVersion) {\n    const version = wx.getSystemInfoSync().SDKVersion;\n    return compareVersion(version, targetVersion) >= 0;\n}\nexport function getWxPage() {\n    return Page;\n}\nexport function overrideWxPage(newPage) {\n    Page = newPage;\n}\nexport function getWxApp() {\n    return App;\n}\nexport function overrideWxApp(newApp) {\n    App = newApp;\n}\nexport function getWxComponent() {\n    return Component;\n}\nexport function overrideWxComponent(newComponent) {\n    Component = newComponent;\n}\nexport function getWxPerformance() {\n    try {\n        return wx.getPerformance();\n    }\n    catch (e) {\n        return null;\n    }\n}\nexport function createWxPerformanceObserver(cb) {\n    try {\n        return getWxPerformance().createObserver((entryList) => {\n            cb && cb(entryList);\n        });\n    }\n    catch (e) {\n        return null;\n    }\n}\n","export * from \"./src/impl\";\nexport * from \"./src/inter\";\nexport * from \"./src/performance/Performance\";\nexport * from \"./src/user-behavior/UserBehavior\";\nexport * from \"./src/OverrideWechatApp\";\nexport * from \"./src/OverrideWechatPage\";\nexport * from \"./src/WechatDownload\";\nexport * from \"./src/WechatUpload\";\nexport * from \"./src/WechatRequest\";\nexport * from \"./src/WechatMonitor\";\nexport * from \"./src/user-behavior/Track\";\n","import { getWxApp, overrideWxApp, sessionStorageKey, sessionStorageTimeKey, storage } from '@kiner/taro-track-corejs';\nexport var proxyWechatAppLiftHooks;\n(function (proxyWechatAppLiftHooks) {\n    proxyWechatAppLiftHooks[\"onShow\"] = \"onShow\";\n    proxyWechatAppLiftHooks[\"onHide\"] = \"onHide\";\n    proxyWechatAppLiftHooks[\"onLaunch\"] = \"onLaunch\";\n    proxyWechatAppLiftHooks[\"onPageNotFound\"] = \"onPageNotFound\";\n    proxyWechatAppLiftHooks[\"onError\"] = \"onError\";\n})(proxyWechatAppLiftHooks || (proxyWechatAppLiftHooks = {}));\nconst proxyMethods = [\n    'onShow',\n    'onHide',\n    'onLaunch',\n    'onPageNotFound',\n    'onError'\n];\nexport class OverrideWechatApp {\n    constructor() {\n        this.wechatOriginalApp = getWxApp();\n    }\n    initialize(AppHooksCb) {\n        const _App = getWxApp();\n        const wrapper = function (options) {\n            proxyMethods.forEach(methodName => {\n                const _originalHooks = options[methodName];\n                const wrapperMethod = function (...args) {\n                    AppHooksCb(methodName);\n                    if (methodName === 'onLaunch') {\n                        const res = wx.getStorageInfoSync();\n                        res.keys.forEach(key => {\n                            if (key.startsWith(sessionStorageKey) || key.startsWith(sessionStorageTimeKey)) {\n                                storage.remove(key);\n                            }\n                        });\n                    }\n                    return _originalHooks && _originalHooks.call(this, ...args);\n                };\n                options = Object.assign(Object.assign({}, options), { [methodName]: wrapperMethod });\n            });\n            _App(options);\n        };\n        overrideWxApp(wrapper);\n    }\n    destroy() {\n        overrideWxApp(this.wechatOriginalApp);\n    }\n}\n","import { getWxComponent, getWxPage, overrideWxComponent, overrideWxPage } from '@kiner/taro-track-corejs';\nconst proxyMethods = [\n    \"onShow\",\n    \"onHide\",\n    \"onReady\",\n    \"onLoad\",\n    \"onUnload\",\n    \"created\",\n    \"attached\",\n    \"ready\",\n    \"moved\",\n    \"detached\",\n];\nconst pageHooksCbs = [];\nexport class OverrideWechatPage {\n    constructor(isTaro = true) {\n        this.isTaro = isTaro;\n        this.wechatOriginalPage = getWxPage();\n        this.wechatOriginalComponent = getWxComponent();\n    }\n    initialize(pageHooksCb) {\n        const _Page = getWxPage();\n        const _Component = getWxComponent();\n        pageHooksCbs.push(pageHooksCb);\n        const self = this;\n        const needProxyMethods = proxyMethods.filter(item => this.isTaro ? !item.startsWith('on') : item.startsWith('on'));\n        const wrapper = function (options) {\n            needProxyMethods.forEach(methodName => {\n                const _originalHooks = options[methodName];\n                const wrapperMethod = function (...args) {\n                    pageHooksCbs.forEach((fn) => fn(methodName, options));\n                    return _originalHooks && _originalHooks.call(this, ...args);\n                };\n                options = Object.assign(Object.assign({}, options), { [methodName]: wrapperMethod });\n            });\n            let res = \"\";\n            if (self.isTaro) {\n                res = _Component(options);\n            }\n            else {\n                _Page(options);\n            }\n            options.__router__ = wrapper.__route__ = res;\n            options.__isPage__ = res.startsWith('pages/');\n            return res;\n        };\n        wrapper.__route__ = '';\n        wrapper.__isPage__ = false;\n        if (this.isTaro) {\n            overrideWxComponent(wrapper);\n        }\n        else {\n            overrideWxPage(wrapper);\n        }\n    }\n    destroy() {\n        overrideWxPage(this.wechatOriginalPage);\n        overrideWxComponent(this.wechatOriginalComponent);\n    }\n}\n","import { canIUse, getWxDownload, overrideWxDownload, WxReviseTimer as ReviseTimer } from '@kiner/taro-track-corejs';\nimport { WechatNetworkRecordType, NetworkRecordStatus } from './inter/network';\nexport class OverrideWechatDownload {\n    constructor() {\n        this.downloadFile = getWxDownload();\n    }\n    initialize(callback, timeout) {\n        const ListenTimeout = typeof timeout === 'number' && timeout >= 0;\n        const _downloadFile = getWxDownload();\n        const wrapper = function (options) {\n            const start = ReviseTimer.start();\n            const { url } = options;\n            const id = ListenTimeout\n                ? setTimeout(onTimeout, timeout)\n                : null;\n            let doTimeout = false;\n            function onTimeout() {\n                if (doTimeout) {\n                    return;\n                }\n                doTimeout = true;\n                ReviseTimer.end(start, (duration) => {\n                    callback({\n                        url,\n                        duration,\n                        status: NetworkRecordStatus.Timeout,\n                        type: WechatNetworkRecordType.download\n                    });\n                });\n            }\n            const _success = options.success;\n            const _fail = options.fail;\n            options.success = function (res) {\n                if ((res.statusCode >= 400 && canIUse('2.11.0')) || !canIUse('2.11.0')) {\n                    if (doTimeout) {\n                        return;\n                    }\n                    if (id !== null) {\n                        clearTimeout(id);\n                    }\n                    ReviseTimer.end(start, (duration) => {\n                        callback({\n                            url,\n                            duration,\n                            status: res.statusCode,\n                            type: WechatNetworkRecordType.download\n                        });\n                    });\n                }\n                _success && _success(res);\n                return res;\n            };\n            options.fail = function (reason) {\n                if (doTimeout) {\n                    return;\n                }\n                if (id !== null) {\n                    clearTimeout(id);\n                }\n                ReviseTimer.end(start, (duration) => {\n                    callback({\n                        url,\n                        duration,\n                        status: NetworkRecordStatus.Error,\n                        type: WechatNetworkRecordType.download\n                    });\n                });\n                _fail && _fail(reason);\n                return reason;\n            };\n            return _downloadFile(options);\n        };\n        overrideWxDownload(wrapper);\n    }\n    destroy() {\n        overrideWxDownload(this.downloadFile);\n    }\n}\n","import { MonitorEventName, MonitorIOType } from \"./inter/monitor\";\nimport { OverrideWechatPage } from \"./OverrideWechatPage\";\nimport { OverrideWechatRequest } from \"./WechatRequest\";\nimport { OverrideWechatDownload } from \"./WechatDownload\";\nimport { OverrideWechatUpload } from \"./WechatUpload\";\nimport { canIUse, createWxPerformanceObserver, getWxPerformance, getWxReferrer, storage } from '@kiner/taro-track-corejs';\nimport { proxyWxLifeHooks } from '..';\nconst DefaultMonitorOptions = {\n    timeout: null\n};\nconst wechatCurrentUrlStorageKey = 'wechatCurrentUrlStorageKey';\nexport class Monitor {\n    constructor(options) {\n        this.callbacks = {};\n        this.options = Object.assign(Object.assign({}, DefaultMonitorOptions), options);\n        this.performance = getWxPerformance();\n        this.timing = performance.timing;\n        this.initialize();\n    }\n    static create(options) {\n        if (Monitor.ins !== null) {\n            Monitor.ins.destroy();\n        }\n        Monitor.ins = new Monitor(options);\n        return Monitor.ins;\n    }\n    getNavigationStartTime() {\n        return Math.floor(this.timing.navigationStart || -1);\n    }\n    on(type, callback) {\n        if (this.callbacks[type]) {\n            this.callbacks[type].push(callback);\n        }\n        else {\n            this.callbacks[type] = [callback];\n        }\n        return this;\n    }\n    emit(type, entity) {\n        const callbacks = this.callbacks[type];\n        if (!callbacks) {\n            return;\n        }\n        for (const cb of callbacks) {\n            try {\n                cb(entity);\n            }\n            catch (e) {\n            }\n        }\n    }\n    initialize() {\n        this.createResourceObserver();\n        this.wechatRequest = new OverrideWechatRequest();\n        this.wechatDownload = new OverrideWechatDownload();\n        this.wechatUpload = new OverrideWechatUpload();\n        this.overrideWechatPage = new OverrideWechatPage(this.options.isTaro);\n        this.wechatRequest.initialize((record) => this.emitNetworkRecord(record), this.options.timeout);\n        this.wechatUpload.initialize((record) => this.emitNetworkRecord(record), this.options.timeout);\n        this.wechatDownload.initialize((record) => this.emitNetworkRecord(record), this.options.timeout);\n        this.overrideWechatPage.initialize((methodName, options) => {\n            if (!options.__isPage__) {\n                return;\n            }\n            switch (methodName) {\n                case proxyWxLifeHooks.onLoad:\n                    this.onPageLoad();\n                    const prevUrl = storage(wechatCurrentUrlStorageKey);\n                    const href = getWxReferrer();\n                    if (prevUrl !== href) {\n                        this.emitUrlChange(href);\n                        storage(wechatCurrentUrlStorageKey, href);\n                    }\n                    break;\n                case proxyWxLifeHooks.onReady:\n                    this.onPageReady();\n                    break;\n                case proxyWxLifeHooks.onShow:\n                    break;\n            }\n        });\n    }\n    emitUrlChange(url) {\n        this.emit(MonitorEventName.OnURLChange, { url });\n    }\n    destroy() {\n        this.observer && this.observer.disconnect();\n        this.wechatRequest && this.wechatRequest.destroy();\n    }\n    emitNetworkRecord(record) {\n        this.emit(MonitorIOType.OnResource, {\n            DNSLookup: -1,\n            TCPConnected: -1,\n            RequestStart: -1,\n            ResponseStart: -1,\n            Duration: record.duration,\n            URI: record.url,\n            Type: \"\",\n            ResourceType: record.type,\n            StatusCode: record.status\n        });\n    }\n    onPageLoad() {\n        this.emit(MonitorIOType.OnDNSParseTime, Monitor.createIOEntityByDuration(this.getDNSLookupTime()));\n        this.emit(MonitorIOType.OnTCPSetUpTime, Monitor.createIOEntityByDuration(this.getTCPSetUpTime()));\n        this.emit(MonitorIOType.OnConnectTime, Monitor.createIOEntityByDuration(this.getTCPConnectTime()));\n        this.emit(MonitorIOType.OnDOMLoadTime, Monitor.createIOEntityByDuration(this.getDOMLoadTime()));\n    }\n    onPageReady() {\n        this.emit(MonitorIOType.OnPageLoadTime, Monitor.createIOEntityByDuration(this.getPageLoadTime()));\n        this.emit(MonitorIOType.OnResourceLoadTime, Monitor.createIOEntityByDuration(this.getResourceLoadTime()));\n    }\n    static createIOEntityByDuration(duration) {\n        return {\n            DNSLookup: -1,\n            TCPConnected: -1,\n            RequestStart: -1,\n            ResponseStart: -1,\n            Duration: duration,\n            URI: \"\",\n            Type: \"\",\n            ResourceType: \"\",\n            StatusCode: 200\n        };\n    }\n    getDNSLookupTime() {\n        return Math.floor(this.timing.domainLookupEnd - this.timing.domainLookupStart);\n    }\n    getTCPSetUpTime() {\n        return Math.floor(this.timing.connectEnd - this.timing.connectStart);\n    }\n    getTCPConnectTime() {\n        return Math.floor(this.timing.responseEnd - this.timing.responseStart);\n    }\n    getDOMLoadTime() {\n        return Math.floor(this.timing.domContentLoadedEventStart - this.timing.navigationStart);\n    }\n    getPageLoadTime() {\n        return Math.floor(this.timing.domComplete - this.timing.responseStart);\n    }\n    getResourceLoadTime() {\n        const timing = (this.performance.getEntriesByType(\"resource\"));\n        const total = timing.reduce(function (p, c) {\n            return p + (c.responseEnd - c.startTime);\n        }, 0);\n        return Math.floor(total);\n    }\n    createResourceObserver() {\n        if (canIUse('2.11.0')) {\n            this.observer = createWxPerformanceObserver((entries) => {\n                const records = entries.getEntries();\n                const io = [];\n                for (const r of records) {\n                    this.emit(MonitorIOType.OnResource, {\n                        DNSLookup: Math.floor(r.domainLookupEnd - r.domainLookupStart),\n                        TCPConnected: Math.floor(r.connectEnd - r.connectStart),\n                        RequestStart: Math.floor(r.requestStart - r.connectEnd),\n                        ResponseStart: Math.floor(r.responseStart - r.connectEnd),\n                        Duration: Math.floor(r.duration),\n                        URI: r.name,\n                        Type: Monitor.getResourceType(r),\n                        ResourceType: r.initiatorType,\n                        StatusCode: 200\n                    });\n                }\n            });\n            this.observer && this.observer.observe({ entryTypes: [\"load\", \"fetch\", \"request\"] });\n        }\n    }\n    static getResourceType(record) {\n        if (record.entryType) {\n            return record.entryType;\n        }\n        if (record.name && record.name.length > 0) {\n            return record.name.replace(/^(.+)?\\.(.+)$/, \"$2\");\n        }\n        return \"\";\n    }\n}\nMonitor.ins = null;\n","import { WechatNetworkRecordType, NetworkRecordStatus } from './inter/network';\nimport { canIUse, getWxRequest, overrideWxRequest, WxReviseTimer as ReviseTimer } from '@kiner/taro-track-corejs';\nexport class OverrideWechatRequest {\n    constructor() {\n        this.request = getWxRequest();\n    }\n    initialize(callback, timeout) {\n        const ListenTimeout = typeof timeout === 'number' && timeout >= 0;\n        const _request = getWxRequest();\n        const wrapper = function (options) {\n            const start = ReviseTimer.start();\n            const method = options && options.method ? options.method.toUpperCase() : 'GET';\n            const { url } = options;\n            const id = ListenTimeout\n                ? setTimeout(onTimeout, timeout)\n                : null;\n            let doTimeout = false;\n            function onTimeout() {\n                if (doTimeout) {\n                    return;\n                }\n                doTimeout = true;\n                ReviseTimer.end(start, (duration) => {\n                    callback({\n                        url,\n                        method,\n                        duration,\n                        status: NetworkRecordStatus.Timeout,\n                        type: WechatNetworkRecordType.request\n                    });\n                });\n            }\n            const _success = options.success;\n            const _fail = options.fail;\n            options.success = function (res) {\n                if ((res.statusCode >= 400 && canIUse('2.11.0')) || !canIUse('2.11.0')) {\n                    if (doTimeout) {\n                        return;\n                    }\n                    if (id !== null) {\n                        clearTimeout(id);\n                    }\n                    ReviseTimer.end(start, (duration) => {\n                        callback({\n                            url,\n                            method,\n                            duration,\n                            status: res.statusCode,\n                            type: WechatNetworkRecordType.request\n                        });\n                    });\n                }\n                _success && _success(res);\n                return res;\n            };\n            options.fail = function (reason) {\n                if (doTimeout) {\n                    return;\n                }\n                if (id !== null) {\n                    clearTimeout(id);\n                }\n                ReviseTimer.end(start, (duration) => {\n                    callback({\n                        url,\n                        method,\n                        duration,\n                        status: NetworkRecordStatus.Error,\n                        type: WechatNetworkRecordType.request\n                    });\n                });\n                _fail && _fail(reason);\n                return reason;\n            };\n            return _request(options);\n        };\n        overrideWxRequest(wrapper);\n    }\n    destroy() {\n        overrideWxRequest(this.request);\n    }\n}\n","import { WechatNetworkRecordType, NetworkRecordStatus } from \"./inter/network\";\nimport { canIUse, getWxUpload, overrideWxUpload, WxReviseTimer as ReviseTimer } from '@kiner/taro-track-corejs';\nexport class OverrideWechatUpload {\n    constructor() {\n        this.uploadFile = getWxUpload();\n    }\n    initialize(callback, timeout) {\n        const ListenTimeout = typeof timeout === \"number\" && timeout >= 0;\n        const _uploadFile = getWxUpload();\n        const wrapper = function (options) {\n            const start = ReviseTimer.start();\n            const { url } = options;\n            const id = ListenTimeout\n                ? setTimeout(onTimeout, timeout)\n                : null;\n            let doTimeout = false;\n            function onTimeout() {\n                if (doTimeout) {\n                    return;\n                }\n                doTimeout = true;\n                ReviseTimer.end(start, (duration) => {\n                    callback({\n                        url,\n                        duration,\n                        status: NetworkRecordStatus.Timeout,\n                        type: WechatNetworkRecordType.upload\n                    });\n                });\n            }\n            const _success = options.success;\n            const _fail = options.fail;\n            options.success = function (res) {\n                if ((res.statusCode >= 400 && canIUse('2.11.0')) || !canIUse('2.11.0')) {\n                    if (doTimeout) {\n                        return;\n                    }\n                    if (id !== null) {\n                        clearTimeout(id);\n                    }\n                    ReviseTimer.end(start, (duration) => {\n                        callback({\n                            url,\n                            duration,\n                            status: res.statusCode,\n                            type: WechatNetworkRecordType.upload\n                        });\n                    });\n                }\n                _success && _success(res);\n                return res;\n            };\n            options.fail = function (reason) {\n                if (doTimeout) {\n                    return;\n                }\n                if (id !== null) {\n                    clearTimeout(id);\n                }\n                ReviseTimer.end(start, (duration) => {\n                    callback({\n                        url,\n                        duration,\n                        status: NetworkRecordStatus.Error,\n                        type: WechatNetworkRecordType.upload\n                    });\n                });\n                _fail && _fail(reason);\n                return reason;\n            };\n            return _uploadFile(options);\n        };\n        overrideWxUpload(wrapper);\n    }\n    destroy() {\n        overrideWxUpload(this.uploadFile);\n    }\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Constant } from \"./Constant\";\nimport { getWxCurrentHref, getWxNetworkType, getWxReferrer, getWxSystemInfo, guid } from '@kiner/taro-track-corejs';\nexport function getCarrier() {\n    return \"unknow\";\n}\nconst constant = new Constant();\nexport var ResType;\n(function (ResType) {\n    ResType[ResType[\"PAGE\"] = 1] = \"PAGE\";\n    ResType[ResType[\"VIDEO\"] = 2] = \"VIDEO\";\n})(ResType || (ResType = {}));\nexport function getBaseExtFields(baseInfo = {}) {\n    const wxSystemInfo = getWxSystemInfo();\n    return {\n        'open_id': baseInfo.app_id || \"\",\n        'page_unique_id': `${baseInfo.open_id || guid()}${Date.now()}`,\n        'url': getWxCurrentHref(),\n        'app_id': baseInfo.app_id || \"\",\n        'app_name': baseInfo.app_name || \"\",\n        'terminal': wxSystemInfo.originalOs.model,\n        'res_type': ResType.PAGE\n    };\n}\nexport function getBaseFields(baseInfo = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const wxSystemInfo = getWxSystemInfo();\n        const ScreenPixel = `${wxSystemInfo.originalOs.screenWidth}*${wxSystemInfo.originalOs.screenHeight}`;\n        const DistinctID = constant.getDistinctID();\n        const SessionID = constant.getSessionID();\n        return {\n            time: new Date().valueOf(),\n            app_name: baseInfo.app_name || \"\",\n            app_version: baseInfo.app_version || \"\",\n            distinct_id: DistinctID,\n            session_id: SessionID,\n            system_name: wxSystemInfo.originalOs.system,\n            system_version: wxSystemInfo.originalOs.version,\n            device_brand: wxSystemInfo.originalOs.brand,\n            device_model: wxSystemInfo.originalOs.model,\n            device_name: wxSystemInfo.originalOs.platform,\n            browser: wxSystemInfo.originalOs.model,\n            browser_version: wxSystemInfo.originalOs.SDKVersion,\n            browser_agent: \"\",\n            screen_dpi: -1,\n            screen_pixel: ScreenPixel,\n            url: getWxCurrentHref(),\n            referrer: getWxReferrer(),\n            client_ip: \"\",\n            network: (yield getWxNetworkType()).networkType,\n            carrier: getCarrier(),\n            ui: baseInfo.ui,\n            pl: getWxCurrentHref(),\n            os: wxSystemInfo.osInfo()\n        };\n    });\n}\n","import { sessionStorage, storage, guid } from \"@kiner/taro-track-corejs\";\nexport class Constant {\n    constructor() {\n        this.session = \"sid\";\n        this.guid = \"guid\";\n    }\n    getSessionID() {\n        let session = sessionStorage(this.session);\n        if (!session) {\n            session = guid();\n            sessionStorage(this.session, session);\n        }\n        return session;\n    }\n    getDistinctID() {\n        let juid = storage(this.guid);\n        if (!juid) {\n            juid = guid();\n            storage(this.guid, juid);\n        }\n        return juid;\n    }\n}\n","import { isRequired } from '@kiner/taro-track-corejs';\nexport class NQueue {\n    constructor(options) {\n        if (options && isRequired(options.size)) {\n            this.max = options.size;\n        }\n        else {\n            this.max = 6;\n        }\n        this.queues = [];\n    }\n    fill(data) {\n        for (let i = 0; i < this.max; i++) {\n            this.queues.push(data);\n        }\n    }\n    push(data) {\n        if (this.count() >= this.max) {\n            this.shift();\n        }\n        this.queues.push(data);\n    }\n    shift() {\n        return this.queues.shift();\n    }\n    first() {\n        return this.queues[0];\n    }\n    last() {\n        return this.queues[this.queues.length - 1];\n    }\n    count() {\n        return this.queues.length;\n    }\n    get() {\n        return this.queues;\n    }\n    getByIndex(index) {\n        return this.queues[index];\n    }\n    reset() {\n        this.queues = [];\n    }\n    toString() {\n        return this.queues.toString();\n    }\n}\n","import { ListenerEventCallbackType, ListenerEventType } from \"../inter/listener\";\nimport { NQueue as Queue } from './Queue';\nimport { getWxCurrentHref, parseErrorMessage, toggleAppShow } from '@kiner/taro-track-corejs';\nclass EventEmitter {\n    constructor() {\n        this.callbacks = {};\n    }\n    getCallbacks(event) {\n        return this.callbacks[event] || (this.callbacks[event] = []);\n    }\n    on(event, callback) {\n        const callbacks = this.getCallbacks(event);\n        if (callbacks.indexOf(callback) < 1) {\n            callbacks.push(callback);\n        }\n        return this;\n    }\n    emit(event, ...data) {\n        const callbacks = this.getCallbacks(event);\n        for (const callback of callbacks) {\n            callback(data[0], data[1], data[2], data[3]);\n        }\n        return this;\n    }\n}\nfunction consoleProxy(cb) {\n    const { log, error } = console;\n    console.error = function (...args) {\n        cb('error', args[0]);\n        error.call(console, ...args);\n    };\n}\nexport class WechatListener {\n    constructor(options) {\n        const opts = options || {};\n        this.root = opts.root;\n        this.types = opts.types || [\n            ListenerEventType.Click,\n            ListenerEventType.Change\n        ];\n        this.queue = new Queue({ size: opts.size || 6 });\n        this.emitter = new EventEmitter();\n        this.inlitialize();\n    }\n    inlitialize() {\n        setTimeout(() => {\n            this.emitter.emit(ListenerEventCallbackType.OnPageView, getWxCurrentHref());\n        }, 0);\n        consoleProxy((type, error) => {\n            const onWindowErrorBackpass = parseErrorMessage(error);\n            if (type === \"error\") {\n                const backpass = this.queue.get();\n                this.queue.reset();\n                this.emitter.emit(ListenerEventCallbackType.OnUIError, {\n                    backpass,\n                    error: onWindowErrorBackpass\n                });\n            }\n        });\n        this.listenVisiableChange();\n    }\n    getListenerBackpass(event) {\n        const target = event.target;\n        const tag = target.tagName.toLowerCase();\n        return {\n            tag,\n            eventType: event.type,\n            url: location.href,\n            cssPath: \"\",\n            mark: \"\"\n        };\n    }\n    listenVisiableChange() {\n        toggleAppShow((isShow => {\n            this.emitter.emit(ListenerEventCallbackType.OnVisiable, !isShow);\n        }));\n    }\n    on(event, callback) {\n        this.emitter.on(event, callback);\n    }\n}\n","export * from \"./Constant\";\nexport * from \"./BaseFields\";\nexport * from \"./WechatListener\";\nexport * from \"./Queue\";\n","export * from \"./listener\";\nexport { MonitorEventName, MonitorIOType, MonitorNetworkType } from \"./monitor\";\nexport * from \"./network\";\nexport * from './pageLife';\n","export var ListenerEventType;\n(function (ListenerEventType) {\n    ListenerEventType[\"Click\"] = \"click\";\n    ListenerEventType[\"Change\"] = \"change\";\n    ListenerEventType[\"Focus\"] = \"focus\";\n    ListenerEventType[\"MouseOver\"] = \"mouseover\";\n    ListenerEventType[\"MouseOut\"] = \"mouseout\";\n    ListenerEventType[\"TouchStart\"] = \"touchstart\";\n    ListenerEventType[\"TouchMove\"] = \"touchmove\";\n    ListenerEventType[\"TouchEnd\"] = \"touchend\";\n})(ListenerEventType || (ListenerEventType = {}));\nexport var ListenerEventCallbackType;\n(function (ListenerEventCallbackType) {\n    ListenerEventCallbackType[\"OnUIEvent\"] = \"OnUIEvent\";\n    ListenerEventCallbackType[\"OnUIError\"] = \"OnUIError\";\n    ListenerEventCallbackType[\"OnURLChange\"] = \"OnURLChange\";\n    ListenerEventCallbackType[\"OnHashChange\"] = \"OnHashChange\";\n    ListenerEventCallbackType[\"OnPageView\"] = \"OnPageView\";\n    ListenerEventCallbackType[\"OnVisiable\"] = \"OnVisiable\";\n})(ListenerEventCallbackType || (ListenerEventCallbackType = {}));\n","export var MonitorEventName;\n(function (MonitorEventName) {\n    MonitorEventName[\"OnUIError\"] = \"OnUIError\";\n    MonitorEventName[\"OnUIEvent\"] = \"OnUIEvent\";\n    MonitorEventName[\"OnPageView\"] = \"OnPageView\";\n    MonitorEventName[\"OnURLChange\"] = \"OnURLChange\";\n    MonitorEventName[\"OnHashChange\"] = \"OnHashChange\";\n    MonitorEventName[\"OnVisiableChange\"] = \"OnVisiableChange\";\n    MonitorEventName[\"PageLoadTime\"] = \"PageLoadTime\";\n    MonitorEventName[\"DOMLoadTime\"] = \"DOMLoadTime\";\n    MonitorEventName[\"TCPCompletedTime\"] = \"TCPCompletedTime\";\n    MonitorEventName[\"TCPConnectTime\"] = \"TCPConnectTime\";\n    MonitorEventName[\"DNSLookupTime\"] = \"DNSLookupTime\";\n    MonitorEventName[\"ResourceLoadTime\"] = \"ResourceLoadTime\";\n    MonitorEventName[\"OnResource\"] = \"OnResource\";\n})(MonitorEventName || (MonitorEventName = {}));\n;\nexport var MonitorIOType;\n(function (MonitorIOType) {\n    MonitorIOType[\"OnDNSParseTime\"] = \"OnDNSParseTime\";\n    MonitorIOType[\"OnTCPSetUpTime\"] = \"OnTCPSetUpTime\";\n    MonitorIOType[\"OnConnectTime\"] = \"OnConnectTime\";\n    MonitorIOType[\"OnDOMLoadTime\"] = \"OnDOMLoadTime\";\n    MonitorIOType[\"OnPageLoadTime\"] = \"OnPageLoadTime\";\n    MonitorIOType[\"OnResourceLoadTime\"] = \"OnResourceLoadTime\";\n    MonitorIOType[\"OnResource\"] = \"OnResource\";\n    MonitorIOType[\"OnFirstPaint\"] = \"OnFirstPaint\";\n})(MonitorIOType || (MonitorIOType = {}));\n;\nexport var MonitorNetworkType;\n(function (MonitorNetworkType) {\n    MonitorNetworkType[\"OnNetworkOnline\"] = \"OnNetworkOnline\";\n    MonitorNetworkType[\"OnNetworkOffline\"] = \"OnNetworkOffline\";\n    MonitorNetworkType[\"OnNetworkTypeChange\"] = \"OnNetworkTypeChange\";\n})(MonitorNetworkType || (MonitorNetworkType = {}));\n;\n;\n;\n;\n;\n;\n;\n;\n","export var WechatNetworkRecordType;\n(function (WechatNetworkRecordType) {\n    WechatNetworkRecordType[\"request\"] = \"request\";\n    WechatNetworkRecordType[\"download\"] = \"download\";\n    WechatNetworkRecordType[\"upload\"] = \"upload\";\n})(WechatNetworkRecordType || (WechatNetworkRecordType = {}));\nexport var NetworkRecordStatus;\n(function (NetworkRecordStatus) {\n    NetworkRecordStatus[NetworkRecordStatus[\"Timeout\"] = -1] = \"Timeout\";\n    NetworkRecordStatus[NetworkRecordStatus[\"Error\"] = -2] = \"Error\";\n})(NetworkRecordStatus || (NetworkRecordStatus = {}));\n","export var proxyWxLifeHooks;\n(function (proxyWxLifeHooks) {\n    proxyWxLifeHooks[\"onShow\"] = \"onShow\";\n    proxyWxLifeHooks[\"onHide\"] = \"onHide\";\n    proxyWxLifeHooks[\"onReady\"] = \"onReady\";\n    proxyWxLifeHooks[\"onLoad\"] = \"onLoad\";\n    proxyWxLifeHooks[\"onUnload\"] = \"onUnload\";\n    proxyWxLifeHooks[\"created\"] = \"created\";\n    proxyWxLifeHooks[\"attached\"] = \"attached\";\n    proxyWxLifeHooks[\"ready\"] = \"ready\";\n    proxyWxLifeHooks[\"moved\"] = \"moved\";\n    proxyWxLifeHooks[\"detached\"] = \"detached\";\n})(proxyWxLifeHooks || (proxyWxLifeHooks = {}));\nexport const CompAndPageHookMap = {\n    \"onShow\": proxyWxLifeHooks.onShow,\n    \"onHide\": proxyWxLifeHooks.onHide,\n    \"onReady\": proxyWxLifeHooks.onReady,\n    \"onLoad\": proxyWxLifeHooks.onLoad,\n    \"onUnload\": proxyWxLifeHooks.onUnload,\n    \"created\": proxyWxLifeHooks.onLoad,\n    \"attached\": proxyWxLifeHooks.attached,\n    \"ready\": proxyWxLifeHooks.onReady,\n    \"moved\": proxyWxLifeHooks.moved,\n    \"detached\": proxyWxLifeHooks.onUnload,\n};\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { MonitorIOType, MonitorEventName } from \"../inter/monitor\";\nimport { Monitor } from \"../WechatMonitor\";\nimport { getBaseFields } from \"../impl/BaseFields\";\nexport class WechatPerformance {\n    constructor(options) {\n        this.options = Object.assign({ app_name: \"\", app_version: \"\", timeout: 5000, ignored: [] }, options);\n        this.monitor = Monitor.create({\n            timeout: options.timeout,\n            isTaro: this.options.isTaro\n        });\n        this.initialize();\n    }\n    initialize() {\n        this.onPerformanceEvent();\n        this.onResource();\n    }\n    isIgnoreURI(uri) {\n        if (this.options.ignored.length < 1) {\n            return false;\n        }\n        return this.options.ignored.some((location) => {\n            if (typeof location === \"string\") {\n                return uri.indexOf(location) === 0;\n            }\n            return location.test(uri);\n        });\n    }\n    onPerformanceEvent() {\n        const measures = [\n            [MonitorIOType.OnPageLoadTime, MonitorEventName.PageLoadTime],\n            [MonitorIOType.OnDOMLoadTime, MonitorEventName.DOMLoadTime],\n            [MonitorIOType.OnConnectTime, MonitorEventName.TCPConnectTime],\n            [MonitorIOType.OnTCPSetUpTime, MonitorEventName.TCPCompletedTime],\n            [MonitorIOType.OnDNSParseTime, MonitorEventName.DNSLookupTime],\n            [MonitorIOType.OnResourceLoadTime, MonitorEventName.ResourceLoadTime]\n        ];\n        const { app_name, app_version, pv_id } = this.options;\n        for (const [event, name] of measures) {\n            this.monitor.on(event, (entity) => __awaiter(this, void 0, void 0, function* () {\n                const base = yield getBaseFields();\n                const properties = Object.assign(Object.assign({}, base), { app_name,\n                    app_version, event_name: name, pv_id, duration: entity.Duration });\n                this.push([properties]);\n            }));\n        }\n    }\n    onResource() {\n        const { app_name, app_version, pv_id } = this.options;\n        this.monitor.on(MonitorIOType.OnResource, (entity) => __awaiter(this, void 0, void 0, function* () {\n            if (this.isIgnoreURI(entity.URI)) {\n                return;\n            }\n            const base = yield getBaseFields();\n            const properties = Object.assign(Object.assign({}, base), { app_name,\n                app_version,\n                pv_id, event_name: MonitorEventName.OnResource, type: entity.ResourceType, resource_uri: entity.URI, dns_lookup: entity.DNSLookup, tcp_connected: entity.TCPConnected, request_start: entity.RequestStart, response_start: entity.ResponseStart, duration: entity.Duration, status: entity.StatusCode });\n            this.push([properties]);\n        }));\n    }\n    register(data) {\n        this.registered = Object.assign(Object.assign({}, this.registered), data);\n    }\n    unRegister(keys) {\n        keys.forEach(function (key) {\n            if (this.registered.keys) {\n                delete this.registered[key];\n            }\n        });\n    }\n    push(data) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const pushData = Object.assign(Object.assign({}, this.registered), data[0]);\n            return this.next && this.next.push([pushData]);\n        });\n    }\n    pipe(next) {\n        this.next = next;\n        return next;\n    }\n}\n","import { Wrapper } from './wrapper';\nimport { getBoundingClientRect, isClickTrackArea, getActivePage } from './helper';\nexport var InjectConfig;\n(function (InjectConfig) {\n    InjectConfig[InjectConfig[\"method\"] = 0] = \"method\";\n    InjectConfig[InjectConfig[\"element\"] = 1] = \"element\";\n    InjectConfig[InjectConfig[\"comMethod\"] = 2] = \"comMethod\";\n})(InjectConfig || (InjectConfig = {}));\nexport class Tracker extends Wrapper {\n    constructor(opts) {\n        const { tracks, isUsingPlugin } = opts;\n        super(isUsingPlugin);\n        this.tracks = tracks;\n        this.addPageMethodExtra(this.elementTracker());\n        this.addPageMethodWrapper(this.methodTracker());\n        this.addComponentMethodWrapper(this.comMethodTracker());\n    }\n    elementTracker() {\n        const elementTracker = (e) => {\n            const tracks = this.findActivePageTracks(InjectConfig.element);\n            const { data } = getActivePage();\n            tracks.forEach((track) => {\n                getBoundingClientRect(track.element).then((res) => {\n                    res.boundingClientRect.forEach((item) => {\n                        const isHit = isClickTrackArea(e, item, res.scrollOffset);\n                        track.dataset = item.dataset;\n                        console.log(`点中元素：${track.element}`, item.dataset, data, res);\n                    });\n                });\n            });\n        };\n        return elementTracker;\n    }\n    methodTracker() {\n        return (page, component, methodName, args = {}) => {\n            const tracks = this.findActivePageTracks(InjectConfig.method);\n            const { data } = getActivePage();\n            const { dataset } = args.currentTarget || {};\n            tracks.forEach((track) => {\n                if (track.method === methodName) {\n                    track.dataset = dataset;\n                    console.log(`页面方法调用：${track.element}`, dataset, data);\n                }\n            });\n        };\n    }\n    comMethodTracker() {\n        return (page, component, methodName, args = {}) => {\n            const tracks = this.findActivePageTracks(InjectConfig.comMethod);\n            const data = component.data;\n            const { dataset } = args.currentTarget || {};\n            tracks.forEach((track) => {\n                if (track.method === methodName) {\n                    track.dataset = dataset;\n                    console.log(`组件方法调用：${track.element}`, dataset, data);\n                }\n            });\n        };\n    }\n    findActivePageTracks(type) {\n        const { route } = getActivePage();\n        const pageTrackConfig = this.tracks.find(item => item.path === route);\n        let tracks = [];\n        if (!pageTrackConfig) {\n            return tracks;\n        }\n        if (type === InjectConfig.method) {\n            tracks = pageTrackConfig.methodTracks;\n        }\n        else if (type === InjectConfig.element) {\n            tracks = pageTrackConfig.elementTracks;\n        }\n        else if (type === InjectConfig.comMethod) {\n            tracks = pageTrackConfig.comMethodTracks;\n        }\n        return tracks;\n    }\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ListenerEventCallbackType } from \"../inter/listener\";\nimport { WechatListener } from \"../impl/WechatListener\";\nimport { getBaseFields } from \"../impl/BaseFields\";\nimport { getWxNetworkType, onWxNetworkStatusChange } from '@kiner/taro-track-corejs';\n;\nexport var UserBeHaviorEventName;\n(function (UserBeHaviorEventName) {\n    UserBeHaviorEventName[\"OnUIError\"] = \"OnUIError\";\n    UserBeHaviorEventName[\"OnUIEvent\"] = \"OnUIEvent\";\n    UserBeHaviorEventName[\"OnPageView\"] = \"OnPageView\";\n    UserBeHaviorEventName[\"OnURLChange\"] = \"OnURLChange\";\n    UserBeHaviorEventName[\"OnHashChange\"] = \"OnHashChange\";\n    UserBeHaviorEventName[\"OnVisiableChange\"] = \"OnVisiableChange\";\n    UserBeHaviorEventName[\"OnNetworkTypeChange\"] = \"OnNetworkTypeChange\";\n    UserBeHaviorEventName[\"OnNetworkOnline\"] = \"OnNetworkOnline\";\n    UserBeHaviorEventName[\"OnNetworkOffline\"] = \"OnNetworkOffline\";\n})(UserBeHaviorEventName || (UserBeHaviorEventName = {}));\n;\nexport var WebAppType;\n(function (WebAppType) {\n    WebAppType[\"hashspa\"] = \"hashspa\";\n    WebAppType[\"statespa\"] = \"statespa\";\n    WebAppType[\"normal\"] = \"normal\";\n})(WebAppType || (WebAppType = {}));\n;\nexport class WechatUserBeHavior {\n    constructor(opts) {\n        this.options = Object.assign({}, opts);\n        this.listener = new WechatListener(Object.assign(Object.assign({}, opts.listenerOptions), { isTaro: opts.isTaro }));\n        this.initialize();\n    }\n    initialize() {\n        this.onUIEvent();\n        this.onUIError();\n        this.onPageView();\n        this.onVisiableEvent();\n        this.createNetworkObserver();\n    }\n    onUIEvent() {\n        const { app_name, app_version, pv_id } = this.options;\n        this.listener.on(ListenerEventCallbackType.OnUIEvent, (backpass) => __awaiter(this, void 0, void 0, function* () {\n            const base = yield getBaseFields();\n            const properties = Object.assign(Object.assign({}, base), { app_name,\n                app_version,\n                pv_id, event_name: UserBeHaviorEventName.OnUIEvent, type: backpass.eventType, message: JSON.stringify(backpass) });\n            this.push([properties]);\n        }));\n    }\n    onVisiableEvent() {\n        const { app_name, app_version, pv_id } = this.options;\n        this.listener.on(ListenerEventCallbackType.OnVisiable, (hiddenState) => __awaiter(this, void 0, void 0, function* () {\n            const base = yield getBaseFields();\n            const properties = Object.assign(Object.assign({}, base), { app_name,\n                app_version,\n                pv_id, event_name: UserBeHaviorEventName.OnVisiableChange, message: \"hidden:\" + hiddenState });\n            this.push([properties]);\n        }));\n    }\n    onUIError() {\n        const { app_name, app_version, pv_id } = this.options;\n        this.listener.on(ListenerEventCallbackType.OnUIError, ({ backpass, error }) => __awaiter(this, void 0, void 0, function* () {\n            const base = yield getBaseFields();\n            const properties = Object.assign(Object.assign({}, base), { app_name,\n                app_version, event_name: UserBeHaviorEventName.OnUIError, message: JSON.stringify(backpass.concat(error)), pv_id });\n            this.push([properties]);\n        }));\n    }\n    onPageView() {\n        const { app_name, app_version, pv_id } = this.options;\n        this.listener.on(ListenerEventCallbackType.OnPageView, (url) => __awaiter(this, void 0, void 0, function* () {\n            const base = yield getBaseFields();\n            const properties = Object.assign(Object.assign({}, base), { app_name,\n                app_version,\n                url, event_name: UserBeHaviorEventName.OnPageView, pv_id });\n            this.push([properties]);\n        }));\n    }\n    observeNetwork(network) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { app_name, app_version, pv_id } = this.options;\n            const base = yield getBaseFields();\n            const properties = Object.assign(Object.assign({}, base), { app_name,\n                app_version,\n                pv_id, event_name: network.isConnected ? UserBeHaviorEventName.OnNetworkOnline : UserBeHaviorEventName.OnNetworkOffline, message: network.networkType || \"unknow\" });\n            this.push([properties]);\n        });\n    }\n    createNetworkObserver() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const networkTypeResult = yield getWxNetworkType();\n            this.observeNetwork({\n                isConnected: networkTypeResult.networkType !== 'none',\n                networkType: networkTypeResult.networkType\n            });\n            onWxNetworkStatusChange(result => this.observeNetwork(result));\n        });\n    }\n    register(data) {\n        this.registered = Object.assign(Object.assign({}, this.registered), data);\n    }\n    unRegister(keys) {\n        keys.forEach(function (key) {\n            if (this.registered.keys) {\n                delete this.registered[key];\n            }\n        });\n    }\n    push(data) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const pushData = Object.assign(Object.assign({}, this.registered), data[0]);\n            return this.next && this.next.push([pushData]);\n        });\n    }\n    pipe(next) {\n        this.next = next;\n        return next;\n    }\n}\n","export const getBoundingClientRect = function (element) {\n    return new Promise((reslove) => {\n        const query = wx.createSelectorQuery();\n        query.selectAll(element).boundingClientRect();\n        query.selectViewport().scrollOffset();\n        query.exec(res => reslove({ boundingClientRect: res[0], scrollOffset: res[1] }));\n    });\n};\nexport const isClickTrackArea = function (clickInfo, boundingClientRect, scrollOffset) {\n    if (!boundingClientRect)\n        return false;\n    const { x, y } = clickInfo.detail;\n    const { left, right, top, height } = boundingClientRect;\n    const { scrollTop } = scrollOffset;\n    return left < x && x < right && scrollTop + top < y && y < scrollTop + top + height;\n};\nexport const getActivePage = function () {\n    const curPages = getCurrentPages();\n    if (curPages.length) {\n        return curPages[curPages.length - 1];\n    }\n    return {};\n};\nexport const getPrevPage = function () {\n    const curPages = getCurrentPages();\n    if (curPages.length > 1) {\n        return curPages[curPages.length - 2];\n    }\n    return {};\n};\nexport const _isPromise = function (value) {\n    return value && Object.prototype.toString.call(value) === '[object Promise]';\n};\n","let globalVarApp;\nlet globalVarPage;\nlet globalVarComponent;\nexport class Wrapper {\n    constructor(isUsingPlugin) {\n        this.injectPageMethods = [];\n        this.injectAppMethods = [];\n        this.extraPageMethods = [];\n        this.extraAppMethods = [];\n        this.injectComponentMethods = [];\n        this.extraComponentMethods = [];\n        globalVarApp = this.__App = App;\n        globalVarPage = this.__Page = Page;\n        globalVarComponent = this.__Comp = Component;\n        if (!isUsingPlugin) {\n            App = (app) => globalVarApp(this._create(app, this.injectAppMethods, this.extraAppMethods));\n            Page = (page) => {\n                let _page = globalVarPage(this._create(page, this.injectPageMethods, this.extraPageMethods));\n                return _page;\n            };\n            Component = (component) => globalVarComponent(this._createComponent(component, this.injectComponentMethods, this.extraComponentMethods));\n        }\n    }\n    _wrapTargetMethod(target, component, methodName, methods = []) {\n        const methodFunction = target[methodName];\n        target[methodName] = function _aa(...args) {\n            const result = methodFunction && methodFunction.apply(this, args);\n            const methodExcuter = () => {\n                methods.forEach((fn) => {\n                    fn.apply(this, [target, component, methodName, ...args]);\n                });\n            };\n            try {\n                if (Object.prototype.toString.call(result) === '[object Promise]') {\n                    result.then(() => {\n                        methodExcuter();\n                    }).catch(() => {\n                        methodExcuter();\n                    });\n                }\n                else {\n                    methodExcuter();\n                }\n            }\n            catch (e) {\n                console.error(methodName, '钩子函数执行出现错误', e);\n            }\n            return result;\n        };\n    }\n    _addExtraMethod(target, methods) {\n        methods\n            .forEach(fn => {\n            const methodName = fn.name;\n            target[methodName] = fn;\n        });\n    }\n    _create(target, injectMethods, extraMethods) {\n        Object.keys(target)\n            .filter((prop) => typeof target[prop] === 'function')\n            .forEach((methodName) => {\n            this._wrapTargetMethod(target, null, methodName, injectMethods);\n        });\n        this._addExtraMethod(target, extraMethods);\n        return target;\n    }\n    _createComponent(component, injectMethods, extraMethods) {\n        const target = component.methods;\n        Object.keys(target)\n            .filter((prop) => typeof target[prop] === 'function')\n            .forEach((methodName) => {\n            this._wrapTargetMethod(target, component, methodName, injectMethods);\n        });\n        this._addExtraMethod(target, extraMethods);\n        return component;\n    }\n    addPageMethodWrapper(fn) {\n        this.injectPageMethods.push(fn);\n    }\n    addComponentMethodWrapper(fn) {\n        this.injectComponentMethods.push(fn);\n    }\n    addAppMethodWrapper(fn) {\n        this.injectAppMethods.push(fn);\n    }\n    addPageMethodExtra(fn) {\n        this.extraPageMethods.push(fn);\n    }\n    addAppMethodExtra(fn) {\n        this.extraAppMethods.push(fn);\n    }\n    createApp(app) {\n        globalVarApp(this._create(app, this.injectAppMethods, this.extraAppMethods));\n    }\n    createPage(page) {\n        globalVarPage(this._create(page, this.injectPageMethods, this.extraPageMethods));\n    }\n    createComponent(component) {\n        globalVarPage(this._createComponent(component, this.injectPageMethods, this.extraPageMethods));\n    }\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { getBaseFields, WebAppType, WechatPerformance, WechatUserBeHavior, getBaseExtFields, OverrideWechatPage, CompAndPageHookMap, proxyWxLifeHooks } from '@kiner/taro-track-datasource';\nimport { getWxCurrentHref, Logger4Node, shortid } from '@kiner/taro-track-corejs';\nimport { TransporterConsole, WechatTransporter, TestELKLogServerHost, ELKLogServerHost } from '@kiner/taro-track-transporter';\nconst logger = Logger4Node.create('TaroTrack:entry', {\n    groupCollapsed: true\n});\nexport var TransporterType;\n(function (TransporterType) {\n    TransporterType[\"Console\"] = \"Console\";\n    TransporterType[\"Elk\"] = \"Elk\";\n})(TransporterType || (TransporterType = {}));\nexport { WechatTransporter, TestELKLogServerHost, ELKLogServerHost, TransporterConsole };\nexport function initTransporter(transporter, initOptions) {\n    switch (transporter) {\n        case TransporterType.Console:\n            return new TransporterConsole();\n        case TransporterType.Elk:\n            return WechatTransporter.create(initOptions);\n    }\n}\nexport function initDolphin(opts) {\n    const { appName, appVersion, baseUrl = TestELKLogServerHost } = opts;\n    const AppName = appName || '_dolphin_app_name';\n    const AppVersion = appVersion || '0.0.0';\n    logger.success('初始化成功', opts);\n    const perf = new WechatPerformance({\n        app_name: AppName,\n        app_version: AppVersion,\n        pv_id: shortid(),\n        ignored: [\n            `https://xxx.xxx.com`\n        ],\n        isTaro: opts.isTaro\n    });\n    const ub = new WechatUserBeHavior({\n        app_name: AppName,\n        app_version: AppVersion,\n        pv_id: shortid(),\n        webAppType: WebAppType.normal,\n        isTaro: opts.isTaro\n    });\n    let perTransport;\n    let ubTransport;\n    if (opts.transporter === TransporterType.Console) {\n        ubTransport = perTransport = new TransporterConsole();\n    }\n    else {\n        perTransport = WechatTransporter.create({\n            baseUrl,\n            query: {\n                app_name: AppName,\n                app_version: AppVersion,\n                ev_type: 'client_perf'\n            }\n        });\n        ubTransport = WechatTransporter.create({\n            baseUrl,\n            query: {\n                app_name: AppName,\n                app_version: AppVersion,\n                ev_type: 'client_ub'\n            }\n        });\n    }\n    perf\n        .pipe(perTransport);\n    ub\n        .pipe(ubTransport);\n}\nexport function initAppletLifecycleListener({ baseUrl, isTaro, transporter, appVersion, appName, showLog = false, pstInterval = 5000 }, extraData = {}, allHooks) {\n    const tpr = initTransporter(transporter, {\n        baseUrl: baseUrl,\n        query: {\n            app_name: appName,\n            app_version: appVersion,\n            ev_type: 'client_ub'\n        }\n    });\n    let timer = null;\n    const overrideWechatPage = new OverrideWechatPage(isTaro);\n    const prevUrl = getWxCurrentHref();\n    overrideWechatPage.initialize((methodName, options) => __awaiter(this, void 0, void 0, function* () {\n        if (!options.__isPage__) {\n            return;\n        }\n        const newData = allHooks && allHooks(tpr, methodName, options);\n        extraData = Object.assign(Object.assign({}, extraData), newData);\n        const openTime = Date.now();\n        const baseExtFields = getBaseExtFields(extraData);\n        const baseFields = yield getBaseFields(extraData);\n        const extraExt = extraData.ext || {};\n        function sendPv() {\n            const now = Date.now();\n            const sendData = Object.assign(Object.assign(Object.assign({ ev: 'applet-pv' }, baseFields), extraData), { time: now, ext: Object.assign(Object.assign(Object.assign({}, baseExtFields), extraExt), { time_in: now }) });\n            tpr.send(sendData, () => showLog && logger.info(`applet-pv上报成功`, sendData));\n        }\n        function sendPst() {\n            const now = Date.now();\n            const sendPstData = Object.assign(Object.assign(Object.assign({ ev: 'applet-pst' }, baseFields), extraData), { time: now, ext: Object.assign(Object.assign(Object.assign({}, baseExtFields), extraExt), { time: now - openTime, url: getWxCurrentHref() }) });\n            tpr.send(sendPstData, () => showLog && logger.info(`applet-pst上报成功`, sendPstData));\n        }\n        function sendPvOut() {\n            const now = Date.now();\n            const sendPvOutData = Object.assign(Object.assign(Object.assign({ ev: 'applet-pvout' }, baseFields), extraData), { time: now, pl: baseFields.url, ext: Object.assign(Object.assign(Object.assign({}, baseExtFields), extraExt), { time_out: now, url: baseFields.url }) });\n            tpr.send(sendPvOutData, () => showLog && logger.info(`applet-pvout上报成功`, sendPvOutData));\n        }\n        switch (CompAndPageHookMap[methodName]) {\n            case proxyWxLifeHooks.onReady:\n            case proxyWxLifeHooks.ready:\n                if (prevUrl && prevUrl !== getWxCurrentHref()) {\n                    sendPvOut();\n                }\n                sendPv();\n                timer = setInterval(() => {\n                    sendPst();\n                }, pstInterval);\n                break;\n            case proxyWxLifeHooks.onUnload:\n            case proxyWxLifeHooks.detached:\n                sendPvOut();\n                break;\n        }\n    }));\n}\n","export * from \"./src/config\";\nexport * from \"./src/TransportElk\";\nexport * from \"./src/TransportConsole\";\n","import { TaroTrackLoggerNamespace } from '@kiner/taro-track-common';\nimport { Logger4Node } from '@kiner/taro-track-corejs';\nconst logger = Logger4Node.create(TaroTrackLoggerNamespace, {\n    groupCollapsed: true\n});\nexport class TransporterConsole {\n    constructor() { }\n    send(data, callback) {\n        logger.info('TransporterConsole.send上报', data);\n        if (callback) {\n            callback(null);\n        }\n    }\n    post(dataArray, callback) {\n        logger.info('TransporterConsole.post上报', ...dataArray);\n        if (callback) {\n            callback(null);\n        }\n    }\n    push(data) {\n        return new Promise(resolve => {\n            logger.info('TransporterConsole压入队列', ...data);\n            resolve();\n        });\n    }\n    pipe(next) {\n        return next;\n    }\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ELKLogServerHost } from \"./config\";\nimport { encodeToArray } from \"./utils/encode-elk\";\nimport { getWxRequest, serialized } from \"@kiner/taro-track-corejs\";\nimport * as base64 from \"@kiner/taro-track-corejs\";\nexport class WechatTransporter {\n    constructor(options) {\n        this.serverHost = ELKLogServerHost;\n        this.supportUint8Array = Uint8Array && (typeof Uint8Array.from === \"function\");\n        this.wxRequest = getWxRequest();\n        this.defaultOptions = {\n            urlMaxLength: 2048,\n            getMethodServer: `${options.baseUrl || ELKLogServerHost}/lu`,\n            headMethodServer: `${options.baseUrl || ELKLogServerHost}/lu`,\n            postMethodServer: `${options.baseUrl || ELKLogServerHost}/lp`,\n            query: {\n                app_name: \"unknow_app_name\",\n                app_version: \"unknow_app_version\",\n                ev_type: \"unknow_type\"\n            }\n        };\n        this.options = Object.assign(Object.assign({}, this.defaultOptions), options);\n        this.query = serialized(this.options.query);\n    }\n    static create(options) {\n        return new WechatTransporter(options);\n    }\n    getRequestURI(uri, query) {\n        return uri\n            + \"?\"\n            + this.query\n            + (query ? (this.query ? (\"&\" + query) : query) : \"\");\n    }\n    sendDataByPostMethod(code, callback) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => {\n                this.wxRequest({\n                    method: \"POST\",\n                    header: {\n                        \"Content-Type\": \"application/octet-stream\",\n                        \"Content-Encoding\": this.supportUint8Array ? \"gzip\" : \"gzip+base64\",\n                    },\n                    data: this.supportUint8Array ? Uint8Array.from(code) : base64.encode(code),\n                    url: this.getRequestURI(this.options.postMethodServer, \"\"),\n                    success: () => {\n                        callback && callback();\n                        resolve();\n                    },\n                    fail: (error) => {\n                        callback && callback(error.errMsg);\n                        reject(error.errMsg);\n                    }\n                });\n            });\n        });\n    }\n    sendDataByHeadMethod(code, callback) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const encodeBase64 = base64.encode(code);\n            const url = this.getRequestURI(this.options.headMethodServer, \"e=gb&q=\" + encodeBase64);\n            return new Promise((resolve, reject) => {\n                this.wxRequest({\n                    url,\n                    method: \"HEAD\",\n                    success: () => {\n                        callback && callback();\n                        resolve();\n                    },\n                    fail: (error) => {\n                        callback && callback(error.errMsg);\n                        reject(error.errMsg);\n                    }\n                });\n            });\n        });\n    }\n    send(data, callback) {\n        const gzip = encodeToArray(JSON.stringify([data]));\n        if (gzip.length * 1.25 + this.options.headMethodServer.length >\n            this.options.urlMaxLength) {\n            this.sendDataByPostMethod(gzip, callback);\n            return;\n        }\n        this.sendDataByHeadMethod(gzip, callback);\n    }\n    post(data, callback) {\n        const gzip = encodeToArray(JSON.stringify(data));\n        this.sendDataByPostMethod(gzip, callback);\n    }\n    pipe(next) {\n        return next;\n    }\n    push(data) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const gzip = encodeToArray(JSON.stringify(data));\n            return this.sendDataByPostMethod(gzip);\n        });\n    }\n}\n","export const ELKLogServerHost = \"\";\nexport const TestELKLogServerHost = \"\";\n","import { zip } from 'gzip-js';\nimport * as base64 from \"@kiner/taro-track-corejs\";\nexport function isSupportTyped() {\n    return (typeof Uint8Array !== \"undefined\")\n        && (typeof Uint16Array !== \"undefined\")\n        && (typeof Int32Array !== \"undefined\");\n}\nexport const SupportTyped = isSupportTyped();\nexport function encodeToUint8Array(data) {\n    return zip(data, {});\n}\nconst ArrayProto = Array.prototype;\nexport function encodeToArray(data) {\n    if (SupportTyped) {\n        return Array.from(encodeToUint8Array(data));\n    }\n    const binary = zip(data).join('');\n    return ArrayProto.slice.call(binary).map(function (v) {\n        return v.charCodeAt(0);\n    });\n}\nexport function encodeToBase64(data) {\n    if (SupportTyped) {\n        return base64.encode(Array.from(encodeToUint8Array(data)));\n    }\n    return base64.encode(encodeToArray(data));\n}\n","module.exports = r => {\n  const n = process.versions.node.split('.').map(x => parseInt(x, 10))\n  r = r.split('.').map(x => parseInt(x, 10))\n  return n[0] > r[0] || (n[0] === r[0] && (n[1] > r[1] || (n[1] === r[1] && n[2] >= r[2])))\n}\n","'use strict';\nmodule.exports = balanced;\nfunction balanced(a, b, str) {\n  if (a instanceof RegExp) a = maybeMatch(a, str);\n  if (b instanceof RegExp) b = maybeMatch(b, str);\n\n  var r = range(a, b, str);\n\n  return r && {\n    start: r[0],\n    end: r[1],\n    pre: str.slice(0, r[0]),\n    body: str.slice(r[0] + a.length, r[1]),\n    post: str.slice(r[1] + b.length)\n  };\n}\n\nfunction maybeMatch(reg, str) {\n  var m = str.match(reg);\n  return m ? m[0] : null;\n}\n\nbalanced.range = range;\nfunction range(a, b, str) {\n  var begs, beg, left, right, result;\n  var ai = str.indexOf(a);\n  var bi = str.indexOf(b, ai + 1);\n  var i = ai;\n\n  if (ai >= 0 && bi > 0) {\n    begs = [];\n    left = str.length;\n\n    while (i >= 0 && !result) {\n      if (i == ai) {\n        begs.push(i);\n        ai = str.indexOf(a, i + 1);\n      } else if (begs.length == 1) {\n        result = [ begs.pop(), bi ];\n      } else {\n        beg = begs.pop();\n        if (beg < left) {\n          left = beg;\n          right = bi;\n        }\n\n        bi = str.indexOf(b, i + 1);\n      }\n\n      i = ai < bi && ai >= 0 ? ai : bi;\n    }\n\n    if (begs.length) {\n      result = [ left, right ];\n    }\n  }\n\n  return result;\n}\n","var concatMap = require('concat-map');\nvar balanced = require('balanced-match');\n\nmodule.exports = expandTop;\n\nvar escSlash = '\\0SLASH'+Math.random()+'\\0';\nvar escOpen = '\\0OPEN'+Math.random()+'\\0';\nvar escClose = '\\0CLOSE'+Math.random()+'\\0';\nvar escComma = '\\0COMMA'+Math.random()+'\\0';\nvar escPeriod = '\\0PERIOD'+Math.random()+'\\0';\n\nfunction numeric(str) {\n  return parseInt(str, 10) == str\n    ? parseInt(str, 10)\n    : str.charCodeAt(0);\n}\n\nfunction escapeBraces(str) {\n  return str.split('\\\\\\\\').join(escSlash)\n            .split('\\\\{').join(escOpen)\n            .split('\\\\}').join(escClose)\n            .split('\\\\,').join(escComma)\n            .split('\\\\.').join(escPeriod);\n}\n\nfunction unescapeBraces(str) {\n  return str.split(escSlash).join('\\\\')\n            .split(escOpen).join('{')\n            .split(escClose).join('}')\n            .split(escComma).join(',')\n            .split(escPeriod).join('.');\n}\n\n\n// Basically just str.split(\",\"), but handling cases\n// where we have nested braced sections, which should be\n// treated as individual members, like {a,{b,c},d}\nfunction parseCommaParts(str) {\n  if (!str)\n    return [''];\n\n  var parts = [];\n  var m = balanced('{', '}', str);\n\n  if (!m)\n    return str.split(',');\n\n  var pre = m.pre;\n  var body = m.body;\n  var post = m.post;\n  var p = pre.split(',');\n\n  p[p.length-1] += '{' + body + '}';\n  var postParts = parseCommaParts(post);\n  if (post.length) {\n    p[p.length-1] += postParts.shift();\n    p.push.apply(p, postParts);\n  }\n\n  parts.push.apply(parts, p);\n\n  return parts;\n}\n\nfunction expandTop(str) {\n  if (!str)\n    return [];\n\n  // I don't know why Bash 4.3 does this, but it does.\n  // Anything starting with {} will have the first two bytes preserved\n  // but *only* at the top level, so {},a}b will not expand to anything,\n  // but a{},b}c will be expanded to [a}c,abc].\n  // One could argue that this is a bug in Bash, but since the goal of\n  // this module is to match Bash's rules, we escape a leading {}\n  if (str.substr(0, 2) === '{}') {\n    str = '\\\\{\\\\}' + str.substr(2);\n  }\n\n  return expand(escapeBraces(str), true).map(unescapeBraces);\n}\n\nfunction identity(e) {\n  return e;\n}\n\nfunction embrace(str) {\n  return '{' + str + '}';\n}\nfunction isPadded(el) {\n  return /^-?0\\d/.test(el);\n}\n\nfunction lte(i, y) {\n  return i <= y;\n}\nfunction gte(i, y) {\n  return i >= y;\n}\n\nfunction expand(str, isTop) {\n  var expansions = [];\n\n  var m = balanced('{', '}', str);\n  if (!m || /\\$$/.test(m.pre)) return [str];\n\n  var isNumericSequence = /^-?\\d+\\.\\.-?\\d+(?:\\.\\.-?\\d+)?$/.test(m.body);\n  var isAlphaSequence = /^[a-zA-Z]\\.\\.[a-zA-Z](?:\\.\\.-?\\d+)?$/.test(m.body);\n  var isSequence = isNumericSequence || isAlphaSequence;\n  var isOptions = m.body.indexOf(',') >= 0;\n  if (!isSequence && !isOptions) {\n    // {a},b}\n    if (m.post.match(/,.*\\}/)) {\n      str = m.pre + '{' + m.body + escClose + m.post;\n      return expand(str);\n    }\n    return [str];\n  }\n\n  var n;\n  if (isSequence) {\n    n = m.body.split(/\\.\\./);\n  } else {\n    n = parseCommaParts(m.body);\n    if (n.length === 1) {\n      // x{{a,b}}y ==> x{a}y x{b}y\n      n = expand(n[0], false).map(embrace);\n      if (n.length === 1) {\n        var post = m.post.length\n          ? expand(m.post, false)\n          : [''];\n        return post.map(function(p) {\n          return m.pre + n[0] + p;\n        });\n      }\n    }\n  }\n\n  // at this point, n is the parts, and we know it's not a comma set\n  // with a single entry.\n\n  // no need to expand pre, since it is guaranteed to be free of brace-sets\n  var pre = m.pre;\n  var post = m.post.length\n    ? expand(m.post, false)\n    : [''];\n\n  var N;\n\n  if (isSequence) {\n    var x = numeric(n[0]);\n    var y = numeric(n[1]);\n    var width = Math.max(n[0].length, n[1].length)\n    var incr = n.length == 3\n      ? Math.abs(numeric(n[2]))\n      : 1;\n    var test = lte;\n    var reverse = y < x;\n    if (reverse) {\n      incr *= -1;\n      test = gte;\n    }\n    var pad = n.some(isPadded);\n\n    N = [];\n\n    for (var i = x; test(i, y); i += incr) {\n      var c;\n      if (isAlphaSequence) {\n        c = String.fromCharCode(i);\n        if (c === '\\\\')\n          c = '';\n      } else {\n        c = String(i);\n        if (pad) {\n          var need = width - c.length;\n          if (need > 0) {\n            var z = new Array(need + 1).join('0');\n            if (i < 0)\n              c = '-' + z + c.slice(1);\n            else\n              c = z + c;\n          }\n        }\n      }\n      N.push(c);\n    }\n  } else {\n    N = concatMap(n, function(el) { return expand(el, false) });\n  }\n\n  for (var j = 0; j < N.length; j++) {\n    for (var k = 0; k < post.length; k++) {\n      var expansion = pre + N[j] + post[k];\n      if (!isTop || isSequence || expansion)\n        expansions.push(expansion);\n    }\n  }\n\n  return expansions;\n}\n\n","/*\n\nThe MIT License (MIT)\n\nOriginal Library\n  - Copyright (c) Marak Squires\n\nAdditional functionality\n - Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n*/\n\nvar colors = {};\nmodule['exports'] = colors;\n\ncolors.themes = {};\n\nvar util = require('util');\nvar ansiStyles = colors.styles = require('./styles');\nvar defineProps = Object.defineProperties;\nvar newLineRegex = new RegExp(/[\\r\\n]+/g);\n\ncolors.supportsColor = require('./system/supports-colors').supportsColor;\n\nif (typeof colors.enabled === 'undefined') {\n  colors.enabled = colors.supportsColor() !== false;\n}\n\ncolors.enable = function() {\n  colors.enabled = true;\n};\n\ncolors.disable = function() {\n  colors.enabled = false;\n};\n\ncolors.stripColors = colors.strip = function(str) {\n  return ('' + str).replace(/\\x1B\\[\\d+m/g, '');\n};\n\n// eslint-disable-next-line no-unused-vars\nvar stylize = colors.stylize = function stylize(str, style) {\n  if (!colors.enabled) {\n    return str+'';\n  }\n\n  var styleMap = ansiStyles[style];\n\n  // Stylize should work for non-ANSI styles, too\n  if(!styleMap && style in colors){\n    // Style maps like trap operate as functions on strings;\n    // they don't have properties like open or close.\n    return colors[style](str);\n  }\n\n  return styleMap.open + str + styleMap.close;\n};\n\nvar matchOperatorsRe = /[|\\\\{}()[\\]^$+*?.]/g;\nvar escapeStringRegexp = function(str) {\n  if (typeof str !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n  return str.replace(matchOperatorsRe, '\\\\$&');\n};\n\nfunction build(_styles) {\n  var builder = function builder() {\n    return applyStyle.apply(builder, arguments);\n  };\n  builder._styles = _styles;\n  // __proto__ is used because we must return a function, but there is\n  // no way to create a function with a different prototype.\n  builder.__proto__ = proto;\n  return builder;\n}\n\nvar styles = (function() {\n  var ret = {};\n  ansiStyles.grey = ansiStyles.gray;\n  Object.keys(ansiStyles).forEach(function(key) {\n    ansiStyles[key].closeRe =\n      new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');\n    ret[key] = {\n      get: function() {\n        return build(this._styles.concat(key));\n      },\n    };\n  });\n  return ret;\n})();\n\nvar proto = defineProps(function colors() {}, styles);\n\nfunction applyStyle() {\n  var args = Array.prototype.slice.call(arguments);\n\n  var str = args.map(function(arg) {\n    // Use weak equality check so we can colorize null/undefined in safe mode\n    if (arg != null && arg.constructor === String) {\n      return arg;\n    } else {\n      return util.inspect(arg);\n    }\n  }).join(' ');\n\n  if (!colors.enabled || !str) {\n    return str;\n  }\n\n  var newLinesPresent = str.indexOf('\\n') != -1;\n\n  var nestedStyles = this._styles;\n\n  var i = nestedStyles.length;\n  while (i--) {\n    var code = ansiStyles[nestedStyles[i]];\n    str = code.open + str.replace(code.closeRe, code.open) + code.close;\n    if (newLinesPresent) {\n      str = str.replace(newLineRegex, function(match) {\n        return code.close + match + code.open;\n      });\n    }\n  }\n\n  return str;\n}\n\ncolors.setTheme = function(theme) {\n  if (typeof theme === 'string') {\n    console.log('colors.setTheme now only accepts an object, not a string.  ' +\n      'If you are trying to set a theme from a file, it is now your (the ' +\n      'caller\\'s) responsibility to require the file.  The old syntax ' +\n      'looked like colors.setTheme(__dirname + ' +\n      '\\'/../themes/generic-logging.js\\'); The new syntax looks like '+\n      'colors.setTheme(require(__dirname + ' +\n      '\\'/../themes/generic-logging.js\\'));');\n    return;\n  }\n  for (var style in theme) {\n    (function(style) {\n      colors[style] = function(str) {\n        if (typeof theme[style] === 'object') {\n          var out = str;\n          for (var i in theme[style]) {\n            out = colors[theme[style][i]](out);\n          }\n          return out;\n        }\n        return colors[theme[style]](str);\n      };\n    })(style);\n  }\n};\n\nfunction init() {\n  var ret = {};\n  Object.keys(styles).forEach(function(name) {\n    ret[name] = {\n      get: function() {\n        return build([name]);\n      },\n    };\n  });\n  return ret;\n}\n\nvar sequencer = function sequencer(map, str) {\n  var exploded = str.split('');\n  exploded = exploded.map(map);\n  return exploded.join('');\n};\n\n// custom formatter methods\ncolors.trap = require('./custom/trap');\ncolors.zalgo = require('./custom/zalgo');\n\n// maps\ncolors.maps = {};\ncolors.maps.america = require('./maps/america')(colors);\ncolors.maps.zebra = require('./maps/zebra')(colors);\ncolors.maps.rainbow = require('./maps/rainbow')(colors);\ncolors.maps.random = require('./maps/random')(colors);\n\nfor (var map in colors.maps) {\n  (function(map) {\n    colors[map] = function(str) {\n      return sequencer(colors.maps[map], str);\n    };\n  })(map);\n}\n\ndefineProps(colors, init());\n","module['exports'] = function runTheTrap(text, options) {\n  var result = '';\n  text = text || 'Run the trap, drop the bass';\n  text = text.split('');\n  var trap = {\n    a: ['\\u0040', '\\u0104', '\\u023a', '\\u0245', '\\u0394', '\\u039b', '\\u0414'],\n    b: ['\\u00df', '\\u0181', '\\u0243', '\\u026e', '\\u03b2', '\\u0e3f'],\n    c: ['\\u00a9', '\\u023b', '\\u03fe'],\n    d: ['\\u00d0', '\\u018a', '\\u0500', '\\u0501', '\\u0502', '\\u0503'],\n    e: ['\\u00cb', '\\u0115', '\\u018e', '\\u0258', '\\u03a3', '\\u03be', '\\u04bc',\n      '\\u0a6c'],\n    f: ['\\u04fa'],\n    g: ['\\u0262'],\n    h: ['\\u0126', '\\u0195', '\\u04a2', '\\u04ba', '\\u04c7', '\\u050a'],\n    i: ['\\u0f0f'],\n    j: ['\\u0134'],\n    k: ['\\u0138', '\\u04a0', '\\u04c3', '\\u051e'],\n    l: ['\\u0139'],\n    m: ['\\u028d', '\\u04cd', '\\u04ce', '\\u0520', '\\u0521', '\\u0d69'],\n    n: ['\\u00d1', '\\u014b', '\\u019d', '\\u0376', '\\u03a0', '\\u048a'],\n    o: ['\\u00d8', '\\u00f5', '\\u00f8', '\\u01fe', '\\u0298', '\\u047a', '\\u05dd',\n      '\\u06dd', '\\u0e4f'],\n    p: ['\\u01f7', '\\u048e'],\n    q: ['\\u09cd'],\n    r: ['\\u00ae', '\\u01a6', '\\u0210', '\\u024c', '\\u0280', '\\u042f'],\n    s: ['\\u00a7', '\\u03de', '\\u03df', '\\u03e8'],\n    t: ['\\u0141', '\\u0166', '\\u0373'],\n    u: ['\\u01b1', '\\u054d'],\n    v: ['\\u05d8'],\n    w: ['\\u0428', '\\u0460', '\\u047c', '\\u0d70'],\n    x: ['\\u04b2', '\\u04fe', '\\u04fc', '\\u04fd'],\n    y: ['\\u00a5', '\\u04b0', '\\u04cb'],\n    z: ['\\u01b5', '\\u0240'],\n  };\n  text.forEach(function(c) {\n    c = c.toLowerCase();\n    var chars = trap[c] || [' '];\n    var rand = Math.floor(Math.random() * chars.length);\n    if (typeof trap[c] !== 'undefined') {\n      result += trap[c][rand];\n    } else {\n      result += c;\n    }\n  });\n  return result;\n};\n","// please no\nmodule['exports'] = function zalgo(text, options) {\n  text = text || '   he is here   ';\n  var soul = {\n    'up': [\n      '̍', '̎', '̄', '̅',\n      '̿', '̑', '̆', '̐',\n      '͒', '͗', '͑', '̇',\n      '̈', '̊', '͂', '̓',\n      '̈', '͊', '͋', '͌',\n      '̃', '̂', '̌', '͐',\n      '̀', '́', '̋', '̏',\n      '̒', '̓', '̔', '̽',\n      '̉', 'ͣ', 'ͤ', 'ͥ',\n      'ͦ', 'ͧ', 'ͨ', 'ͩ',\n      'ͪ', 'ͫ', 'ͬ', 'ͭ',\n      'ͮ', 'ͯ', '̾', '͛',\n      '͆', '̚',\n    ],\n    'down': [\n      '̖', '̗', '̘', '̙',\n      '̜', '̝', '̞', '̟',\n      '̠', '̤', '̥', '̦',\n      '̩', '̪', '̫', '̬',\n      '̭', '̮', '̯', '̰',\n      '̱', '̲', '̳', '̹',\n      '̺', '̻', '̼', 'ͅ',\n      '͇', '͈', '͉', '͍',\n      '͎', '͓', '͔', '͕',\n      '͖', '͙', '͚', '̣',\n    ],\n    'mid': [\n      '̕', '̛', '̀', '́',\n      '͘', '̡', '̢', '̧',\n      '̨', '̴', '̵', '̶',\n      '͜', '͝', '͞',\n      '͟', '͠', '͢', '̸',\n      '̷', '͡', ' ҉',\n    ],\n  };\n  var all = [].concat(soul.up, soul.down, soul.mid);\n\n  function randomNumber(range) {\n    var r = Math.floor(Math.random() * range);\n    return r;\n  }\n\n  function isChar(character) {\n    var bool = false;\n    all.filter(function(i) {\n      bool = (i === character);\n    });\n    return bool;\n  }\n\n\n  function heComes(text, options) {\n    var result = '';\n    var counts;\n    var l;\n    options = options || {};\n    options['up'] =\n      typeof options['up'] !== 'undefined' ? options['up'] : true;\n    options['mid'] =\n      typeof options['mid'] !== 'undefined' ? options['mid'] : true;\n    options['down'] =\n      typeof options['down'] !== 'undefined' ? options['down'] : true;\n    options['size'] =\n      typeof options['size'] !== 'undefined' ? options['size'] : 'maxi';\n    text = text.split('');\n    for (l in text) {\n      if (isChar(l)) {\n        continue;\n      }\n      result = result + text[l];\n      counts = {'up': 0, 'down': 0, 'mid': 0};\n      switch (options.size) {\n        case 'mini':\n          counts.up = randomNumber(8);\n          counts.mid = randomNumber(2);\n          counts.down = randomNumber(8);\n          break;\n        case 'maxi':\n          counts.up = randomNumber(16) + 3;\n          counts.mid = randomNumber(4) + 1;\n          counts.down = randomNumber(64) + 3;\n          break;\n        default:\n          counts.up = randomNumber(8) + 1;\n          counts.mid = randomNumber(6) / 2;\n          counts.down = randomNumber(8) + 1;\n          break;\n      }\n\n      var arr = ['up', 'mid', 'down'];\n      for (var d in arr) {\n        var index = arr[d];\n        for (var i = 0; i <= counts[index]; i++) {\n          if (options[index]) {\n            result = result + soul[index][randomNumber(soul[index].length)];\n          }\n        }\n      }\n    }\n    return result;\n  }\n  // don't summon him\n  return heComes(text, options);\n};\n\n","var colors = require('./colors');\n\nmodule['exports'] = function() {\n  //\n  // Extends prototype of native string object to allow for \"foo\".red syntax\n  //\n  var addProperty = function(color, func) {\n    String.prototype.__defineGetter__(color, func);\n  };\n\n  addProperty('strip', function() {\n    return colors.strip(this);\n  });\n\n  addProperty('stripColors', function() {\n    return colors.strip(this);\n  });\n\n  addProperty('trap', function() {\n    return colors.trap(this);\n  });\n\n  addProperty('zalgo', function() {\n    return colors.zalgo(this);\n  });\n\n  addProperty('zebra', function() {\n    return colors.zebra(this);\n  });\n\n  addProperty('rainbow', function() {\n    return colors.rainbow(this);\n  });\n\n  addProperty('random', function() {\n    return colors.random(this);\n  });\n\n  addProperty('america', function() {\n    return colors.america(this);\n  });\n\n  //\n  // Iterate through all default styles and colors\n  //\n  var x = Object.keys(colors.styles);\n  x.forEach(function(style) {\n    addProperty(style, function() {\n      return colors.stylize(this, style);\n    });\n  });\n\n  function applyTheme(theme) {\n    //\n    // Remark: This is a list of methods that exist\n    // on String that you should not overwrite.\n    //\n    var stringPrototypeBlacklist = [\n      '__defineGetter__', '__defineSetter__', '__lookupGetter__',\n      '__lookupSetter__', 'charAt', 'constructor', 'hasOwnProperty',\n      'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString',\n      'valueOf', 'charCodeAt', 'indexOf', 'lastIndexOf', 'length',\n      'localeCompare', 'match', 'repeat', 'replace', 'search', 'slice',\n      'split', 'substring', 'toLocaleLowerCase', 'toLocaleUpperCase',\n      'toLowerCase', 'toUpperCase', 'trim', 'trimLeft', 'trimRight',\n    ];\n\n    Object.keys(theme).forEach(function(prop) {\n      if (stringPrototypeBlacklist.indexOf(prop) !== -1) {\n        console.log('warn: '.red + ('String.prototype' + prop).magenta +\n          ' is probably something you don\\'t want to override.  ' +\n          'Ignoring style name');\n      } else {\n        if (typeof(theme[prop]) === 'string') {\n          colors[prop] = colors[theme[prop]];\n          addProperty(prop, function() {\n            return colors[prop](this);\n          });\n        } else {\n          var themePropApplicator = function(str) {\n            var ret = str || this;\n            for (var t = 0; t < theme[prop].length; t++) {\n              ret = colors[theme[prop][t]](ret);\n            }\n            return ret;\n          };\n          addProperty(prop, themePropApplicator);\n          colors[prop] = function(str) {\n            return themePropApplicator(str);\n          };\n        }\n      }\n    });\n  }\n\n  colors.setTheme = function(theme) {\n    if (typeof theme === 'string') {\n      console.log('colors.setTheme now only accepts an object, not a string. ' +\n        'If you are trying to set a theme from a file, it is now your (the ' +\n        'caller\\'s) responsibility to require the file.  The old syntax ' +\n        'looked like colors.setTheme(__dirname + ' +\n        '\\'/../themes/generic-logging.js\\'); The new syntax looks like '+\n        'colors.setTheme(require(__dirname + ' +\n        '\\'/../themes/generic-logging.js\\'));');\n      return;\n    } else {\n      applyTheme(theme);\n    }\n  };\n};\n","var colors = require('./colors');\nmodule['exports'] = colors;\n\n// Remark: By default, colors will add style properties to String.prototype.\n//\n// If you don't wish to extend String.prototype, you can do this instead and\n// native String will not be touched:\n//\n//   var colors = require('colors/safe);\n//   colors.red(\"foo\")\n//\n//\nrequire('./extendStringPrototype')();\n","module['exports'] = function(colors) {\n  return function(letter, i, exploded) {\n    if (letter === ' ') return letter;\n    switch (i%3) {\n      case 0: return colors.red(letter);\n      case 1: return colors.white(letter);\n      case 2: return colors.blue(letter);\n    }\n  };\n};\n","module['exports'] = function(colors) {\n  // RoY G BiV\n  var rainbowColors = ['red', 'yellow', 'green', 'blue', 'magenta'];\n  return function(letter, i, exploded) {\n    if (letter === ' ') {\n      return letter;\n    } else {\n      return colors[rainbowColors[i++ % rainbowColors.length]](letter);\n    }\n  };\n};\n\n","module['exports'] = function(colors) {\n  var available = ['underline', 'inverse', 'grey', 'yellow', 'red', 'green',\n    'blue', 'white', 'cyan', 'magenta', 'brightYellow', 'brightRed',\n    'brightGreen', 'brightBlue', 'brightWhite', 'brightCyan', 'brightMagenta'];\n  return function(letter, i, exploded) {\n    return letter === ' ' ? letter :\n      colors[\n          available[Math.round(Math.random() * (available.length - 2))]\n      ](letter);\n  };\n};\n","module['exports'] = function(colors) {\n  return function(letter, i, exploded) {\n    return i % 2 === 0 ? letter : colors.inverse(letter);\n  };\n};\n","/*\nThe MIT License (MIT)\n\nCopyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n*/\n\nvar styles = {};\nmodule['exports'] = styles;\n\nvar codes = {\n  reset: [0, 0],\n\n  bold: [1, 22],\n  dim: [2, 22],\n  italic: [3, 23],\n  underline: [4, 24],\n  inverse: [7, 27],\n  hidden: [8, 28],\n  strikethrough: [9, 29],\n\n  black: [30, 39],\n  red: [31, 39],\n  green: [32, 39],\n  yellow: [33, 39],\n  blue: [34, 39],\n  magenta: [35, 39],\n  cyan: [36, 39],\n  white: [37, 39],\n  gray: [90, 39],\n  grey: [90, 39],\n\n  brightRed: [91, 39],\n  brightGreen: [92, 39],\n  brightYellow: [93, 39],\n  brightBlue: [94, 39],\n  brightMagenta: [95, 39],\n  brightCyan: [96, 39],\n  brightWhite: [97, 39],\n\n  bgBlack: [40, 49],\n  bgRed: [41, 49],\n  bgGreen: [42, 49],\n  bgYellow: [43, 49],\n  bgBlue: [44, 49],\n  bgMagenta: [45, 49],\n  bgCyan: [46, 49],\n  bgWhite: [47, 49],\n  bgGray: [100, 49],\n  bgGrey: [100, 49],\n\n  bgBrightRed: [101, 49],\n  bgBrightGreen: [102, 49],\n  bgBrightYellow: [103, 49],\n  bgBrightBlue: [104, 49],\n  bgBrightMagenta: [105, 49],\n  bgBrightCyan: [106, 49],\n  bgBrightWhite: [107, 49],\n\n  // legacy styles for colors pre v1.0.0\n  blackBG: [40, 49],\n  redBG: [41, 49],\n  greenBG: [42, 49],\n  yellowBG: [43, 49],\n  blueBG: [44, 49],\n  magentaBG: [45, 49],\n  cyanBG: [46, 49],\n  whiteBG: [47, 49],\n\n};\n\nObject.keys(codes).forEach(function(key) {\n  var val = codes[key];\n  var style = styles[key] = [];\n  style.open = '\\u001b[' + val[0] + 'm';\n  style.close = '\\u001b[' + val[1] + 'm';\n});\n","/*\nMIT License\n\nCopyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\n'use strict';\n\nmodule.exports = function(flag, argv) {\n  argv = argv || process.argv;\n\n  var terminatorPos = argv.indexOf('--');\n  var prefix = /^-{1,2}/.test(flag) ? '' : '--';\n  var pos = argv.indexOf(prefix + flag);\n\n  return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);\n};\n","/*\nThe MIT License (MIT)\n\nCopyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n*/\n\n'use strict';\n\nvar os = require('os');\nvar hasFlag = require('./has-flag.js');\n\nvar env = process.env;\n\nvar forceColor = void 0;\nif (hasFlag('no-color') || hasFlag('no-colors') || hasFlag('color=false')) {\n  forceColor = false;\n} else if (hasFlag('color') || hasFlag('colors') || hasFlag('color=true')\n           || hasFlag('color=always')) {\n  forceColor = true;\n}\nif ('FORCE_COLOR' in env) {\n  forceColor = env.FORCE_COLOR.length === 0\n    || parseInt(env.FORCE_COLOR, 10) !== 0;\n}\n\nfunction translateLevel(level) {\n  if (level === 0) {\n    return false;\n  }\n\n  return {\n    level: level,\n    hasBasic: true,\n    has256: level >= 2,\n    has16m: level >= 3,\n  };\n}\n\nfunction supportsColor(stream) {\n  if (forceColor === false) {\n    return 0;\n  }\n\n  if (hasFlag('color=16m') || hasFlag('color=full')\n      || hasFlag('color=truecolor')) {\n    return 3;\n  }\n\n  if (hasFlag('color=256')) {\n    return 2;\n  }\n\n  if (stream && !stream.isTTY && forceColor !== true) {\n    return 0;\n  }\n\n  var min = forceColor ? 1 : 0;\n\n  if (process.platform === 'win32') {\n    // Node.js 7.5.0 is the first version of Node.js to include a patch to\n    // libuv that enables 256 color output on Windows. Anything earlier and it\n    // won't work. However, here we target Node.js 8 at minimum as it is an LTS\n    // release, and Node.js 7 is not. Windows 10 build 10586 is the first\n    // Windows release that supports 256 colors. Windows 10 build 14931 is the\n    // first release that supports 16m/TrueColor.\n    var osRelease = os.release().split('.');\n    if (Number(process.versions.node.split('.')[0]) >= 8\n        && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {\n      return Number(osRelease[2]) >= 14931 ? 3 : 2;\n    }\n\n    return 1;\n  }\n\n  if ('CI' in env) {\n    if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(function(sign) {\n      return sign in env;\n    }) || env.CI_NAME === 'codeship') {\n      return 1;\n    }\n\n    return min;\n  }\n\n  if ('TEAMCITY_VERSION' in env) {\n    return (/^(9\\.(0*[1-9]\\d*)\\.|\\d{2,}\\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0\n    );\n  }\n\n  if ('TERM_PROGRAM' in env) {\n    var version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);\n\n    switch (env.TERM_PROGRAM) {\n      case 'iTerm.app':\n        return version >= 3 ? 3 : 2;\n      case 'Hyper':\n        return 3;\n      case 'Apple_Terminal':\n        return 2;\n      // No default\n    }\n  }\n\n  if (/-256(color)?$/i.test(env.TERM)) {\n    return 2;\n  }\n\n  if (/^screen|^xterm|^vt100|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {\n    return 1;\n  }\n\n  if ('COLORTERM' in env) {\n    return 1;\n  }\n\n  if (env.TERM === 'dumb') {\n    return min;\n  }\n\n  return min;\n}\n\nfunction getSupportLevel(stream) {\n  var level = supportsColor(stream);\n  return translateLevel(level);\n}\n\nmodule.exports = {\n  supportsColor: getSupportLevel,\n  stdout: getSupportLevel(process.stdout),\n  stderr: getSupportLevel(process.stderr),\n};\n","module.exports = function (xs, fn) {\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        var x = fn(xs[i], i);\n        if (isArray(x)) res.push.apply(res, x);\n        else res.push(x);\n    }\n    return res;\n};\n\nvar isArray = Array.isArray || function (xs) {\n    return Object.prototype.toString.call(xs) === '[object Array]';\n};\n","(function () {\n\t'use strict';\n\n\tvar table = [],\n\t\tpoly = 0xEDB88320; // reverse polynomial\n\n\t// build the table\n\tfunction makeTable() {\n\t\tvar c, n, k;\n\n\t\tfor (n = 0; n < 256; n += 1) {\n\t\t\tc = n;\n\t\t\tfor (k = 0; k < 8; k += 1) {\n\t\t\t\tif (c & 1) {\n\t\t\t\t\tc = poly ^ (c >>> 1);\n\t\t\t\t} else {\n\t\t\t\t\tc = c >>> 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttable[n] = c >>> 0;\n\t\t}\n\t}\n\n\tfunction strToArr(str) {\n\t\t// sweet hack to turn string into a 'byte' array\n\t\treturn Array.prototype.map.call(str, function (c) {\n\t\t\treturn c.charCodeAt(0);\n\t\t});\n\t}\n\n\t/*\n\t * Compute CRC of array directly.\n\t *\n\t * This is slower for repeated calls, so append mode is not supported.\n\t */\n\tfunction crcDirect(arr) {\n\t\tvar crc = -1, // initial contents of LFBSR\n\t\t\ti, j, l, temp;\n\n\t\tfor (i = 0, l = arr.length; i < l; i += 1) {\n\t\t\ttemp = (crc ^ arr[i]) & 0xff;\n\n\t\t\t// read 8 bits one at a time\n\t\t\tfor (j = 0; j < 8; j += 1) {\n\t\t\t\tif ((temp & 1) === 1) {\n\t\t\t\t\ttemp = (temp >>> 1) ^ poly;\n\t\t\t\t} else {\n\t\t\t\t\ttemp = (temp >>> 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcrc = (crc >>> 8) ^ temp;\n\t\t}\n\n\t\t// flip bits\n\t\treturn crc ^ -1;\n\t}\n\n\t/*\n\t * Compute CRC with the help of a pre-calculated table.\n\t *\n\t * This supports append mode, if the second parameter is set.\n\t */\n\tfunction crcTable(arr, append) {\n\t\tvar crc, i, l;\n\n\t\t// if we're in append mode, don't reset crc\n\t\t// if arr is null or undefined, reset table and return\n\t\tif (typeof crcTable.crc === 'undefined' || !append || !arr) {\n\t\t\tcrcTable.crc = 0 ^ -1;\n\n\t\t\tif (!arr) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// store in temp variable for minor speed gain\n\t\tcrc = crcTable.crc;\n\n\t\tfor (i = 0, l = arr.length; i < l; i += 1) {\n\t\t\tcrc = (crc >>> 8) ^ table[(crc ^ arr[i]) & 0xff];\n\t\t}\n\n\t\tcrcTable.crc = crc;\n\n\t\treturn crc ^ -1;\n\t}\n\n\t// build the table\n\t// this isn't that costly, and most uses will be for table assisted mode\n\tmakeTable();\n\n\tmodule.exports = function (val, direct) {\n\t\tvar val = (typeof val === 'string') ? strToArr(val) : val,\n\t\t\tret = direct ? crcDirect(val) : crcTable(val);\n\n\t\t// convert to 2's complement hex\n\t\treturn (ret >>> 0).toString(16);\n\t};\n\tmodule.exports.direct = crcDirect;\n\tmodule.exports.table = crcTable;\n}());\n","(function () {\n\t'use strict';\n\n\tmodule.exports = {\n\t\t'inflate': require('./lib/rawinflate.js'),\n\t\t'deflate': require('./lib/rawdeflate.js')\n\t};\n}());\n","/*\n * $Id: rawdeflate.js,v 0.3 2009/03/01 19:05:05 dankogai Exp dankogai $\n *\n * Original:\n *   http://www.onicos.com/staff/iz/amuse/javascript/expert/deflate.txt\n */\n\n/* Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>\n * Version: 1.0.1\n * LastModified: Dec 25 1999\n */\n\n/* Interface:\n * data = deflate(src);\n */\n\n(function () {\n\t/* constant parameters */\n\tvar WSIZE = 32768, // Sliding Window size\n\t\tSTORED_BLOCK = 0,\n\t\tSTATIC_TREES = 1,\n\t\tDYN_TREES = 2,\n\n\t/* for deflate */\n\t\tDEFAULT_LEVEL = 6,\n\t\tFULL_SEARCH = false,\n\t\tINBUFSIZ = 32768, // Input buffer size\n\t\t//INBUF_EXTRA = 64, // Extra buffer\n\t\tOUTBUFSIZ = 1024 * 8,\n\t\twindow_size = 2 * WSIZE,\n\t\tMIN_MATCH = 3,\n\t\tMAX_MATCH = 258,\n\t\tBITS = 16,\n\t// for SMALL_MEM\n\t\tLIT_BUFSIZE = 0x2000,\n//\t\tHASH_BITS = 13,\n\t//for MEDIUM_MEM\n\t//\tLIT_BUFSIZE = 0x4000,\n\t//\tHASH_BITS = 14,\n\t// for BIG_MEM\n\t//\tLIT_BUFSIZE = 0x8000,\n\t\tHASH_BITS = 15,\n\t\tDIST_BUFSIZE = LIT_BUFSIZE,\n\t\tHASH_SIZE = 1 << HASH_BITS,\n\t\tHASH_MASK = HASH_SIZE - 1,\n\t\tWMASK = WSIZE - 1,\n\t\tNIL = 0, // Tail of hash chains\n\t\tTOO_FAR = 4096,\n\t\tMIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1,\n\t\tMAX_DIST = WSIZE - MIN_LOOKAHEAD,\n\t\tSMALLEST = 1,\n\t\tMAX_BITS = 15,\n\t\tMAX_BL_BITS = 7,\n\t\tLENGTH_CODES = 29,\n\t\tLITERALS = 256,\n\t\tEND_BLOCK = 256,\n\t\tL_CODES = LITERALS + 1 + LENGTH_CODES,\n\t\tD_CODES = 30,\n\t\tBL_CODES = 19,\n\t\tREP_3_6 = 16,\n\t\tREPZ_3_10 = 17,\n\t\tREPZ_11_138 = 18,\n\t\tHEAP_SIZE = 2 * L_CODES + 1,\n\t\tH_SHIFT = parseInt((HASH_BITS + MIN_MATCH - 1) / MIN_MATCH, 10),\n\n\t/* variables */\n\t\tfree_queue,\n\t\tqhead,\n\t\tqtail,\n\t\tinitflag,\n\t\toutbuf = null,\n\t\toutcnt,\n\t\toutoff,\n\t\tcomplete,\n\t\twindow,\n\t\td_buf,\n\t\tl_buf,\n\t\tprev,\n\t\tbi_buf,\n\t\tbi_valid,\n\t\tblock_start,\n\t\tins_h,\n\t\thash_head,\n\t\tprev_match,\n\t\tmatch_available,\n\t\tmatch_length,\n\t\tprev_length,\n\t\tstrstart,\n\t\tmatch_start,\n\t\teofile,\n\t\tlookahead,\n\t\tmax_chain_length,\n\t\tmax_lazy_match,\n\t\tcompr_level,\n\t\tgood_match,\n\t\tnice_match,\n\t\tdyn_ltree,\n\t\tdyn_dtree,\n\t\tstatic_ltree,\n\t\tstatic_dtree,\n\t\tbl_tree,\n\t\tl_desc,\n\t\td_desc,\n\t\tbl_desc,\n\t\tbl_count,\n\t\theap,\n\t\theap_len,\n\t\theap_max,\n\t\tdepth,\n\t\tlength_code,\n\t\tdist_code,\n\t\tbase_length,\n\t\tbase_dist,\n\t\tflag_buf,\n\t\tlast_lit,\n\t\tlast_dist,\n\t\tlast_flags,\n\t\tflags,\n\t\tflag_bit,\n\t\topt_len,\n\t\tstatic_len,\n\t\tdeflate_data,\n\t\tdeflate_pos;\n\n\tif (LIT_BUFSIZE > INBUFSIZ) {\n\t\tconsole.error(\"error: INBUFSIZ is too small\");\n\t}\n\tif ((WSIZE << 1) > (1 << BITS)) {\n\t\tconsole.error(\"error: WSIZE is too large\");\n\t}\n\tif (HASH_BITS > BITS - 1) {\n\t\tconsole.error(\"error: HASH_BITS is too large\");\n\t}\n\tif (HASH_BITS < 8 || MAX_MATCH !== 258) {\n\t\tconsole.error(\"error: Code too clever\");\n\t}\n\n\t/* objects (deflate) */\n\n\tfunction DeflateCT() {\n\t\tthis.fc = 0; // frequency count or bit string\n\t\tthis.dl = 0; // father node in Huffman tree or length of bit string\n\t}\n\n\tfunction DeflateTreeDesc() {\n\t\tthis.dyn_tree = null; // the dynamic tree\n\t\tthis.static_tree = null; // corresponding static tree or NULL\n\t\tthis.extra_bits = null; // extra bits for each code or NULL\n\t\tthis.extra_base = 0; // base index for extra_bits\n\t\tthis.elems = 0; // max number of elements in the tree\n\t\tthis.max_length = 0; // max bit length for the codes\n\t\tthis.max_code = 0; // largest code with non zero frequency\n\t}\n\n\t/* Values for max_lazy_match, good_match and max_chain_length, depending on\n\t * the desired pack level (0..9). The values given below have been tuned to\n\t * exclude worst case performance for pathological files. Better values may be\n\t * found for specific files.\n\t */\n\tfunction DeflateConfiguration(a, b, c, d) {\n\t\tthis.good_length = a; // reduce lazy search above this match length\n\t\tthis.max_lazy = b; // do not perform lazy search above this match length\n\t\tthis.nice_length = c; // quit search above this match length\n\t\tthis.max_chain = d;\n\t}\n\n\tfunction DeflateBuffer() {\n\t\tthis.next = null;\n\t\tthis.len = 0;\n\t\tthis.ptr = []; // new Array(OUTBUFSIZ); // ptr.length is never read\n\t\tthis.off = 0;\n\t}\n\n\t/* constant tables */\n\tvar extra_lbits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];\n\tvar extra_dbits = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];\n\tvar extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];\n\tvar bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n\tvar configuration_table = [\n\t\tnew DeflateConfiguration(0, 0, 0, 0),\n\t\tnew DeflateConfiguration(4, 4, 8, 4),\n\t\tnew DeflateConfiguration(4, 5, 16, 8),\n\t\tnew DeflateConfiguration(4, 6, 32, 32),\n\t\tnew DeflateConfiguration(4, 4, 16, 16),\n\t\tnew DeflateConfiguration(8, 16, 32, 32),\n\t\tnew DeflateConfiguration(8, 16, 128, 128),\n\t\tnew DeflateConfiguration(8, 32, 128, 256),\n\t\tnew DeflateConfiguration(32, 128, 258, 1024),\n\t\tnew DeflateConfiguration(32, 258, 258, 4096)\n\t];\n\n\n\t/* routines (deflate) */\n\n\tfunction deflate_start(level) {\n\t\tvar i;\n\n\t\tif (!level) {\n\t\t\tlevel = DEFAULT_LEVEL;\n\t\t} else if (level < 1) {\n\t\t\tlevel = 1;\n\t\t} else if (level > 9) {\n\t\t\tlevel = 9;\n\t\t}\n\n\t\tcompr_level = level;\n\t\tinitflag = false;\n\t\teofile = false;\n\t\tif (outbuf !== null) {\n\t\t\treturn;\n\t\t}\n\n\t\tfree_queue = qhead = qtail = null;\n\t\toutbuf = []; // new Array(OUTBUFSIZ); // outbuf.length never called\n\t\twindow = []; // new Array(window_size); // window.length never called\n\t\td_buf = []; // new Array(DIST_BUFSIZE); // d_buf.length never called\n\t\tl_buf = []; // new Array(INBUFSIZ + INBUF_EXTRA); // l_buf.length never called\n\t\tprev = []; // new Array(1 << BITS); // prev.length never called\n\n\t\tdyn_ltree = [];\n\t\tfor (i = 0; i < HEAP_SIZE; i++) {\n\t\t\tdyn_ltree[i] = new DeflateCT();\n\t\t}\n\t\tdyn_dtree = [];\n\t\tfor (i = 0; i < 2 * D_CODES + 1; i++) {\n\t\t\tdyn_dtree[i] = new DeflateCT();\n\t\t}\n\t\tstatic_ltree = [];\n\t\tfor (i = 0; i < L_CODES + 2; i++) {\n\t\t\tstatic_ltree[i] = new DeflateCT();\n\t\t}\n\t\tstatic_dtree = [];\n\t\tfor (i = 0; i < D_CODES; i++) {\n\t\t\tstatic_dtree[i] = new DeflateCT();\n\t\t}\n\t\tbl_tree = [];\n\t\tfor (i = 0; i < 2 * BL_CODES + 1; i++) {\n\t\t\tbl_tree[i] = new DeflateCT();\n\t\t}\n\t\tl_desc = new DeflateTreeDesc();\n\t\td_desc = new DeflateTreeDesc();\n\t\tbl_desc = new DeflateTreeDesc();\n\t\tbl_count = []; // new Array(MAX_BITS+1); // bl_count.length never called\n\t\theap = []; // new Array(2*L_CODES+1); // heap.length never called\n\t\tdepth = []; // new Array(2*L_CODES+1); // depth.length never called\n\t\tlength_code = []; // new Array(MAX_MATCH-MIN_MATCH+1); // length_code.length never called\n\t\tdist_code = []; // new Array(512); // dist_code.length never called\n\t\tbase_length = []; // new Array(LENGTH_CODES); // base_length.length never called\n\t\tbase_dist = []; // new Array(D_CODES); // base_dist.length never called\n\t\tflag_buf = []; // new Array(parseInt(LIT_BUFSIZE / 8, 10)); // flag_buf.length never called\n\t}\n\n\tfunction deflate_end() {\n\t\tfree_queue = qhead = qtail = null;\n\t\toutbuf = null;\n\t\twindow = null;\n\t\td_buf = null;\n\t\tl_buf = null;\n\t\tprev = null;\n\t\tdyn_ltree = null;\n\t\tdyn_dtree = null;\n\t\tstatic_ltree = null;\n\t\tstatic_dtree = null;\n\t\tbl_tree = null;\n\t\tl_desc = null;\n\t\td_desc = null;\n\t\tbl_desc = null;\n\t\tbl_count = null;\n\t\theap = null;\n\t\tdepth = null;\n\t\tlength_code = null;\n\t\tdist_code = null;\n\t\tbase_length = null;\n\t\tbase_dist = null;\n\t\tflag_buf = null;\n\t}\n\n\tfunction reuse_queue(p) {\n\t\tp.next = free_queue;\n\t\tfree_queue = p;\n\t}\n\n\tfunction new_queue() {\n\t\tvar p;\n\n\t\tif (free_queue !== null) {\n\t\t\tp = free_queue;\n\t\t\tfree_queue = free_queue.next;\n\t\t} else {\n\t\t\tp = new DeflateBuffer();\n\t\t}\n\t\tp.next = null;\n\t\tp.len = p.off = 0;\n\n\t\treturn p;\n\t}\n\n\tfunction head1(i) {\n\t\treturn prev[WSIZE + i];\n\t}\n\n\tfunction head2(i, val) {\n\t\treturn (prev[WSIZE + i] = val);\n\t}\n\n\t/* put_byte is used for the compressed output, put_ubyte for the\n\t * uncompressed output. However unlzw() uses window for its\n\t * suffix table instead of its output buffer, so it does not use put_ubyte\n\t * (to be cleaned up).\n\t */\n\tfunction put_byte(c) {\n\t\toutbuf[outoff + outcnt++] = c;\n\t\tif (outoff + outcnt === OUTBUFSIZ) {\n\t\t\tqoutbuf();\n\t\t}\n\t}\n\n\t/* Output a 16 bit value, lsb first */\n\tfunction put_short(w) {\n\t\tw &= 0xffff;\n\t\tif (outoff + outcnt < OUTBUFSIZ - 2) {\n\t\t\toutbuf[outoff + outcnt++] = (w & 0xff);\n\t\t\toutbuf[outoff + outcnt++] = (w >>> 8);\n\t\t} else {\n\t\t\tput_byte(w & 0xff);\n\t\t\tput_byte(w >>> 8);\n\t\t}\n\t}\n\n\t/* ==========================================================================\n\t * Insert string s in the dictionary and set match_head to the previous head\n\t * of the hash chain (the most recent string with same hash key). Return\n\t * the previous length of the hash chain.\n\t * IN  assertion: all calls to to INSERT_STRING are made with consecutive\n\t *    input characters and the first MIN_MATCH bytes of s are valid\n\t *    (except for the last MIN_MATCH-1 bytes of the input file).\n\t */\n\tfunction INSERT_STRING() {\n\t\tins_h = ((ins_h << H_SHIFT) ^ (window[strstart + MIN_MATCH - 1] & 0xff)) & HASH_MASK;\n\t\thash_head = head1(ins_h);\n\t\tprev[strstart & WMASK] = hash_head;\n\t\thead2(ins_h, strstart);\n\t}\n\n\t/* Send a code of the given tree. c and tree must not have side effects */\n\tfunction SEND_CODE(c, tree) {\n\t\tsend_bits(tree[c].fc, tree[c].dl);\n\t}\n\n\t/* Mapping from a distance to a distance code. dist is the distance - 1 and\n\t * must not have side effects. dist_code[256] and dist_code[257] are never\n\t * used.\n\t */\n\tfunction D_CODE(dist) {\n\t\treturn (dist < 256 ? dist_code[dist] : dist_code[256 + (dist >> 7)]) & 0xff;\n\t}\n\n\t/* ==========================================================================\n\t * Compares to subtrees, using the tree depth as tie breaker when\n\t * the subtrees have equal frequency. This minimizes the worst case length.\n\t */\n\tfunction SMALLER(tree, n, m) {\n\t\treturn tree[n].fc < tree[m].fc || (tree[n].fc === tree[m].fc && depth[n] <= depth[m]);\n\t}\n\n\t/* ==========================================================================\n\t * read string data\n\t */\n\tfunction read_buff(buff, offset, n) {\n\t\tvar i;\n\t\tfor (i = 0; i < n && deflate_pos < deflate_data.length; i++) {\n\t\t\tbuff[offset + i] = deflate_data[deflate_pos++] & 0xff;\n\t\t}\n\t\treturn i;\n\t}\n\n\t/* ==========================================================================\n\t * Initialize the \"longest match\" routines for a new file\n\t */\n\tfunction lm_init() {\n\t\tvar j;\n\n\t\t// Initialize the hash table. */\n\t\tfor (j = 0; j < HASH_SIZE; j++) {\n\t\t\t// head2(j, NIL);\n\t\t\tprev[WSIZE + j] = 0;\n\t\t}\n\t\t// prev will be initialized on the fly */\n\n\t\t// Set the default configuration parameters:\n\t\tmax_lazy_match = configuration_table[compr_level].max_lazy;\n\t\tgood_match = configuration_table[compr_level].good_length;\n\t\tif (!FULL_SEARCH) {\n\t\t\tnice_match = configuration_table[compr_level].nice_length;\n\t\t}\n\t\tmax_chain_length = configuration_table[compr_level].max_chain;\n\n\t\tstrstart = 0;\n\t\tblock_start = 0;\n\n\t\tlookahead = read_buff(window, 0, 2 * WSIZE);\n\t\tif (lookahead <= 0) {\n\t\t\teofile = true;\n\t\t\tlookahead = 0;\n\t\t\treturn;\n\t\t}\n\t\teofile = false;\n\t\t// Make sure that we always have enough lookahead. This is important\n\t\t// if input comes from a device such as a tty.\n\t\twhile (lookahead < MIN_LOOKAHEAD && !eofile) {\n\t\t\tfill_window();\n\t\t}\n\n\t\t// If lookahead < MIN_MATCH, ins_h is garbage, but this is\n\t\t// not important since only literal bytes will be emitted.\n\t\tins_h = 0;\n\t\tfor (j = 0; j < MIN_MATCH - 1; j++) {\n\t\t\t// UPDATE_HASH(ins_h, window[j]);\n\t\t\tins_h = ((ins_h << H_SHIFT) ^ (window[j] & 0xff)) & HASH_MASK;\n\t\t}\n\t}\n\n\t/* ==========================================================================\n\t * Set match_start to the longest match starting at the given string and\n\t * return its length. Matches shorter or equal to prev_length are discarded,\n\t * in which case the result is equal to prev_length and match_start is\n\t * garbage.\n\t * IN assertions: cur_match is the head of the hash chain for the current\n\t *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n\t */\n\tfunction longest_match(cur_match) {\n\t\tvar chain_length = max_chain_length; // max hash chain length\n\t\tvar scanp = strstart; // current string\n\t\tvar matchp; // matched string\n\t\tvar len; // length of current match\n\t\tvar best_len = prev_length; // best match length so far\n\n\t\t// Stop when cur_match becomes <= limit. To simplify the code,\n\t\t// we prevent matches with the string of window index 0.\n\t\tvar limit = (strstart > MAX_DIST ? strstart - MAX_DIST : NIL);\n\n\t\tvar strendp = strstart + MAX_MATCH;\n\t\tvar scan_end1 = window[scanp + best_len - 1];\n\t\tvar scan_end = window[scanp + best_len];\n\n\t\tvar i, broke;\n\n\t\t// Do not waste too much time if we already have a good match: */\n\t\tif (prev_length >= good_match) {\n\t\t\tchain_length >>= 2;\n\t\t}\n\n\t\t// Assert(encoder->strstart <= window_size-MIN_LOOKAHEAD, \"insufficient lookahead\");\n\n\t\tdo {\n\t\t\t// Assert(cur_match < encoder->strstart, \"no future\");\n\t\t\tmatchp = cur_match;\n\n\t\t\t// Skip to next match if the match length cannot increase\n\t\t\t// or if the match length is less than 2:\n\t\t\tif (window[matchp + best_len] !== scan_end  ||\n\t\t\t\t\twindow[matchp + best_len - 1] !== scan_end1 ||\n\t\t\t\t\twindow[matchp] !== window[scanp] ||\n\t\t\t\t\twindow[++matchp] !== window[scanp + 1]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// The check at best_len-1 can be removed because it will be made\n\t\t\t// again later. (This heuristic is not always a win.)\n\t\t\t// It is not necessary to compare scan[2] and match[2] since they\n\t\t\t// are always equal when the other bytes match, given that\n\t\t\t// the hash keys are equal and that HASH_BITS >= 8.\n\t\t\tscanp += 2;\n\t\t\tmatchp++;\n\n\t\t\t// We check for insufficient lookahead only every 8th comparison;\n\t\t\t// the 256th check will be made at strstart+258.\n\t\t\twhile (scanp < strendp) {\n\t\t\t\tbroke = false;\n\t\t\t\tfor (i = 0; i < 8; i += 1) {\n\t\t\t\t\tscanp += 1;\n\t\t\t\t\tmatchp += 1;\n\t\t\t\t\tif (window[scanp] !== window[matchp]) {\n\t\t\t\t\t\tbroke = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (broke) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlen = MAX_MATCH - (strendp - scanp);\n\t\t\tscanp = strendp - MAX_MATCH;\n\n\t\t\tif (len > best_len) {\n\t\t\t\tmatch_start = cur_match;\n\t\t\t\tbest_len = len;\n\t\t\t\tif (FULL_SEARCH) {\n\t\t\t\t\tif (len >= MAX_MATCH) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (len >= nice_match) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tscan_end1 = window[scanp + best_len - 1];\n\t\t\t\tscan_end = window[scanp + best_len];\n\t\t\t}\n\t\t} while ((cur_match = prev[cur_match & WMASK]) > limit && --chain_length !== 0);\n\n\t\treturn best_len;\n\t}\n\n\t/* ==========================================================================\n\t * Fill the window when the lookahead becomes insufficient.\n\t * Updates strstart and lookahead, and sets eofile if end of input file.\n\t * IN assertion: lookahead < MIN_LOOKAHEAD && strstart + lookahead > 0\n\t * OUT assertions: at least one byte has been read, or eofile is set;\n\t *    file reads are performed for at least two bytes (required for the\n\t *    translate_eol option).\n\t */\n\tfunction fill_window() {\n\t\tvar n, m;\n\n\t // Amount of free space at the end of the window.\n\t\tvar more = window_size - lookahead - strstart;\n\n\t\t// If the window is almost full and there is insufficient lookahead,\n\t\t// move the upper half to the lower one to make room in the upper half.\n\t\tif (more === -1) {\n\t\t\t// Very unlikely, but possible on 16 bit machine if strstart == 0\n\t\t\t// and lookahead == 1 (input done one byte at time)\n\t\t\tmore--;\n\t\t} else if (strstart >= WSIZE + MAX_DIST) {\n\t\t\t// By the IN assertion, the window is not empty so we can't confuse\n\t\t\t// more == 0 with more == 64K on a 16 bit machine.\n\t\t\t// Assert(window_size == (ulg)2*WSIZE, \"no sliding with BIG_MEM\");\n\n\t\t\t// System.arraycopy(window, WSIZE, window, 0, WSIZE);\n\t\t\tfor (n = 0; n < WSIZE; n++) {\n\t\t\t\twindow[n] = window[n + WSIZE];\n\t\t\t}\n\n\t\t\tmatch_start -= WSIZE;\n\t\t\tstrstart    -= WSIZE; /* we now have strstart >= MAX_DIST: */\n\t\t\tblock_start -= WSIZE;\n\n\t\t\tfor (n = 0; n < HASH_SIZE; n++) {\n\t\t\t\tm = head1(n);\n\t\t\t\thead2(n, m >= WSIZE ? m - WSIZE : NIL);\n\t\t\t}\n\t\t\tfor (n = 0; n < WSIZE; n++) {\n\t\t\t// If n is not on any hash chain, prev[n] is garbage but\n\t\t\t// its value will never be used.\n\t\t\t\tm = prev[n];\n\t\t\t\tprev[n] = (m >= WSIZE ? m - WSIZE : NIL);\n\t\t\t}\n\t\t\tmore += WSIZE;\n\t\t}\n\t\t// At this point, more >= 2\n\t\tif (!eofile) {\n\t\t\tn = read_buff(window, strstart + lookahead, more);\n\t\t\tif (n <= 0) {\n\t\t\t\teofile = true;\n\t\t\t} else {\n\t\t\t\tlookahead += n;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* ==========================================================================\n\t * Processes a new input file and return its compressed length. This\n\t * function does not perform lazy evaluationof matches and inserts\n\t * new strings in the dictionary only for unmatched strings or for short\n\t * matches. It is used only for the fast compression options.\n\t */\n\tfunction deflate_fast() {\n\t\twhile (lookahead !== 0 && qhead === null) {\n\t\t\tvar flush; // set if current block must be flushed\n\n\t\t\t// Insert the string window[strstart .. strstart+2] in the\n\t\t\t// dictionary, and set hash_head to the head of the hash chain:\n\t\t\tINSERT_STRING();\n\n\t\t\t// Find the longest match, discarding those <= prev_length.\n\t\t\t// At this point we have always match_length < MIN_MATCH\n\t\t\tif (hash_head !== NIL && strstart - hash_head <= MAX_DIST) {\n\t\t\t\t// To simplify the code, we prevent matches with the string\n\t\t\t\t// of window index 0 (in particular we have to avoid a match\n\t\t\t\t// of the string with itself at the start of the input file).\n\t\t\t\tmatch_length = longest_match(hash_head);\n\t\t\t\t// longest_match() sets match_start */\n\t\t\t\tif (match_length > lookahead) {\n\t\t\t\t\tmatch_length = lookahead;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (match_length >= MIN_MATCH) {\n\t\t\t\t// check_match(strstart, match_start, match_length);\n\n\t\t\t\tflush = ct_tally(strstart - match_start, match_length - MIN_MATCH);\n\t\t\t\tlookahead -= match_length;\n\n\t\t\t\t// Insert new strings in the hash table only if the match length\n\t\t\t\t// is not too large. This saves time but degrades compression.\n\t\t\t\tif (match_length <= max_lazy_match) {\n\t\t\t\t\tmatch_length--; // string at strstart already in hash table\n\t\t\t\t\tdo {\n\t\t\t\t\t\tstrstart++;\n\t\t\t\t\t\tINSERT_STRING();\n\t\t\t\t\t\t// strstart never exceeds WSIZE-MAX_MATCH, so there are\n\t\t\t\t\t\t// always MIN_MATCH bytes ahead. If lookahead < MIN_MATCH\n\t\t\t\t\t\t// these bytes are garbage, but it does not matter since\n\t\t\t\t\t\t// the next lookahead bytes will be emitted as literals.\n\t\t\t\t\t} while (--match_length !== 0);\n\t\t\t\t\tstrstart++;\n\t\t\t\t} else {\n\t\t\t\t\tstrstart += match_length;\n\t\t\t\t\tmatch_length = 0;\n\t\t\t\t\tins_h = window[strstart] & 0xff;\n\t\t\t\t\t// UPDATE_HASH(ins_h, window[strstart + 1]);\n\t\t\t\t\tins_h = ((ins_h << H_SHIFT) ^ (window[strstart + 1] & 0xff)) & HASH_MASK;\n\n\t\t\t\t//#if MIN_MATCH !== 3\n\t\t\t\t//\t\tCall UPDATE_HASH() MIN_MATCH-3 more times\n\t\t\t\t//#endif\n\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// No match, output a literal byte */\n\t\t\t\tflush = ct_tally(0, window[strstart] & 0xff);\n\t\t\t\tlookahead--;\n\t\t\t\tstrstart++;\n\t\t\t}\n\t\t\tif (flush) {\n\t\t\t\tflush_block(0);\n\t\t\t\tblock_start = strstart;\n\t\t\t}\n\n\t\t\t// Make sure that we always have enough lookahead, except\n\t\t\t// at the end of the input file. We need MAX_MATCH bytes\n\t\t\t// for the next match, plus MIN_MATCH bytes to insert the\n\t\t\t// string following the next match.\n\t\t\twhile (lookahead < MIN_LOOKAHEAD && !eofile) {\n\t\t\t\tfill_window();\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction deflate_better() {\n\t\t// Process the input block. */\n\t\twhile (lookahead !== 0 && qhead === null) {\n\t\t\t// Insert the string window[strstart .. strstart+2] in the\n\t\t\t// dictionary, and set hash_head to the head of the hash chain:\n\t\t\tINSERT_STRING();\n\n\t\t\t// Find the longest match, discarding those <= prev_length.\n\t\t\tprev_length = match_length;\n\t\t\tprev_match = match_start;\n\t\t\tmatch_length = MIN_MATCH - 1;\n\n\t\t\tif (hash_head !== NIL && prev_length < max_lazy_match && strstart - hash_head <= MAX_DIST) {\n\t\t\t\t// To simplify the code, we prevent matches with the string\n\t\t\t\t// of window index 0 (in particular we have to avoid a match\n\t\t\t\t// of the string with itself at the start of the input file).\n\t\t\t\tmatch_length = longest_match(hash_head);\n\t\t\t\t// longest_match() sets match_start */\n\t\t\t\tif (match_length > lookahead) {\n\t\t\t\t\tmatch_length = lookahead;\n\t\t\t\t}\n\n\t\t\t\t// Ignore a length 3 match if it is too distant: */\n\t\t\t\tif (match_length === MIN_MATCH && strstart - match_start > TOO_FAR) {\n\t\t\t\t\t// If prev_match is also MIN_MATCH, match_start is garbage\n\t\t\t\t\t// but we will ignore the current match anyway.\n\t\t\t\t\tmatch_length--;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// If there was a match at the previous step and the current\n\t\t\t// match is not better, output the previous match:\n\t\t\tif (prev_length >= MIN_MATCH && match_length <= prev_length) {\n\t\t\t\tvar flush; // set if current block must be flushed\n\n\t\t\t\t// check_match(strstart - 1, prev_match, prev_length);\n\t\t\t\tflush = ct_tally(strstart - 1 - prev_match, prev_length - MIN_MATCH);\n\n\t\t\t\t// Insert in hash table all strings up to the end of the match.\n\t\t\t\t// strstart-1 and strstart are already inserted.\n\t\t\t\tlookahead -= prev_length - 1;\n\t\t\t\tprev_length -= 2;\n\t\t\t\tdo {\n\t\t\t\t\tstrstart++;\n\t\t\t\t\tINSERT_STRING();\n\t\t\t\t\t// strstart never exceeds WSIZE-MAX_MATCH, so there are\n\t\t\t\t\t// always MIN_MATCH bytes ahead. If lookahead < MIN_MATCH\n\t\t\t\t\t// these bytes are garbage, but it does not matter since the\n\t\t\t\t\t// next lookahead bytes will always be emitted as literals.\n\t\t\t\t} while (--prev_length !== 0);\n\t\t\t\tmatch_available = false;\n\t\t\t\tmatch_length = MIN_MATCH - 1;\n\t\t\t\tstrstart++;\n\t\t\t\tif (flush) {\n\t\t\t\t\tflush_block(0);\n\t\t\t\t\tblock_start = strstart;\n\t\t\t\t}\n\t\t\t} else if (match_available) {\n\t\t\t\t// If there was no match at the previous position, output a\n\t\t\t\t// single literal. If there was a match but the current match\n\t\t\t\t// is longer, truncate the previous match to a single literal.\n\t\t\t\tif (ct_tally(0, window[strstart - 1] & 0xff)) {\n\t\t\t\t\tflush_block(0);\n\t\t\t\t\tblock_start = strstart;\n\t\t\t\t}\n\t\t\t\tstrstart++;\n\t\t\t\tlookahead--;\n\t\t\t} else {\n\t\t\t\t// There is no previous match to compare with, wait for\n\t\t\t\t// the next step to decide.\n\t\t\t\tmatch_available = true;\n\t\t\t\tstrstart++;\n\t\t\t\tlookahead--;\n\t\t\t}\n\n\t\t\t// Make sure that we always have enough lookahead, except\n\t\t\t// at the end of the input file. We need MAX_MATCH bytes\n\t\t\t// for the next match, plus MIN_MATCH bytes to insert the\n\t\t\t// string following the next match.\n\t\t\twhile (lookahead < MIN_LOOKAHEAD && !eofile) {\n\t\t\t\tfill_window();\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction init_deflate() {\n\t\tif (eofile) {\n\t\t\treturn;\n\t\t}\n\t\tbi_buf = 0;\n\t\tbi_valid = 0;\n\t\tct_init();\n\t\tlm_init();\n\n\t\tqhead = null;\n\t\toutcnt = 0;\n\t\toutoff = 0;\n\n\t\tif (compr_level <= 3) {\n\t\t\tprev_length = MIN_MATCH - 1;\n\t\t\tmatch_length = 0;\n\t\t} else {\n\t\t\tmatch_length = MIN_MATCH - 1;\n\t\t\tmatch_available = false;\n\t\t}\n\n\t\tcomplete = false;\n\t}\n\n\t/* ==========================================================================\n\t * Same as above, but achieves better compression. We use a lazy\n\t * evaluation for matches: a match is finally adopted only if there is\n\t * no better match at the next window position.\n\t */\n\tfunction deflate_internal(buff, off, buff_size) {\n\t\tvar n;\n\n\t\tif (!initflag) {\n\t\t\tinit_deflate();\n\t\t\tinitflag = true;\n\t\t\tif (lookahead === 0) { // empty\n\t\t\t\tcomplete = true;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tn = qcopy(buff, off, buff_size);\n\t\tif (n === buff_size) {\n\t\t\treturn buff_size;\n\t\t}\n\n\t\tif (complete) {\n\t\t\treturn n;\n\t\t}\n\n\t\tif (compr_level <= 3) {\n\t\t\t// optimized for speed\n\t\t\tdeflate_fast();\n\t\t} else {\n\t\t\tdeflate_better();\n\t\t}\n\n\t\tif (lookahead === 0) {\n\t\t\tif (match_available) {\n\t\t\t\tct_tally(0, window[strstart - 1] & 0xff);\n\t\t\t}\n\t\t\tflush_block(1);\n\t\t\tcomplete = true;\n\t\t}\n\n\t\treturn n + qcopy(buff, n + off, buff_size - n);\n\t}\n\n\tfunction qcopy(buff, off, buff_size) {\n\t\tvar n, i, j;\n\n\t\tn = 0;\n\t\twhile (qhead !== null && n < buff_size) {\n\t\t\ti = buff_size - n;\n\t\t\tif (i > qhead.len) {\n\t\t\t\ti = qhead.len;\n\t\t\t}\n\t\t\t// System.arraycopy(qhead.ptr, qhead.off, buff, off + n, i);\n\t\t\tfor (j = 0; j < i; j++) {\n\t\t\t\tbuff[off + n + j] = qhead.ptr[qhead.off + j];\n\t\t\t}\n\n\t\t\tqhead.off += i;\n\t\t\tqhead.len -= i;\n\t\t\tn += i;\n\t\t\tif (qhead.len === 0) {\n\t\t\t\tvar p;\n\t\t\t\tp = qhead;\n\t\t\t\tqhead = qhead.next;\n\t\t\t\treuse_queue(p);\n\t\t\t}\n\t\t}\n\n\t\tif (n === buff_size) {\n\t\t\treturn n;\n\t\t}\n\n\t\tif (outoff < outcnt) {\n\t\t\ti = buff_size - n;\n\t\t\tif (i > outcnt - outoff) {\n\t\t\t\ti = outcnt - outoff;\n\t\t\t}\n\t\t\t// System.arraycopy(outbuf, outoff, buff, off + n, i);\n\t\t\tfor (j = 0; j < i; j++) {\n\t\t\t\tbuff[off + n + j] = outbuf[outoff + j];\n\t\t\t}\n\t\t\toutoff += i;\n\t\t\tn += i;\n\t\t\tif (outcnt === outoff) {\n\t\t\t\toutcnt = outoff = 0;\n\t\t\t}\n\t\t}\n\t\treturn n;\n\t}\n\n\t/* ==========================================================================\n\t * Allocate the match buffer, initialize the various tables and save the\n\t * location of the internal file attribute (ascii/binary) and method\n\t * (DEFLATE/STORE).\n\t */\n\tfunction ct_init() {\n\t\tvar n; // iterates over tree elements\n\t\tvar bits; // bit counter\n\t\tvar length; // length value\n\t\tvar code; // code value\n\t\tvar dist; // distance index\n\n\t\tif (static_dtree[0].dl !== 0) {\n\t\t\treturn; // ct_init already called\n\t\t}\n\n\t\tl_desc.dyn_tree = dyn_ltree;\n\t\tl_desc.static_tree = static_ltree;\n\t\tl_desc.extra_bits = extra_lbits;\n\t\tl_desc.extra_base = LITERALS + 1;\n\t\tl_desc.elems = L_CODES;\n\t\tl_desc.max_length = MAX_BITS;\n\t\tl_desc.max_code = 0;\n\n\t\td_desc.dyn_tree = dyn_dtree;\n\t\td_desc.static_tree = static_dtree;\n\t\td_desc.extra_bits = extra_dbits;\n\t\td_desc.extra_base = 0;\n\t\td_desc.elems = D_CODES;\n\t\td_desc.max_length = MAX_BITS;\n\t\td_desc.max_code = 0;\n\n\t\tbl_desc.dyn_tree = bl_tree;\n\t\tbl_desc.static_tree = null;\n\t\tbl_desc.extra_bits = extra_blbits;\n\t\tbl_desc.extra_base = 0;\n\t\tbl_desc.elems = BL_CODES;\n\t\tbl_desc.max_length = MAX_BL_BITS;\n\t\tbl_desc.max_code = 0;\n\n\t // Initialize the mapping length (0..255) -> length code (0..28)\n\t\tlength = 0;\n\t\tfor (code = 0; code < LENGTH_CODES - 1; code++) {\n\t\t\tbase_length[code] = length;\n\t\t\tfor (n = 0; n < (1 << extra_lbits[code]); n++) {\n\t\t\t\tlength_code[length++] = code;\n\t\t\t}\n\t\t}\n\t // Assert (length === 256, \"ct_init: length !== 256\");\n\n\t\t// Note that the length 255 (match length 258) can be represented\n\t\t// in two different ways: code 284 + 5 bits or code 285, so we\n\t\t// overwrite length_code[255] to use the best encoding:\n\t\tlength_code[length - 1] = code;\n\n\t\t// Initialize the mapping dist (0..32K) -> dist code (0..29) */\n\t\tdist = 0;\n\t\tfor (code = 0; code < 16; code++) {\n\t\t\tbase_dist[code] = dist;\n\t\t\tfor (n = 0; n < (1 << extra_dbits[code]); n++) {\n\t\t\t\tdist_code[dist++] = code;\n\t\t\t}\n\t\t}\n\t\t// Assert (dist === 256, \"ct_init: dist !== 256\");\n\t\t// from now on, all distances are divided by 128\n\t\tfor (dist >>= 7; code < D_CODES; code++) {\n\t\t\tbase_dist[code] = dist << 7;\n\t\t\tfor (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {\n\t\t\t\tdist_code[256 + dist++] = code;\n\t\t\t}\n\t\t}\n\t\t// Assert (dist === 256, \"ct_init: 256+dist !== 512\");\n\n\t\t// Construct the codes of the static literal tree\n\t\tfor (bits = 0; bits <= MAX_BITS; bits++) {\n\t\t\tbl_count[bits] = 0;\n\t\t}\n\t\tn = 0;\n\t\twhile (n <= 143) {\n\t\t\tstatic_ltree[n++].dl = 8;\n\t\t\tbl_count[8]++;\n\t\t}\n\t\twhile (n <= 255) {\n\t\t\tstatic_ltree[n++].dl = 9;\n\t\t\tbl_count[9]++;\n\t\t}\n\t\twhile (n <= 279) {\n\t\t\tstatic_ltree[n++].dl = 7;\n\t\t\tbl_count[7]++;\n\t\t}\n\t\twhile (n <= 287) {\n\t\t\tstatic_ltree[n++].dl = 8;\n\t\t\tbl_count[8]++;\n\t\t}\n\t\t// Codes 286 and 287 do not exist, but we must include them in the\n\t\t// tree construction to get a canonical Huffman tree (longest code\n\t\t// all ones)\n\t\tgen_codes(static_ltree, L_CODES + 1);\n\n\t\t// The static distance tree is trivial: */\n\t\tfor (n = 0; n < D_CODES; n++) {\n\t\t\tstatic_dtree[n].dl = 5;\n\t\t\tstatic_dtree[n].fc = bi_reverse(n, 5);\n\t\t}\n\n\t\t// Initialize the first block of the first file:\n\t\tinit_block();\n\t}\n\n\t/* ==========================================================================\n\t * Initialize a new block.\n\t */\n\tfunction init_block() {\n\t\tvar n; // iterates over tree elements\n\n\t\t// Initialize the trees.\n\t\tfor (n = 0; n < L_CODES;  n++) {\n\t\t\tdyn_ltree[n].fc = 0;\n\t\t}\n\t\tfor (n = 0; n < D_CODES;  n++) {\n\t\t\tdyn_dtree[n].fc = 0;\n\t\t}\n\t\tfor (n = 0; n < BL_CODES; n++) {\n\t\t\tbl_tree[n].fc = 0;\n\t\t}\n\n\t\tdyn_ltree[END_BLOCK].fc = 1;\n\t\topt_len = static_len = 0;\n\t\tlast_lit = last_dist = last_flags = 0;\n\t\tflags = 0;\n\t\tflag_bit = 1;\n\t}\n\n\t/* ==========================================================================\n\t * Restore the heap property by moving down the tree starting at node k,\n\t * exchanging a node with the smallest of its two sons if necessary, stopping\n\t * when the heap property is re-established (each father smaller than its\n\t * two sons).\n\t *\n\t * @param tree- tree to restore\n\t * @param k- node to move down\n\t */\n\tfunction pqdownheap(tree, k) {\n\t\tvar v = heap[k],\n\t\t\tj = k << 1; // left son of k\n\n\t\twhile (j <= heap_len) {\n\t\t\t// Set j to the smallest of the two sons:\n\t\t\tif (j < heap_len && SMALLER(tree, heap[j + 1], heap[j])) {\n\t\t\t\tj++;\n\t\t\t}\n\n\t\t\t// Exit if v is smaller than both sons\n\t\t\tif (SMALLER(tree, v, heap[j])) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Exchange v with the smallest son\n\t\t\theap[k] = heap[j];\n\t\t\tk = j;\n\n\t\t\t// And continue down the tree, setting j to the left son of k\n\t\t\tj <<= 1;\n\t\t}\n\t\theap[k] = v;\n\t}\n\n\t/* ==========================================================================\n\t * Compute the optimal bit lengths for a tree and update the total bit length\n\t * for the current block.\n\t * IN assertion: the fields freq and dad are set, heap[heap_max] and\n\t *    above are the tree nodes sorted by increasing frequency.\n\t * OUT assertions: the field len is set to the optimal bit length, the\n\t *     array bl_count contains the frequencies for each bit length.\n\t *     The length opt_len is updated; static_len is also updated if stree is\n\t *     not null.\n\t */\n\tfunction gen_bitlen(desc) { // the tree descriptor\n\t\tvar tree = desc.dyn_tree;\n\t\tvar extra = desc.extra_bits;\n\t\tvar base = desc.extra_base;\n\t\tvar max_code = desc.max_code;\n\t\tvar max_length = desc.max_length;\n\t\tvar stree = desc.static_tree;\n\t\tvar h; // heap index\n\t\tvar n, m; // iterate over the tree elements\n\t\tvar bits; // bit length\n\t\tvar xbits; // extra bits\n\t\tvar f; // frequency\n\t\tvar overflow = 0; // number of elements with bit length too large\n\n\t\tfor (bits = 0; bits <= MAX_BITS; bits++) {\n\t\t\tbl_count[bits] = 0;\n\t\t}\n\n\t\t// In a first pass, compute the optimal bit lengths (which may\n\t\t// overflow in the case of the bit length tree).\n\t\ttree[heap[heap_max]].dl = 0; // root of the heap\n\n\t\tfor (h = heap_max + 1; h < HEAP_SIZE; h++) {\n\t\t\tn = heap[h];\n\t\t\tbits = tree[tree[n].dl].dl + 1;\n\t\t\tif (bits > max_length) {\n\t\t\t\tbits = max_length;\n\t\t\t\toverflow++;\n\t\t\t}\n\t\t\ttree[n].dl = bits;\n\t\t\t// We overwrite tree[n].dl which is no longer needed\n\n\t\t\tif (n > max_code) {\n\t\t\t\tcontinue; // not a leaf node\n\t\t\t}\n\n\t\t\tbl_count[bits]++;\n\t\t\txbits = 0;\n\t\t\tif (n >= base) {\n\t\t\t\txbits = extra[n - base];\n\t\t\t}\n\t\t\tf = tree[n].fc;\n\t\t\topt_len += f * (bits + xbits);\n\t\t\tif (stree !== null) {\n\t\t\t\tstatic_len += f * (stree[n].dl + xbits);\n\t\t\t}\n\t\t}\n\t\tif (overflow === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t// This happens for example on obj2 and pic of the Calgary corpus\n\n\t\t// Find the first bit length which could increase:\n\t\tdo {\n\t\t\tbits = max_length - 1;\n\t\t\twhile (bl_count[bits] === 0) {\n\t\t\t\tbits--;\n\t\t\t}\n\t\t\tbl_count[bits]--; // move one leaf down the tree\n\t\t\tbl_count[bits + 1] += 2; // move one overflow item as its brother\n\t\t\tbl_count[max_length]--;\n\t\t\t// The brother of the overflow item also moves one step up,\n\t\t\t// but this does not affect bl_count[max_length]\n\t\t\toverflow -= 2;\n\t\t} while (overflow > 0);\n\n\t\t// Now recompute all bit lengths, scanning in increasing frequency.\n\t\t// h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n\t\t// lengths instead of fixing only the wrong ones. This idea is taken\n\t\t// from 'ar' written by Haruhiko Okumura.)\n\t\tfor (bits = max_length; bits !== 0; bits--) {\n\t\t\tn = bl_count[bits];\n\t\t\twhile (n !== 0) {\n\t\t\t\tm = heap[--h];\n\t\t\t\tif (m > max_code) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (tree[m].dl !== bits) {\n\t\t\t\t\topt_len += (bits - tree[m].dl) * tree[m].fc;\n\t\t\t\t\ttree[m].fc = bits;\n\t\t\t\t}\n\t\t\t\tn--;\n\t\t\t}\n\t\t}\n\t}\n\n\t  /* ==========================================================================\n\t   * Generate the codes for a given tree and bit counts (which need not be\n\t   * optimal).\n\t   * IN assertion: the array bl_count contains the bit length statistics for\n\t   * the given tree and the field len is set for all tree elements.\n\t   * OUT assertion: the field code is set for all tree elements of non\n\t   *     zero code length.\n\t   * @param tree- the tree to decorate\n\t   * @param max_code- largest code with non-zero frequency\n\t   */\n\tfunction gen_codes(tree, max_code) {\n\t\tvar next_code = []; // new Array(MAX_BITS + 1); // next code value for each bit length\n\t\tvar code = 0; // running code value\n\t\tvar bits; // bit index\n\t\tvar n; // code index\n\n\t\t// The distribution counts are first used to generate the code values\n\t\t// without bit reversal.\n\t\tfor (bits = 1; bits <= MAX_BITS; bits++) {\n\t\t\tcode = ((code + bl_count[bits - 1]) << 1);\n\t\t\tnext_code[bits] = code;\n\t\t}\n\n\t\t// Check that the bit counts in bl_count are consistent. The last code\n\t\t// must be all ones.\n\t\t// Assert (code + encoder->bl_count[MAX_BITS]-1 === (1<<MAX_BITS)-1, \"inconsistent bit counts\");\n\t\t// Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n\n\t\tfor (n = 0; n <= max_code; n++) {\n\t\t\tvar len = tree[n].dl;\n\t\t\tif (len === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// Now reverse the bits\n\t\t\ttree[n].fc = bi_reverse(next_code[len]++, len);\n\n\t\t\t// Tracec(tree !== static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \", n, (isgraph(n) ? n : ' '), len, tree[n].fc, next_code[len]-1));\n\t\t}\n\t}\n\n\t/* ==========================================================================\n\t * Construct one Huffman tree and assigns the code bit strings and lengths.\n\t * Update the total bit length for the current block.\n\t * IN assertion: the field freq is set for all tree elements.\n\t * OUT assertions: the fields len and code are set to the optimal bit length\n\t *     and corresponding code. The length opt_len is updated; static_len is\n\t *     also updated if stree is not null. The field max_code is set.\n\t */\n\tfunction build_tree(desc) { // the tree descriptor\n\t\tvar tree = desc.dyn_tree;\n\t\tvar stree = desc.static_tree;\n\t\tvar elems = desc.elems;\n\t\tvar n, m; // iterate over heap elements\n\t\tvar max_code = -1; // largest code with non zero frequency\n\t\tvar node = elems; // next internal node of the tree\n\n\t\t// Construct the initial heap, with least frequent element in\n\t\t// heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n\t\t// heap[0] is not used.\n\t\theap_len = 0;\n\t\theap_max = HEAP_SIZE;\n\n\t\tfor (n = 0; n < elems; n++) {\n\t\t\tif (tree[n].fc !== 0) {\n\t\t\t\theap[++heap_len] = max_code = n;\n\t\t\t\tdepth[n] = 0;\n\t\t\t} else {\n\t\t\t\ttree[n].dl = 0;\n\t\t\t}\n\t\t}\n\n\t\t// The pkzip format requires that at least one distance code exists,\n\t\t// and that at least one bit should be sent even if there is only one\n\t\t// possible code. So to avoid special checks later on we force at least\n\t\t// two codes of non zero frequency.\n\t\twhile (heap_len < 2) {\n\t\t\tvar xnew = heap[++heap_len] = (max_code < 2 ? ++max_code : 0);\n\t\t\ttree[xnew].fc = 1;\n\t\t\tdepth[xnew] = 0;\n\t\t\topt_len--;\n\t\t\tif (stree !== null) {\n\t\t\t\tstatic_len -= stree[xnew].dl;\n\t\t\t}\n\t\t\t// new is 0 or 1 so it does not have extra bits\n\t\t}\n\t\tdesc.max_code = max_code;\n\n\t\t// The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n\t\t// establish sub-heaps of increasing lengths:\n\t\tfor (n = heap_len >> 1; n >= 1; n--) {\n\t\t\tpqdownheap(tree, n);\n\t\t}\n\n\t\t// Construct the Huffman tree by repeatedly combining the least two\n\t\t// frequent nodes.\n\t\tdo {\n\t\t\tn = heap[SMALLEST];\n\t\t\theap[SMALLEST] = heap[heap_len--];\n\t\t\tpqdownheap(tree, SMALLEST);\n\n\t\t\tm = heap[SMALLEST]; // m = node of next least frequency\n\n\t\t\t// keep the nodes sorted by frequency\n\t\t\theap[--heap_max] = n;\n\t\t\theap[--heap_max] = m;\n\n\t\t\t// Create a new node father of n and m\n\t\t\ttree[node].fc = tree[n].fc + tree[m].fc;\n\t\t\t//\tdepth[node] = (char)(MAX(depth[n], depth[m]) + 1);\n\t\t\tif (depth[n] > depth[m] + 1) {\n\t\t\t\tdepth[node] = depth[n];\n\t\t\t} else {\n\t\t\t\tdepth[node] = depth[m] + 1;\n\t\t\t}\n\t\t\ttree[n].dl = tree[m].dl = node;\n\n\t\t\t// and insert the new node in the heap\n\t\t\theap[SMALLEST] = node++;\n\t\t\tpqdownheap(tree, SMALLEST);\n\n\t\t} while (heap_len >= 2);\n\n\t\theap[--heap_max] = heap[SMALLEST];\n\n\t\t// At this point, the fields freq and dad are set. We can now\n\t\t// generate the bit lengths.\n\t\tgen_bitlen(desc);\n\n\t\t// The field len is now set, we can generate the bit codes\n\t\tgen_codes(tree, max_code);\n\t}\n\n\t/* ==========================================================================\n\t * Scan a literal or distance tree to determine the frequencies of the codes\n\t * in the bit length tree. Updates opt_len to take into account the repeat\n\t * counts. (The contribution of the bit length codes will be added later\n\t * during the construction of bl_tree.)\n\t *\n\t * @param tree- the tree to be scanned\n\t * @param max_code- and its largest code of non zero frequency\n\t */\n\tfunction scan_tree(tree, max_code) {\n\t\tvar n, // iterates over all tree elements\n\t\t\tprevlen = -1, // last emitted length\n\t\t\tcurlen, // length of current code\n\t\t\tnextlen = tree[0].dl, // length of next code\n\t\t\tcount = 0, // repeat count of the current code\n\t\t\tmax_count = 7, // max repeat count\n\t\t\tmin_count = 4; // min repeat count\n\n\t\tif (nextlen === 0) {\n\t\t\tmax_count = 138;\n\t\t\tmin_count = 3;\n\t\t}\n\t\ttree[max_code + 1].dl = 0xffff; // guard\n\n\t\tfor (n = 0; n <= max_code; n++) {\n\t\t\tcurlen = nextlen;\n\t\t\tnextlen = tree[n + 1].dl;\n\t\t\tif (++count < max_count && curlen === nextlen) {\n\t\t\t\tcontinue;\n\t\t\t} else if (count < min_count) {\n\t\t\t\tbl_tree[curlen].fc += count;\n\t\t\t} else if (curlen !== 0) {\n\t\t\t\tif (curlen !== prevlen) {\n\t\t\t\t\tbl_tree[curlen].fc++;\n\t\t\t\t}\n\t\t\t\tbl_tree[REP_3_6].fc++;\n\t\t\t} else if (count <= 10) {\n\t\t\t\tbl_tree[REPZ_3_10].fc++;\n\t\t\t} else {\n\t\t\t\tbl_tree[REPZ_11_138].fc++;\n\t\t\t}\n\t\t\tcount = 0; prevlen = curlen;\n\t\t\tif (nextlen === 0) {\n\t\t\t\tmax_count = 138;\n\t\t\t\tmin_count = 3;\n\t\t\t} else if (curlen === nextlen) {\n\t\t\t\tmax_count = 6;\n\t\t\t\tmin_count = 3;\n\t\t\t} else {\n\t\t\t\tmax_count = 7;\n\t\t\t\tmin_count = 4;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* ==========================================================================\n\t * Send a literal or distance tree in compressed form, using the codes in\n\t * bl_tree.\n\t *\n\t * @param tree- the tree to be scanned\n\t * @param max_code- and its largest code of non zero frequency\n\t */\n\tfunction send_tree(tree, max_code) {\n\t\tvar n; // iterates over all tree elements\n\t\tvar prevlen = -1; // last emitted length\n\t\tvar curlen; // length of current code\n\t\tvar nextlen = tree[0].dl; // length of next code\n\t\tvar count = 0; // repeat count of the current code\n\t\tvar max_count = 7; // max repeat count\n\t\tvar min_count = 4; // min repeat count\n\n\t\t// tree[max_code+1].dl = -1; */  /* guard already set */\n\t\tif (nextlen === 0) {\n\t\t\tmax_count = 138;\n\t\t\tmin_count = 3;\n\t\t}\n\n\t\tfor (n = 0; n <= max_code; n++) {\n\t\t\tcurlen = nextlen;\n\t\t\tnextlen = tree[n + 1].dl;\n\t\t\tif (++count < max_count && curlen === nextlen) {\n\t\t\t\tcontinue;\n\t\t\t} else if (count < min_count) {\n\t\t\t\tdo {\n\t\t\t\t\tSEND_CODE(curlen, bl_tree);\n\t\t\t\t} while (--count !== 0);\n\t\t\t} else if (curlen !== 0) {\n\t\t\t\tif (curlen !== prevlen) {\n\t\t\t\t\tSEND_CODE(curlen, bl_tree);\n\t\t\t\t\tcount--;\n\t\t\t\t}\n\t\t\t// Assert(count >= 3 && count <= 6, \" 3_6?\");\n\t\t\t\tSEND_CODE(REP_3_6, bl_tree);\n\t\t\t\tsend_bits(count - 3, 2);\n\t\t\t} else if (count <= 10) {\n\t\t\t\tSEND_CODE(REPZ_3_10, bl_tree);\n\t\t\t\tsend_bits(count - 3, 3);\n\t\t\t} else {\n\t\t\t\tSEND_CODE(REPZ_11_138, bl_tree);\n\t\t\t\tsend_bits(count - 11, 7);\n\t\t\t}\n\t\t\tcount = 0;\n\t\t\tprevlen = curlen;\n\t\t\tif (nextlen === 0) {\n\t\t\t\tmax_count = 138;\n\t\t\t\tmin_count = 3;\n\t\t\t} else if (curlen === nextlen) {\n\t\t\t\tmax_count = 6;\n\t\t\t\tmin_count = 3;\n\t\t\t} else {\n\t\t\t\tmax_count = 7;\n\t\t\t\tmin_count = 4;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* ==========================================================================\n\t * Construct the Huffman tree for the bit lengths and return the index in\n\t * bl_order of the last bit length code to send.\n\t */\n\tfunction build_bl_tree() {\n\t\tvar max_blindex; // index of last bit length code of non zero freq\n\n\t\t// Determine the bit length frequencies for literal and distance trees\n\t\tscan_tree(dyn_ltree, l_desc.max_code);\n\t\tscan_tree(dyn_dtree, d_desc.max_code);\n\n\t\t// Build the bit length tree:\n\t\tbuild_tree(bl_desc);\n\t\t// opt_len now includes the length of the tree representations, except\n\t\t// the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n\n\t\t// Determine the number of bit length codes to send. The pkzip format\n\t\t// requires that at least 4 bit length codes be sent. (appnote.txt says\n\t\t// 3 but the actual value used is 4.)\n\t\tfor (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {\n\t\t\tif (bl_tree[bl_order[max_blindex]].dl !== 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// Update opt_len to include the bit length tree and counts */\n\t\topt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\n\t\t// Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n\t\t// encoder->opt_len, encoder->static_len));\n\n\t\treturn max_blindex;\n\t}\n\n\t/* ==========================================================================\n\t * Send the header for a block using dynamic Huffman trees: the counts, the\n\t * lengths of the bit length codes, the literal tree and the distance tree.\n\t * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n\t */\n\tfunction send_all_trees(lcodes, dcodes, blcodes) { // number of codes for each tree\n\t\tvar rank; // index in bl_order\n\n\t\t// Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n\t\t// Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES, \"too many codes\");\n\t\t// Tracev((stderr, \"\\nbl counts: \"));\n\t\tsend_bits(lcodes - 257, 5); // not +255 as stated in appnote.txt\n\t\tsend_bits(dcodes - 1,   5);\n\t\tsend_bits(blcodes - 4,  4); // not -3 as stated in appnote.txt\n\t\tfor (rank = 0; rank < blcodes; rank++) {\n\t\t\t// Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n\t\t\tsend_bits(bl_tree[bl_order[rank]].dl, 3);\n\t\t}\n\n\t\t// send the literal tree\n\t\tsend_tree(dyn_ltree, lcodes - 1);\n\n\t\t// send the distance tree\n\t\tsend_tree(dyn_dtree, dcodes - 1);\n\t}\n\n\t/* ==========================================================================\n\t * Determine the best encoding for the current block: dynamic trees, static\n\t * trees or store, and output the encoded block to the zip file.\n\t */\n\tfunction flush_block(eof) { // true if this is the last block for a file\n\t\tvar opt_lenb, static_lenb, // opt_len and static_len in bytes\n\t\t\tmax_blindex, // index of last bit length code of non zero freq\n\t\t\tstored_len, // length of input block\n\t\t\ti;\n\n\t\tstored_len = strstart - block_start;\n\t\tflag_buf[last_flags] = flags; // Save the flags for the last 8 items\n\n\t\t// Construct the literal and distance trees\n\t\tbuild_tree(l_desc);\n\t\t// Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\",\n\t\t// encoder->opt_len, encoder->static_len));\n\n\t\tbuild_tree(d_desc);\n\t\t// Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\",\n\t\t// encoder->opt_len, encoder->static_len));\n\t\t// At this point, opt_len and static_len are the total bit lengths of\n\t\t// the compressed block data, excluding the tree representations.\n\n\t\t// Build the bit length tree for the above two trees, and get the index\n\t\t// in bl_order of the last bit length code to send.\n\t\tmax_blindex = build_bl_tree();\n\n\t // Determine the best encoding. Compute first the block length in bytes\n\t\topt_lenb = (opt_len + 3 + 7) >> 3;\n\t\tstatic_lenb = (static_len + 3 + 7) >> 3;\n\n\t//  Trace((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u dist %u \", opt_lenb, encoder->opt_len, static_lenb, encoder->static_len, stored_len, encoder->last_lit, encoder->last_dist));\n\n\t\tif (static_lenb <= opt_lenb) {\n\t\t\topt_lenb = static_lenb;\n\t\t}\n\t\tif (stored_len + 4 <= opt_lenb && block_start >= 0) { // 4: two words for the lengths\n\t\t\t// The test buf !== NULL is only necessary if LIT_BUFSIZE > WSIZE.\n\t\t\t// Otherwise we can't have processed more than WSIZE input bytes since\n\t\t\t// the last block flush, because compression would have been\n\t\t\t// successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n\t\t\t// transform a block into a stored block.\n\t\t\tsend_bits((STORED_BLOCK << 1) + eof, 3);  /* send block type */\n\t\t\tbi_windup();         /* align on byte boundary */\n\t\t\tput_short(stored_len);\n\t\t\tput_short(~stored_len);\n\n\t\t\t// copy block\n\t\t\t/*\n\t\t\t\tp = &window[block_start];\n\t\t\t\tfor (i = 0; i < stored_len; i++) {\n\t\t\t\t\tput_byte(p[i]);\n\t\t\t\t}\n\t\t\t*/\n\t\t\tfor (i = 0; i < stored_len; i++) {\n\t\t\t\tput_byte(window[block_start + i]);\n\t\t\t}\n\t\t} else if (static_lenb === opt_lenb) {\n\t\t\tsend_bits((STATIC_TREES << 1) + eof, 3);\n\t\t\tcompress_block(static_ltree, static_dtree);\n\t\t} else {\n\t\t\tsend_bits((DYN_TREES << 1) + eof, 3);\n\t\t\tsend_all_trees(l_desc.max_code + 1, d_desc.max_code + 1, max_blindex + 1);\n\t\t\tcompress_block(dyn_ltree, dyn_dtree);\n\t\t}\n\n\t\tinit_block();\n\n\t\tif (eof !== 0) {\n\t\t\tbi_windup();\n\t\t}\n\t}\n\n\t/* ==========================================================================\n\t * Save the match info and tally the frequency counts. Return true if\n\t * the current block must be flushed.\n\t *\n\t * @param dist- distance of matched string\n\t * @param lc- (match length - MIN_MATCH) or unmatched char (if dist === 0)\n\t */\n\tfunction ct_tally(dist, lc) {\n\t\tl_buf[last_lit++] = lc;\n\t\tif (dist === 0) {\n\t\t\t// lc is the unmatched char\n\t\t\tdyn_ltree[lc].fc++;\n\t\t} else {\n\t\t\t// Here, lc is the match length - MIN_MATCH\n\t\t\tdist--; // dist = match distance - 1\n\t\t\t// Assert((ush)dist < (ush)MAX_DIST && (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) && (ush)D_CODE(dist) < (ush)D_CODES,  \"ct_tally: bad match\");\n\n\t\t\tdyn_ltree[length_code[lc] + LITERALS + 1].fc++;\n\t\t\tdyn_dtree[D_CODE(dist)].fc++;\n\n\t\t\td_buf[last_dist++] = dist;\n\t\t\tflags |= flag_bit;\n\t\t}\n\t\tflag_bit <<= 1;\n\n\t\t// Output the flags if they fill a byte\n\t\tif ((last_lit & 7) === 0) {\n\t\t\tflag_buf[last_flags++] = flags;\n\t\t\tflags = 0;\n\t\t\tflag_bit = 1;\n\t\t}\n\t\t// Try to guess if it is profitable to stop the current block here\n\t\tif (compr_level > 2 && (last_lit & 0xfff) === 0) {\n\t\t\t// Compute an upper bound for the compressed length\n\t\t\tvar out_length = last_lit * 8;\n\t\t\tvar in_length = strstart - block_start;\n\t\t\tvar dcode;\n\n\t\t\tfor (dcode = 0; dcode < D_CODES; dcode++) {\n\t\t\t\tout_length += dyn_dtree[dcode].fc * (5 + extra_dbits[dcode]);\n\t\t\t}\n\t\t\tout_length >>= 3;\n\t\t\t// Trace((stderr,\"\\nlast_lit %u, last_dist %u, in %ld, out ~%ld(%ld%%) \", encoder->last_lit, encoder->last_dist, in_length, out_length, 100L - out_length*100L/in_length));\n\t\t\tif (last_dist < parseInt(last_lit / 2, 10) && out_length < parseInt(in_length / 2, 10)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn (last_lit === LIT_BUFSIZE - 1 || last_dist === DIST_BUFSIZE);\n\t\t// We avoid equality with LIT_BUFSIZE because of wraparound at 64K\n\t\t// on 16 bit machines and because stored blocks are restricted to\n\t\t// 64K-1 bytes.\n\t}\n\n\t  /* ==========================================================================\n\t   * Send the block data compressed using the given Huffman trees\n\t   *\n\t   * @param ltree- literal tree\n\t   * @param dtree- distance tree\n\t   */\n\tfunction compress_block(ltree, dtree) {\n\t\tvar dist; // distance of matched string\n\t\tvar lc; // match length or unmatched char (if dist === 0)\n\t\tvar lx = 0; // running index in l_buf\n\t\tvar dx = 0; // running index in d_buf\n\t\tvar fx = 0; // running index in flag_buf\n\t\tvar flag = 0; // current flags\n\t\tvar code; // the code to send\n\t\tvar extra; // number of extra bits to send\n\n\t\tif (last_lit !== 0) {\n\t\t\tdo {\n\t\t\t\tif ((lx & 7) === 0) {\n\t\t\t\t\tflag = flag_buf[fx++];\n\t\t\t\t}\n\t\t\t\tlc = l_buf[lx++] & 0xff;\n\t\t\t\tif ((flag & 1) === 0) {\n\t\t\t\t\tSEND_CODE(lc, ltree); /* send a literal byte */\n\t\t\t\t\t//\tTracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n\t\t\t\t} else {\n\t\t\t\t\t// Here, lc is the match length - MIN_MATCH\n\t\t\t\t\tcode = length_code[lc];\n\t\t\t\t\tSEND_CODE(code + LITERALS + 1, ltree); // send the length code\n\t\t\t\t\textra = extra_lbits[code];\n\t\t\t\t\tif (extra !== 0) {\n\t\t\t\t\t\tlc -= base_length[code];\n\t\t\t\t\t\tsend_bits(lc, extra); // send the extra length bits\n\t\t\t\t\t}\n\t\t\t\t\tdist = d_buf[dx++];\n\t\t\t\t\t// Here, dist is the match distance - 1\n\t\t\t\t\tcode = D_CODE(dist);\n\t\t\t\t\t//\tAssert (code < D_CODES, \"bad d_code\");\n\n\t\t\t\t\tSEND_CODE(code, dtree); // send the distance code\n\t\t\t\t\textra = extra_dbits[code];\n\t\t\t\t\tif (extra !== 0) {\n\t\t\t\t\t\tdist -= base_dist[code];\n\t\t\t\t\t\tsend_bits(dist, extra); // send the extra distance bits\n\t\t\t\t\t}\n\t\t\t\t} // literal or match pair ?\n\t\t\t\tflag >>= 1;\n\t\t\t} while (lx < last_lit);\n\t\t}\n\n\t\tSEND_CODE(END_BLOCK, ltree);\n\t}\n\n\t/* ==========================================================================\n\t * Send a value on a given number of bits.\n\t * IN assertion: length <= 16 and value fits in length bits.\n\t *\n\t * @param value- value to send\n\t * @param length- number of bits\n\t */\n\tvar Buf_size = 16; // bit size of bi_buf\n\tfunction send_bits(value, length) {\n\t\t// If not enough room in bi_buf, use (valid) bits from bi_buf and\n\t\t// (16 - bi_valid) bits from value, leaving (width - (16-bi_valid))\n\t\t// unused bits in value.\n\t\tif (bi_valid > Buf_size - length) {\n\t\t\tbi_buf |= (value << bi_valid);\n\t\t\tput_short(bi_buf);\n\t\t\tbi_buf = (value >> (Buf_size - bi_valid));\n\t\t\tbi_valid += length - Buf_size;\n\t\t} else {\n\t\t\tbi_buf |= value << bi_valid;\n\t\t\tbi_valid += length;\n\t\t}\n\t}\n\n\t/* ==========================================================================\n\t * Reverse the first len bits of a code, using straightforward code (a faster\n\t * method would use a table)\n\t * IN assertion: 1 <= len <= 15\n\t *\n\t * @param code- the value to invert\n\t * @param len- its bit length\n\t */\n\tfunction bi_reverse(code, len) {\n\t\tvar res = 0;\n\t\tdo {\n\t\t\tres |= code & 1;\n\t\t\tcode >>= 1;\n\t\t\tres <<= 1;\n\t\t} while (--len > 0);\n\t\treturn res >> 1;\n\t}\n\n\t/* ==========================================================================\n\t * Write out any remaining bits in an incomplete byte.\n\t */\n\tfunction bi_windup() {\n\t\tif (bi_valid > 8) {\n\t\t\tput_short(bi_buf);\n\t\t} else if (bi_valid > 0) {\n\t\t\tput_byte(bi_buf);\n\t\t}\n\t\tbi_buf = 0;\n\t\tbi_valid = 0;\n\t}\n\n\tfunction qoutbuf() {\n\t\tvar q, i;\n\t\tif (outcnt !== 0) {\n\t\t\tq = new_queue();\n\t\t\tif (qhead === null) {\n\t\t\t\tqhead = qtail = q;\n\t\t\t} else {\n\t\t\t\tqtail = qtail.next = q;\n\t\t\t}\n\t\t\tq.len = outcnt - outoff;\n\t\t\t// System.arraycopy(outbuf, outoff, q.ptr, 0, q.len);\n\t\t\tfor (i = 0; i < q.len; i++) {\n\t\t\t\tq.ptr[i] = outbuf[outoff + i];\n\t\t\t}\n\t\t\toutcnt = outoff = 0;\n\t\t}\n\t}\n\n\tfunction deflate(arr, level) {\n\t\tvar i, j, buff;\n\n\t\tdeflate_data = arr;\n\t\tdeflate_pos = 0;\n\t\tif (typeof level === \"undefined\") {\n\t\t\tlevel = DEFAULT_LEVEL;\n\t\t}\n\t\tdeflate_start(level);\n\n\t\tbuff = [];\n\n\t\tdo {\n\t\t\ti = deflate_internal(buff, buff.length, 1024);\n\t\t} while (i > 0);\n\n\t\tdeflate_data = null; // G.C.\n\t\treturn buff;\n\t}\n\n\tmodule.exports = deflate;\n\tmodule.exports.DEFAULT_LEVEL = DEFAULT_LEVEL;\n}());\n","/*\n * $Id: rawinflate.js,v 0.2 2009/03/01 18:32:24 dankogai Exp $\n *\n * original:\n * http://www.onicos.com/staff/iz/amuse/javascript/expert/inflate.txt\n */\n\n/* Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>\n * Version: 1.0.0.1\n * LastModified: Dec 25 1999\n */\n\n/* Interface:\n * data = inflate(src);\n */\n\n(function () {\n\t/* constant parameters */\n\tvar WSIZE = 32768, // Sliding Window size\n\t\tSTORED_BLOCK = 0,\n\t\tSTATIC_TREES = 1,\n\t\tDYN_TREES = 2,\n\n\t/* for inflate */\n\t\tlbits = 9, // bits in base literal/length lookup table\n\t\tdbits = 6, // bits in base distance lookup table\n\n\t/* variables (inflate) */\n\t\tslide,\n\t\twp, // current position in slide\n\t\tfixed_tl = null, // inflate static\n\t\tfixed_td, // inflate static\n\t\tfixed_bl, // inflate static\n\t\tfixed_bd, // inflate static\n\t\tbit_buf, // bit buffer\n\t\tbit_len, // bits in bit buffer\n\t\tmethod,\n\t\teof,\n\t\tcopy_leng,\n\t\tcopy_dist,\n\t\ttl, // literal length decoder table\n\t\ttd, // literal distance decoder table\n\t\tbl, // number of bits decoded by tl\n\t\tbd, // number of bits decoded by td\n\n\t\tinflate_data,\n\t\tinflate_pos,\n\n\n/* constant tables (inflate) */\n\t\tMASK_BITS = [\n\t\t\t0x0000,\n\t\t\t0x0001, 0x0003, 0x0007, 0x000f, 0x001f, 0x003f, 0x007f, 0x00ff,\n\t\t\t0x01ff, 0x03ff, 0x07ff, 0x0fff, 0x1fff, 0x3fff, 0x7fff, 0xffff\n\t\t],\n\t\t// Tables for deflate from PKZIP's appnote.txt.\n\t\t// Copy lengths for literal codes 257..285\n\t\tcplens = [\n\t\t\t3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n\t\t\t35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0\n\t\t],\n/* note: see note #13 above about the 258 in this list. */\n\t\t// Extra bits for literal codes 257..285\n\t\tcplext = [\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,\n\t\t\t3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99 // 99==invalid\n\t\t],\n\t\t// Copy offsets for distance codes 0..29\n\t\tcpdist = [\n\t\t\t1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n\t\t\t257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n\t\t\t8193, 12289, 16385, 24577\n\t\t],\n\t\t// Extra bits for distance codes\n\t\tcpdext = [\n\t\t\t0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,\n\t\t\t7, 7, 8, 8, 9, 9, 10, 10, 11, 11,\n\t\t\t12, 12, 13, 13\n\t\t],\n\t\t// Order of the bit length code lengths\n\t\tborder = [\n\t\t\t16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15\n\t\t];\n\t/* objects (inflate) */\n\n\tfunction HuftList() {\n\t\tthis.next = null;\n\t\tthis.list = null;\n\t}\n\n\tfunction HuftNode() {\n\t\tthis.e = 0; // number of extra bits or operation\n\t\tthis.b = 0; // number of bits in this code or subcode\n\n\t\t// union\n\t\tthis.n = 0; // literal, length base, or distance base\n\t\tthis.t = null; // (HuftNode) pointer to next level of table\n\t}\n\n\t/*\n\t * @param b-  code lengths in bits (all assumed <= BMAX)\n\t * @param n- number of codes (assumed <= N_MAX)\n\t * @param s- number of simple-valued codes (0..s-1)\n\t * @param d- list of base values for non-simple codes\n\t * @param e- list of extra bits for non-simple codes\n\t * @param mm- maximum lookup bits\n\t */\n\tfunction HuftBuild(b, n, s, d, e, mm) {\n\t\tthis.BMAX = 16; // maximum bit length of any code\n\t\tthis.N_MAX = 288; // maximum number of codes in any set\n\t\tthis.status = 0; // 0: success, 1: incomplete table, 2: bad input\n\t\tthis.root = null; // (HuftList) starting table\n\t\tthis.m = 0; // maximum lookup bits, returns actual\n\n\t/* Given a list of code lengths and a maximum table size, make a set of\n\t   tables to decode that set of codes. Return zero on success, one if\n\t   the given code set is incomplete (the tables are still built in this\n\t   case), two if the input is invalid (all zero length codes or an\n\t   oversubscribed set of lengths), and three if not enough memory.\n\t   The code with value 256 is special, and the tables are constructed\n\t   so that no bits beyond that code are fetched when that code is\n\t   decoded. */\n\t\tvar a; // counter for codes of length k\n\t\tvar c = [];\n\t\tvar el; // length of EOB code (value 256)\n\t\tvar f; // i repeats in table every f entries\n\t\tvar g; // maximum code length\n\t\tvar h; // table level\n\t\tvar i; // counter, current code\n\t\tvar j; // counter\n\t\tvar k; // number of bits in current code\n\t\tvar lx = [];\n\t\tvar p; // pointer into c[], b[], or v[]\n\t\tvar pidx; // index of p\n\t\tvar q; // (HuftNode) points to current table\n\t\tvar r = new HuftNode(); // table entry for structure assignment\n\t\tvar u = [];\n\t\tvar v = [];\n\t\tvar w;\n\t\tvar x = [];\n\t\tvar xp; // pointer into x or c\n\t\tvar y; // number of dummy codes added\n\t\tvar z; // number of entries in current table\n\t\tvar o;\n\t\tvar tail; // (HuftList)\n\n\t\ttail = this.root = null;\n\n\t\t// bit length count table\n\t\tfor (i = 0; i < this.BMAX + 1; i++) {\n\t\t\tc[i] = 0;\n\t\t}\n\t\t// stack of bits per table\n\t\tfor (i = 0; i < this.BMAX + 1; i++) {\n\t\t\tlx[i] = 0;\n\t\t}\n\t\t// HuftNode[BMAX][]  table stack\n\t\tfor (i = 0; i < this.BMAX; i++) {\n\t\t\tu[i] = null;\n\t\t}\n\t\t// values in order of bit length\n\t\tfor (i = 0; i < this.N_MAX; i++) {\n\t\t\tv[i] = 0;\n\t\t}\n\t\t// bit offsets, then code stack\n\t\tfor (i = 0; i < this.BMAX + 1; i++) {\n\t\t\tx[i] = 0;\n\t\t}\n\n\t\t// Generate counts for each bit length\n\t\tel = n > 256 ? b[256] : this.BMAX; // set length of EOB code, if any\n\t\tp = b; pidx = 0;\n\t\ti = n;\n\t\tdo {\n\t\t\tc[p[pidx]]++; // assume all entries <= BMAX\n\t\t\tpidx++;\n\t\t} while (--i > 0);\n\t\tif (c[0] === n) { // null input--all zero length codes\n\t\t\tthis.root = null;\n\t\t\tthis.m = 0;\n\t\t\tthis.status = 0;\n\t\t\treturn;\n\t\t}\n\n\t\t// Find minimum and maximum length, bound *m by those\n\t\tfor (j = 1; j <= this.BMAX; j++) {\n\t\t\tif (c[j] !== 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tk = j; // minimum code length\n\t\tif (mm < j) {\n\t\t\tmm = j;\n\t\t}\n\t\tfor (i = this.BMAX; i !== 0; i--) {\n\t\t\tif (c[i] !== 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tg = i; // maximum code length\n\t\tif (mm > i) {\n\t\t\tmm = i;\n\t\t}\n\n\t\t// Adjust last length count to fill out codes, if needed\n\t\tfor (y = 1 << j; j < i; j++, y <<= 1) {\n\t\t\tif ((y -= c[j]) < 0) {\n\t\t\t\tthis.status = 2; // bad input: more codes than bits\n\t\t\t\tthis.m = mm;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif ((y -= c[i]) < 0) {\n\t\t\tthis.status = 2;\n\t\t\tthis.m = mm;\n\t\t\treturn;\n\t\t}\n\t\tc[i] += y;\n\n\t\t// Generate starting offsets into the value table for each length\n\t\tx[1] = j = 0;\n\t\tp = c;\n\t\tpidx = 1;\n\t\txp = 2;\n\t\twhile (--i > 0) { // note that i == g from above\n\t\t\tx[xp++] = (j += p[pidx++]);\n\t\t}\n\n\t\t// Make a table of values in order of bit lengths\n\t\tp = b; pidx = 0;\n\t\ti = 0;\n\t\tdo {\n\t\t\tif ((j = p[pidx++]) !== 0) {\n\t\t\t\tv[x[j]++] = i;\n\t\t\t}\n\t\t} while (++i < n);\n\t\tn = x[g]; // set n to length of v\n\n\t\t// Generate the Huffman codes and for each, make the table entries\n\t\tx[0] = i = 0; // first Huffman code is zero\n\t\tp = v; pidx = 0; // grab values in bit order\n\t\th = -1; // no tables yet--level -1\n\t\tw = lx[0] = 0; // no bits decoded yet\n\t\tq = null; // ditto\n\t\tz = 0; // ditto\n\n\t\t// go through the bit lengths (k already is bits in shortest code)\n\t\tfor (null; k <= g; k++) {\n\t\t\ta = c[k];\n\t\t\twhile (a-- > 0) {\n\t\t\t\t// here i is the Huffman code of length k bits for value p[pidx]\n\t\t\t\t// make tables up to required level\n\t\t\t\twhile (k > w + lx[1 + h]) {\n\t\t\t\t\tw += lx[1 + h]; // add bits already decoded\n\t\t\t\t\th++;\n\n\t\t\t\t\t// compute minimum size table less than or equal to *m bits\n\t\t\t\t\tz = (z = g - w) > mm ? mm : z; // upper limit\n\t\t\t\t\tif ((f = 1 << (j = k - w)) > a + 1) { // try a k-w bit table\n\t\t\t\t\t\t// too few codes for k-w bit table\n\t\t\t\t\t\tf -= a + 1; // deduct codes from patterns left\n\t\t\t\t\t\txp = k;\n\t\t\t\t\t\twhile (++j < z) { // try smaller tables up to z bits\n\t\t\t\t\t\t\tif ((f <<= 1) <= c[++xp]) {\n\t\t\t\t\t\t\t\tbreak; // enough codes to use up j bits\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tf -= c[xp]; // else deduct codes from patterns\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (w + j > el && w < el) {\n\t\t\t\t\t\tj = el - w; // make EOB code end at table\n\t\t\t\t\t}\n\t\t\t\t\tz = 1 << j; // table entries for j-bit table\n\t\t\t\t\tlx[1 + h] = j; // set table size in stack\n\n\t\t\t\t\t// allocate and link in new table\n\t\t\t\t\tq = [];\n\t\t\t\t\tfor (o = 0; o < z; o++) {\n\t\t\t\t\t\tq[o] = new HuftNode();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!tail) {\n\t\t\t\t\t\ttail = this.root = new HuftList();\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttail = tail.next = new HuftList();\n\t\t\t\t\t}\n\t\t\t\t\ttail.next = null;\n\t\t\t\t\ttail.list = q;\n\t\t\t\t\tu[h] = q; // table starts after link\n\n\t\t\t\t\t/* connect to last table, if there is one */\n\t\t\t\t\tif (h > 0) {\n\t\t\t\t\t\tx[h] = i; // save pattern for backing up\n\t\t\t\t\t\tr.b = lx[h]; // bits to dump before this table\n\t\t\t\t\t\tr.e = 16 + j; // bits in this table\n\t\t\t\t\t\tr.t = q; // pointer to this table\n\t\t\t\t\t\tj = (i & ((1 << w) - 1)) >> (w - lx[h]);\n\t\t\t\t\t\tu[h - 1][j].e = r.e;\n\t\t\t\t\t\tu[h - 1][j].b = r.b;\n\t\t\t\t\t\tu[h - 1][j].n = r.n;\n\t\t\t\t\t\tu[h - 1][j].t = r.t;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// set up table entry in r\n\t\t\t\tr.b = k - w;\n\t\t\t\tif (pidx >= n) {\n\t\t\t\t\tr.e = 99; // out of values--invalid code\n\t\t\t\t} else if (p[pidx] < s) {\n\t\t\t\t\tr.e = (p[pidx] < 256 ? 16 : 15); // 256 is end-of-block code\n\t\t\t\t\tr.n = p[pidx++]; // simple code is just the value\n\t\t\t\t} else {\n\t\t\t\t\tr.e = e[p[pidx] - s]; // non-simple--look up in lists\n\t\t\t\t\tr.n = d[p[pidx++] - s];\n\t\t\t\t}\n\n\t\t\t\t// fill code-like entries with r //\n\t\t\t\tf = 1 << (k - w);\n\t\t\t\tfor (j = i >> w; j < z; j += f) {\n\t\t\t\t\tq[j].e = r.e;\n\t\t\t\t\tq[j].b = r.b;\n\t\t\t\t\tq[j].n = r.n;\n\t\t\t\t\tq[j].t = r.t;\n\t\t\t\t}\n\n\t\t\t\t// backwards increment the k-bit code i\n\t\t\t\tfor (j = 1 << (k - 1); (i & j) !== 0; j >>= 1) {\n\t\t\t\t\ti ^= j;\n\t\t\t\t}\n\t\t\t\ti ^= j;\n\n\t\t\t\t// backup over finished tables\n\t\t\t\twhile ((i & ((1 << w) - 1)) !== x[h]) {\n\t\t\t\t\tw -= lx[h]; // don't need to update q\n\t\t\t\t\th--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* return actual size of base table */\n\t\tthis.m = lx[1];\n\n\t\t/* Return true (1) if we were given an incomplete table */\n\t\tthis.status = ((y !== 0 && g !== 1) ? 1 : 0);\n\t}\n\n\n\t/* routines (inflate) */\n\n\tfunction GET_BYTE() {\n\t\tif (inflate_data.length === inflate_pos) {\n\t\t\treturn -1;\n\t\t}\n\t\treturn inflate_data[inflate_pos++] & 0xff;\n\t}\n\n\tfunction NEEDBITS(n) {\n\t\twhile (bit_len < n) {\n\t\t\tbit_buf |= GET_BYTE() << bit_len;\n\t\t\tbit_len += 8;\n\t\t}\n\t}\n\n\tfunction GETBITS(n) {\n\t\treturn bit_buf & MASK_BITS[n];\n\t}\n\n\tfunction DUMPBITS(n) {\n\t\tbit_buf >>= n;\n\t\tbit_len -= n;\n\t}\n\n\tfunction inflate_codes(buff, off, size) {\n\t\t// inflate (decompress) the codes in a deflated (compressed) block.\n\t\t// Return an error code or zero if it all goes ok.\n\t\tvar e; // table entry flag/number of extra bits\n\t\tvar t; // (HuftNode) pointer to table entry\n\t\tvar n;\n\n\t\tif (size === 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t// inflate the coded data\n\t\tn = 0;\n\t\tfor (;;) { // do until end of block\n\t\t\tNEEDBITS(bl);\n\t\t\tt = tl.list[GETBITS(bl)];\n\t\t\te = t.e;\n\t\t\twhile (e > 16) {\n\t\t\t\tif (e === 99) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tDUMPBITS(t.b);\n\t\t\t\te -= 16;\n\t\t\t\tNEEDBITS(e);\n\t\t\t\tt = t.t[GETBITS(e)];\n\t\t\t\te = t.e;\n\t\t\t}\n\t\t\tDUMPBITS(t.b);\n\n\t\t\tif (e === 16) { // then it's a literal\n\t\t\t\twp &= WSIZE - 1;\n\t\t\t\tbuff[off + n++] = slide[wp++] = t.n;\n\t\t\t\tif (n === size) {\n\t\t\t\t\treturn size;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// exit if end of block\n\t\t\tif (e === 15) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// it's an EOB or a length\n\n\t\t\t// get length of block to copy\n\t\t\tNEEDBITS(e);\n\t\t\tcopy_leng = t.n + GETBITS(e);\n\t\t\tDUMPBITS(e);\n\n\t\t\t// decode distance of block to copy\n\t\t\tNEEDBITS(bd);\n\t\t\tt = td.list[GETBITS(bd)];\n\t\t\te = t.e;\n\n\t\t\twhile (e > 16) {\n\t\t\t\tif (e === 99) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tDUMPBITS(t.b);\n\t\t\t\te -= 16;\n\t\t\t\tNEEDBITS(e);\n\t\t\t\tt = t.t[GETBITS(e)];\n\t\t\t\te = t.e;\n\t\t\t}\n\t\t\tDUMPBITS(t.b);\n\t\t\tNEEDBITS(e);\n\t\t\tcopy_dist = wp - t.n - GETBITS(e);\n\t\t\tDUMPBITS(e);\n\n\t\t\t// do the copy\n\t\t\twhile (copy_leng > 0 && n < size) {\n\t\t\t\tcopy_leng--;\n\t\t\t\tcopy_dist &= WSIZE - 1;\n\t\t\t\twp &= WSIZE - 1;\n\t\t\t\tbuff[off + n++] = slide[wp++] = slide[copy_dist++];\n\t\t\t}\n\n\t\t\tif (n === size) {\n\t\t\t\treturn size;\n\t\t\t}\n\t\t}\n\n\t\tmethod = -1; // done\n\t\treturn n;\n\t}\n\n\tfunction inflate_stored(buff, off, size) {\n\t\t/* \"decompress\" an inflated type 0 (stored) block. */\n\t\tvar n;\n\n\t\t// go to byte boundary\n\t\tn = bit_len & 7;\n\t\tDUMPBITS(n);\n\n\t\t// get the length and its complement\n\t\tNEEDBITS(16);\n\t\tn = GETBITS(16);\n\t\tDUMPBITS(16);\n\t\tNEEDBITS(16);\n\t\tif (n !== ((~bit_buf) & 0xffff)) {\n\t\t\treturn -1; // error in compressed data\n\t\t}\n\t\tDUMPBITS(16);\n\n\t\t// read and output the compressed data\n\t\tcopy_leng = n;\n\n\t\tn = 0;\n\t\twhile (copy_leng > 0 && n < size) {\n\t\t\tcopy_leng--;\n\t\t\twp &= WSIZE - 1;\n\t\t\tNEEDBITS(8);\n\t\t\tbuff[off + n++] = slide[wp++] = GETBITS(8);\n\t\t\tDUMPBITS(8);\n\t\t}\n\n\t\tif (copy_leng === 0) {\n\t\t\tmethod = -1; // done\n\t\t}\n\t\treturn n;\n\t}\n\n\tfunction inflate_fixed(buff, off, size) {\n\t\t// decompress an inflated type 1 (fixed Huffman codes) block.  We should\n\t\t// either replace this with a custom decoder, or at least precompute the\n\t\t// Huffman tables.\n\n\t\t// if first time, set up tables for fixed blocks\n\t\tif (!fixed_tl) {\n\t\t\tvar i; // temporary variable\n\t\t\tvar l = []; // 288 length list for huft_build (initialized below)\n\t\t\tvar h; // HuftBuild\n\n\t\t\t// literal table\n\t\t\tfor (i = 0; i < 144; i++) {\n\t\t\t\tl[i] = 8;\n\t\t\t}\n\t\t\tfor (null; i < 256; i++) {\n\t\t\t\tl[i] = 9;\n\t\t\t}\n\t\t\tfor (null; i < 280; i++) {\n\t\t\t\tl[i] = 7;\n\t\t\t}\n\t\t\tfor (null; i < 288; i++) { // make a complete, but wrong code set\n\t\t\t\tl[i] = 8;\n\t\t\t}\n\t\t\tfixed_bl = 7;\n\n\t\t\th = new HuftBuild(l, 288, 257, cplens, cplext, fixed_bl);\n\t\t\tif (h.status !== 0) {\n\t\t\t\tconsole.error(\"HufBuild error: \" + h.status);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfixed_tl = h.root;\n\t\t\tfixed_bl = h.m;\n\n\t\t\t// distance table\n\t\t\tfor (i = 0; i < 30; i++) { // make an incomplete code set\n\t\t\t\tl[i] = 5;\n\t\t\t}\n\t\t\tfixed_bd = 5;\n\n\t\t\th = new HuftBuild(l, 30, 0, cpdist, cpdext, fixed_bd);\n\t\t\tif (h.status > 1) {\n\t\t\t\tfixed_tl = null;\n\t\t\t\tconsole.error(\"HufBuild error: \" + h.status);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfixed_td = h.root;\n\t\t\tfixed_bd = h.m;\n\t\t}\n\n\t\ttl = fixed_tl;\n\t\ttd = fixed_td;\n\t\tbl = fixed_bl;\n\t\tbd = fixed_bd;\n\t\treturn inflate_codes(buff, off, size);\n\t}\n\n\tfunction inflate_dynamic(buff, off, size) {\n\t\t// decompress an inflated type 2 (dynamic Huffman codes) block.\n\t\tvar i; // temporary variables\n\t\tvar j;\n\t\tvar l; // last length\n\t\tvar n; // number of lengths to get\n\t\tvar t; // (HuftNode) literal/length code table\n\t\tvar nb; // number of bit length codes\n\t\tvar nl; // number of literal/length codes\n\t\tvar nd; // number of distance codes\n\t\tvar ll = [];\n\t\tvar h; // (HuftBuild)\n\n\t\t// literal/length and distance code lengths\n\t\tfor (i = 0; i < 286 + 30; i++) {\n\t\t\tll[i] = 0;\n\t\t}\n\n\t\t// read in table lengths\n\t\tNEEDBITS(5);\n\t\tnl = 257 + GETBITS(5); // number of literal/length codes\n\t\tDUMPBITS(5);\n\t\tNEEDBITS(5);\n\t\tnd = 1 + GETBITS(5); // number of distance codes\n\t\tDUMPBITS(5);\n\t\tNEEDBITS(4);\n\t\tnb = 4 + GETBITS(4); // number of bit length codes\n\t\tDUMPBITS(4);\n\t\tif (nl > 286 || nd > 30) {\n\t\t\treturn -1; // bad lengths\n\t\t}\n\n\t\t// read in bit-length-code lengths\n\t\tfor (j = 0; j < nb; j++) {\n\t\t\tNEEDBITS(3);\n\t\t\tll[border[j]] = GETBITS(3);\n\t\t\tDUMPBITS(3);\n\t\t}\n\t\tfor (null; j < 19; j++) {\n\t\t\tll[border[j]] = 0;\n\t\t}\n\n\t\t// build decoding table for trees--single level, 7 bit lookup\n\t\tbl = 7;\n\t\th = new HuftBuild(ll, 19, 19, null, null, bl);\n\t\tif (h.status !== 0) {\n\t\t\treturn -1; // incomplete code set\n\t\t}\n\n\t\ttl = h.root;\n\t\tbl = h.m;\n\n\t\t// read in literal and distance code lengths\n\t\tn = nl + nd;\n\t\ti = l = 0;\n\t\twhile (i < n) {\n\t\t\tNEEDBITS(bl);\n\t\t\tt = tl.list[GETBITS(bl)];\n\t\t\tj = t.b;\n\t\t\tDUMPBITS(j);\n\t\t\tj = t.n;\n\t\t\tif (j < 16) { // length of code in bits (0..15)\n\t\t\t\tll[i++] = l = j; // save last length in l\n\t\t\t} else if (j === 16) { // repeat last length 3 to 6 times\n\t\t\t\tNEEDBITS(2);\n\t\t\t\tj = 3 + GETBITS(2);\n\t\t\t\tDUMPBITS(2);\n\t\t\t\tif (i + j > n) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\twhile (j-- > 0) {\n\t\t\t\t\tll[i++] = l;\n\t\t\t\t}\n\t\t\t} else if (j === 17) { // 3 to 10 zero length codes\n\t\t\t\tNEEDBITS(3);\n\t\t\t\tj = 3 + GETBITS(3);\n\t\t\t\tDUMPBITS(3);\n\t\t\t\tif (i + j > n) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\twhile (j-- > 0) {\n\t\t\t\t\tll[i++] = 0;\n\t\t\t\t}\n\t\t\t\tl = 0;\n\t\t\t} else { // j === 18: 11 to 138 zero length codes\n\t\t\t\tNEEDBITS(7);\n\t\t\t\tj = 11 + GETBITS(7);\n\t\t\t\tDUMPBITS(7);\n\t\t\t\tif (i + j > n) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\twhile (j-- > 0) {\n\t\t\t\t\tll[i++] = 0;\n\t\t\t\t}\n\t\t\t\tl = 0;\n\t\t\t}\n\t\t}\n\n\t\t// build the decoding tables for literal/length and distance codes\n\t\tbl = lbits;\n\t\th = new HuftBuild(ll, nl, 257, cplens, cplext, bl);\n\t\tif (bl === 0) { // no literals or lengths\n\t\t\th.status = 1;\n\t\t}\n\t\tif (h.status !== 0) {\n\t\t\tif (h.status !== 1) {\n\t\t\t\treturn -1; // incomplete code set\n\t\t\t}\n\t\t\t// **incomplete literal tree**\n\t\t}\n\t\ttl = h.root;\n\t\tbl = h.m;\n\n\t\tfor (i = 0; i < nd; i++) {\n\t\t\tll[i] = ll[i + nl];\n\t\t}\n\t\tbd = dbits;\n\t\th = new HuftBuild(ll, nd, 0, cpdist, cpdext, bd);\n\t\ttd = h.root;\n\t\tbd = h.m;\n\n\t\tif (bd === 0 && nl > 257) { // lengths but no distances\n\t\t\t// **incomplete distance tree**\n\t\t\treturn -1;\n\t\t}\n/*\n\t\tif (h.status === 1) {\n\t\t\t// **incomplete distance tree**\n\t\t}\n*/\n\t\tif (h.status !== 0) {\n\t\t\treturn -1;\n\t\t}\n\n\t\t// decompress until an end-of-block code\n\t\treturn inflate_codes(buff, off, size);\n\t}\n\n\tfunction inflate_start() {\n\t\tif (!slide) {\n\t\t\tslide = []; // new Array(2 * WSIZE); // slide.length is never called\n\t\t}\n\t\twp = 0;\n\t\tbit_buf = 0;\n\t\tbit_len = 0;\n\t\tmethod = -1;\n\t\teof = false;\n\t\tcopy_leng = copy_dist = 0;\n\t\ttl = null;\n\t}\n\n\tfunction inflate_internal(buff, off, size) {\n\t\t// decompress an inflated entry\n\t\tvar n, i;\n\n\t\tn = 0;\n\t\twhile (n < size) {\n\t\t\tif (eof && method === -1) {\n\t\t\t\treturn n;\n\t\t\t}\n\n\t\t\tif (copy_leng > 0) {\n\t\t\t\tif (method !== STORED_BLOCK) {\n\t\t\t\t\t// STATIC_TREES or DYN_TREES\n\t\t\t\t\twhile (copy_leng > 0 && n < size) {\n\t\t\t\t\t\tcopy_leng--;\n\t\t\t\t\t\tcopy_dist &= WSIZE - 1;\n\t\t\t\t\t\twp &= WSIZE - 1;\n\t\t\t\t\t\tbuff[off + n++] = slide[wp++] = slide[copy_dist++];\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\twhile (copy_leng > 0 && n < size) {\n\t\t\t\t\t\tcopy_leng--;\n\t\t\t\t\t\twp &= WSIZE - 1;\n\t\t\t\t\t\tNEEDBITS(8);\n\t\t\t\t\t\tbuff[off + n++] = slide[wp++] = GETBITS(8);\n\t\t\t\t\t\tDUMPBITS(8);\n\t\t\t\t\t}\n\t\t\t\t\tif (copy_leng === 0) {\n\t\t\t\t\t\tmethod = -1; // done\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (n === size) {\n\t\t\t\t\treturn n;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (method === -1) {\n\t\t\t\tif (eof) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// read in last block bit\n\t\t\t\tNEEDBITS(1);\n\t\t\t\tif (GETBITS(1) !== 0) {\n\t\t\t\t\teof = true;\n\t\t\t\t}\n\t\t\t\tDUMPBITS(1);\n\n\t\t\t\t// read in block type\n\t\t\t\tNEEDBITS(2);\n\t\t\t\tmethod = GETBITS(2);\n\t\t\t\tDUMPBITS(2);\n\t\t\t\ttl = null;\n\t\t\t\tcopy_leng = 0;\n\t\t\t}\n\n\t\t\tswitch (method) {\n\t\t\tcase STORED_BLOCK:\n\t\t\t\ti = inflate_stored(buff, off + n, size - n);\n\t\t\t\tbreak;\n\n\t\t\tcase STATIC_TREES:\n\t\t\t\tif (tl) {\n\t\t\t\t\ti = inflate_codes(buff, off + n, size - n);\n\t\t\t\t} else {\n\t\t\t\t\ti = inflate_fixed(buff, off + n, size - n);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase DYN_TREES:\n\t\t\t\tif (tl) {\n\t\t\t\t\ti = inflate_codes(buff, off + n, size - n);\n\t\t\t\t} else {\n\t\t\t\t\ti = inflate_dynamic(buff, off + n, size - n);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault: // error\n\t\t\t\ti = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (i === -1) {\n\t\t\t\tif (eof) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tn += i;\n\t\t}\n\t\treturn n;\n\t}\n\n\tfunction inflate(arr) {\n\t\tvar buff = [], i;\n\n\t\tinflate_start();\n\t\tinflate_data = arr;\n\t\tinflate_pos = 0;\n\n\t\tdo {\n\t\t\ti = inflate_internal(buff, buff.length, 1024);\n\t\t} while (i > 0);\n\t\tinflate_data = null; // G.C.\n\t\treturn buff;\n\t}\n\n\tmodule.exports = inflate;\n}());\n","'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst mkdirsSync = require('../mkdirs').mkdirsSync\nconst utimesMillisSync = require('../util/utimes').utimesMillisSync\nconst stat = require('../util/stat')\n\nfunction copySync (src, dest, opts) {\n  if (typeof opts === 'function') {\n    opts = { filter: opts }\n  }\n\n  opts = opts || {}\n  opts.clobber = 'clobber' in opts ? !!opts.clobber : true // default to true for now\n  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber // overwrite falls back to clobber\n\n  // Warn about using preserveTimestamps on 32-bit node\n  if (opts.preserveTimestamps && process.arch === 'ia32') {\n    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\\n\n    see https://github.com/jprichardson/node-fs-extra/issues/269`)\n  }\n\n  const { srcStat, destStat } = stat.checkPathsSync(src, dest, 'copy')\n  stat.checkParentPathsSync(src, srcStat, dest, 'copy')\n  return handleFilterAndCopy(destStat, src, dest, opts)\n}\n\nfunction handleFilterAndCopy (destStat, src, dest, opts) {\n  if (opts.filter && !opts.filter(src, dest)) return\n  const destParent = path.dirname(dest)\n  if (!fs.existsSync(destParent)) mkdirsSync(destParent)\n  return startCopy(destStat, src, dest, opts)\n}\n\nfunction startCopy (destStat, src, dest, opts) {\n  if (opts.filter && !opts.filter(src, dest)) return\n  return getStats(destStat, src, dest, opts)\n}\n\nfunction getStats (destStat, src, dest, opts) {\n  const statSync = opts.dereference ? fs.statSync : fs.lstatSync\n  const srcStat = statSync(src)\n\n  if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts)\n  else if (srcStat.isFile() ||\n           srcStat.isCharacterDevice() ||\n           srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts)\n  else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts)\n}\n\nfunction onFile (srcStat, destStat, src, dest, opts) {\n  if (!destStat) return copyFile(srcStat, src, dest, opts)\n  return mayCopyFile(srcStat, src, dest, opts)\n}\n\nfunction mayCopyFile (srcStat, src, dest, opts) {\n  if (opts.overwrite) {\n    fs.unlinkSync(dest)\n    return copyFile(srcStat, src, dest, opts)\n  } else if (opts.errorOnExist) {\n    throw new Error(`'${dest}' already exists`)\n  }\n}\n\nfunction copyFile (srcStat, src, dest, opts) {\n  fs.copyFileSync(src, dest)\n  if (opts.preserveTimestamps) handleTimestamps(srcStat.mode, src, dest)\n  return setDestMode(dest, srcStat.mode)\n}\n\nfunction handleTimestamps (srcMode, src, dest) {\n  // Make sure the file is writable before setting the timestamp\n  // otherwise open fails with EPERM when invoked with 'r+'\n  // (through utimes call)\n  if (fileIsNotWritable(srcMode)) makeFileWritable(dest, srcMode)\n  return setDestTimestamps(src, dest)\n}\n\nfunction fileIsNotWritable (srcMode) {\n  return (srcMode & 0o200) === 0\n}\n\nfunction makeFileWritable (dest, srcMode) {\n  return setDestMode(dest, srcMode | 0o200)\n}\n\nfunction setDestMode (dest, srcMode) {\n  return fs.chmodSync(dest, srcMode)\n}\n\nfunction setDestTimestamps (src, dest) {\n  // The initial srcStat.atime cannot be trusted\n  // because it is modified by the read(2) system call\n  // (See https://nodejs.org/api/fs.html#fs_stat_time_values)\n  const updatedSrcStat = fs.statSync(src)\n  return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime)\n}\n\nfunction onDir (srcStat, destStat, src, dest, opts) {\n  if (!destStat) return mkDirAndCopy(srcStat.mode, src, dest, opts)\n  if (destStat && !destStat.isDirectory()) {\n    throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`)\n  }\n  return copyDir(src, dest, opts)\n}\n\nfunction mkDirAndCopy (srcMode, src, dest, opts) {\n  fs.mkdirSync(dest)\n  copyDir(src, dest, opts)\n  return setDestMode(dest, srcMode)\n}\n\nfunction copyDir (src, dest, opts) {\n  fs.readdirSync(src).forEach(item => copyDirItem(item, src, dest, opts))\n}\n\nfunction copyDirItem (item, src, dest, opts) {\n  const srcItem = path.join(src, item)\n  const destItem = path.join(dest, item)\n  const { destStat } = stat.checkPathsSync(srcItem, destItem, 'copy')\n  return startCopy(destStat, srcItem, destItem, opts)\n}\n\nfunction onLink (destStat, src, dest, opts) {\n  let resolvedSrc = fs.readlinkSync(src)\n  if (opts.dereference) {\n    resolvedSrc = path.resolve(process.cwd(), resolvedSrc)\n  }\n\n  if (!destStat) {\n    return fs.symlinkSync(resolvedSrc, dest)\n  } else {\n    let resolvedDest\n    try {\n      resolvedDest = fs.readlinkSync(dest)\n    } catch (err) {\n      // dest exists and is a regular file or directory,\n      // Windows may throw UNKNOWN error. If dest already exists,\n      // fs throws error anyway, so no need to guard against it here.\n      if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs.symlinkSync(resolvedSrc, dest)\n      throw err\n    }\n    if (opts.dereference) {\n      resolvedDest = path.resolve(process.cwd(), resolvedDest)\n    }\n    if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {\n      throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`)\n    }\n\n    // prevent copy if src is a subdir of dest since unlinking\n    // dest in this case would result in removing src contents\n    // and therefore a broken symlink would be created.\n    if (fs.statSync(dest).isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {\n      throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`)\n    }\n    return copyLink(resolvedSrc, dest)\n  }\n}\n\nfunction copyLink (resolvedSrc, dest) {\n  fs.unlinkSync(dest)\n  return fs.symlinkSync(resolvedSrc, dest)\n}\n\nmodule.exports = copySync\n","'use strict'\n\nmodule.exports = {\n  copySync: require('./copy-sync')\n}\n","'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst mkdirs = require('../mkdirs').mkdirs\nconst pathExists = require('../path-exists').pathExists\nconst utimesMillis = require('../util/utimes').utimesMillis\nconst stat = require('../util/stat')\n\nfunction copy (src, dest, opts, cb) {\n  if (typeof opts === 'function' && !cb) {\n    cb = opts\n    opts = {}\n  } else if (typeof opts === 'function') {\n    opts = { filter: opts }\n  }\n\n  cb = cb || function () {}\n  opts = opts || {}\n\n  opts.clobber = 'clobber' in opts ? !!opts.clobber : true // default to true for now\n  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber // overwrite falls back to clobber\n\n  // Warn about using preserveTimestamps on 32-bit node\n  if (opts.preserveTimestamps && process.arch === 'ia32') {\n    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\\n\n    see https://github.com/jprichardson/node-fs-extra/issues/269`)\n  }\n\n  stat.checkPaths(src, dest, 'copy', (err, stats) => {\n    if (err) return cb(err)\n    const { srcStat, destStat } = stats\n    stat.checkParentPaths(src, srcStat, dest, 'copy', err => {\n      if (err) return cb(err)\n      if (opts.filter) return handleFilter(checkParentDir, destStat, src, dest, opts, cb)\n      return checkParentDir(destStat, src, dest, opts, cb)\n    })\n  })\n}\n\nfunction checkParentDir (destStat, src, dest, opts, cb) {\n  const destParent = path.dirname(dest)\n  pathExists(destParent, (err, dirExists) => {\n    if (err) return cb(err)\n    if (dirExists) return startCopy(destStat, src, dest, opts, cb)\n    mkdirs(destParent, err => {\n      if (err) return cb(err)\n      return startCopy(destStat, src, dest, opts, cb)\n    })\n  })\n}\n\nfunction handleFilter (onInclude, destStat, src, dest, opts, cb) {\n  Promise.resolve(opts.filter(src, dest)).then(include => {\n    if (include) return onInclude(destStat, src, dest, opts, cb)\n    return cb()\n  }, error => cb(error))\n}\n\nfunction startCopy (destStat, src, dest, opts, cb) {\n  if (opts.filter) return handleFilter(getStats, destStat, src, dest, opts, cb)\n  return getStats(destStat, src, dest, opts, cb)\n}\n\nfunction getStats (destStat, src, dest, opts, cb) {\n  const stat = opts.dereference ? fs.stat : fs.lstat\n  stat(src, (err, srcStat) => {\n    if (err) return cb(err)\n\n    if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts, cb)\n    else if (srcStat.isFile() ||\n             srcStat.isCharacterDevice() ||\n             srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts, cb)\n    else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts, cb)\n  })\n}\n\nfunction onFile (srcStat, destStat, src, dest, opts, cb) {\n  if (!destStat) return copyFile(srcStat, src, dest, opts, cb)\n  return mayCopyFile(srcStat, src, dest, opts, cb)\n}\n\nfunction mayCopyFile (srcStat, src, dest, opts, cb) {\n  if (opts.overwrite) {\n    fs.unlink(dest, err => {\n      if (err) return cb(err)\n      return copyFile(srcStat, src, dest, opts, cb)\n    })\n  } else if (opts.errorOnExist) {\n    return cb(new Error(`'${dest}' already exists`))\n  } else return cb()\n}\n\nfunction copyFile (srcStat, src, dest, opts, cb) {\n  fs.copyFile(src, dest, err => {\n    if (err) return cb(err)\n    if (opts.preserveTimestamps) return handleTimestampsAndMode(srcStat.mode, src, dest, cb)\n    return setDestMode(dest, srcStat.mode, cb)\n  })\n}\n\nfunction handleTimestampsAndMode (srcMode, src, dest, cb) {\n  // Make sure the file is writable before setting the timestamp\n  // otherwise open fails with EPERM when invoked with 'r+'\n  // (through utimes call)\n  if (fileIsNotWritable(srcMode)) {\n    return makeFileWritable(dest, srcMode, err => {\n      if (err) return cb(err)\n      return setDestTimestampsAndMode(srcMode, src, dest, cb)\n    })\n  }\n  return setDestTimestampsAndMode(srcMode, src, dest, cb)\n}\n\nfunction fileIsNotWritable (srcMode) {\n  return (srcMode & 0o200) === 0\n}\n\nfunction makeFileWritable (dest, srcMode, cb) {\n  return setDestMode(dest, srcMode | 0o200, cb)\n}\n\nfunction setDestTimestampsAndMode (srcMode, src, dest, cb) {\n  setDestTimestamps(src, dest, err => {\n    if (err) return cb(err)\n    return setDestMode(dest, srcMode, cb)\n  })\n}\n\nfunction setDestMode (dest, srcMode, cb) {\n  return fs.chmod(dest, srcMode, cb)\n}\n\nfunction setDestTimestamps (src, dest, cb) {\n  // The initial srcStat.atime cannot be trusted\n  // because it is modified by the read(2) system call\n  // (See https://nodejs.org/api/fs.html#fs_stat_time_values)\n  fs.stat(src, (err, updatedSrcStat) => {\n    if (err) return cb(err)\n    return utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime, cb)\n  })\n}\n\nfunction onDir (srcStat, destStat, src, dest, opts, cb) {\n  if (!destStat) return mkDirAndCopy(srcStat.mode, src, dest, opts, cb)\n  if (destStat && !destStat.isDirectory()) {\n    return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`))\n  }\n  return copyDir(src, dest, opts, cb)\n}\n\nfunction mkDirAndCopy (srcMode, src, dest, opts, cb) {\n  fs.mkdir(dest, err => {\n    if (err) return cb(err)\n    copyDir(src, dest, opts, err => {\n      if (err) return cb(err)\n      return setDestMode(dest, srcMode, cb)\n    })\n  })\n}\n\nfunction copyDir (src, dest, opts, cb) {\n  fs.readdir(src, (err, items) => {\n    if (err) return cb(err)\n    return copyDirItems(items, src, dest, opts, cb)\n  })\n}\n\nfunction copyDirItems (items, src, dest, opts, cb) {\n  const item = items.pop()\n  if (!item) return cb()\n  return copyDirItem(items, item, src, dest, opts, cb)\n}\n\nfunction copyDirItem (items, item, src, dest, opts, cb) {\n  const srcItem = path.join(src, item)\n  const destItem = path.join(dest, item)\n  stat.checkPaths(srcItem, destItem, 'copy', (err, stats) => {\n    if (err) return cb(err)\n    const { destStat } = stats\n    startCopy(destStat, srcItem, destItem, opts, err => {\n      if (err) return cb(err)\n      return copyDirItems(items, src, dest, opts, cb)\n    })\n  })\n}\n\nfunction onLink (destStat, src, dest, opts, cb) {\n  fs.readlink(src, (err, resolvedSrc) => {\n    if (err) return cb(err)\n    if (opts.dereference) {\n      resolvedSrc = path.resolve(process.cwd(), resolvedSrc)\n    }\n\n    if (!destStat) {\n      return fs.symlink(resolvedSrc, dest, cb)\n    } else {\n      fs.readlink(dest, (err, resolvedDest) => {\n        if (err) {\n          // dest exists and is a regular file or directory,\n          // Windows may throw UNKNOWN error. If dest already exists,\n          // fs throws error anyway, so no need to guard against it here.\n          if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs.symlink(resolvedSrc, dest, cb)\n          return cb(err)\n        }\n        if (opts.dereference) {\n          resolvedDest = path.resolve(process.cwd(), resolvedDest)\n        }\n        if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {\n          return cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`))\n        }\n\n        // do not copy if src is a subdir of dest since unlinking\n        // dest in this case would result in removing src contents\n        // and therefore a broken symlink would be created.\n        if (destStat.isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {\n          return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`))\n        }\n        return copyLink(resolvedSrc, dest, cb)\n      })\n    }\n  })\n}\n\nfunction copyLink (resolvedSrc, dest, cb) {\n  fs.unlink(dest, err => {\n    if (err) return cb(err)\n    return fs.symlink(resolvedSrc, dest, cb)\n  })\n}\n\nmodule.exports = copy\n","'use strict'\n\nconst u = require('universalify').fromCallback\nmodule.exports = {\n  copy: u(require('./copy'))\n}\n","'use strict'\n\nconst u = require('universalify').fromCallback\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst mkdir = require('../mkdirs')\nconst remove = require('../remove')\n\nconst emptyDir = u(function emptyDir (dir, callback) {\n  callback = callback || function () {}\n  fs.readdir(dir, (err, items) => {\n    if (err) return mkdir.mkdirs(dir, callback)\n\n    items = items.map(item => path.join(dir, item))\n\n    deleteItem()\n\n    function deleteItem () {\n      const item = items.pop()\n      if (!item) return callback()\n      remove.remove(item, err => {\n        if (err) return callback(err)\n        deleteItem()\n      })\n    }\n  })\n})\n\nfunction emptyDirSync (dir) {\n  let items\n  try {\n    items = fs.readdirSync(dir)\n  } catch {\n    return mkdir.mkdirsSync(dir)\n  }\n\n  items.forEach(item => {\n    item = path.join(dir, item)\n    remove.removeSync(item)\n  })\n}\n\nmodule.exports = {\n  emptyDirSync,\n  emptydirSync: emptyDirSync,\n  emptyDir,\n  emptydir: emptyDir\n}\n","'use strict'\n\nconst u = require('universalify').fromCallback\nconst path = require('path')\nconst fs = require('graceful-fs')\nconst mkdir = require('../mkdirs')\n\nfunction createFile (file, callback) {\n  function makeFile () {\n    fs.writeFile(file, '', err => {\n      if (err) return callback(err)\n      callback()\n    })\n  }\n\n  fs.stat(file, (err, stats) => { // eslint-disable-line handle-callback-err\n    if (!err && stats.isFile()) return callback()\n    const dir = path.dirname(file)\n    fs.stat(dir, (err, stats) => {\n      if (err) {\n        // if the directory doesn't exist, make it\n        if (err.code === 'ENOENT') {\n          return mkdir.mkdirs(dir, err => {\n            if (err) return callback(err)\n            makeFile()\n          })\n        }\n        return callback(err)\n      }\n\n      if (stats.isDirectory()) makeFile()\n      else {\n        // parent is not a directory\n        // This is just to cause an internal ENOTDIR error to be thrown\n        fs.readdir(dir, err => {\n          if (err) return callback(err)\n        })\n      }\n    })\n  })\n}\n\nfunction createFileSync (file) {\n  let stats\n  try {\n    stats = fs.statSync(file)\n  } catch {}\n  if (stats && stats.isFile()) return\n\n  const dir = path.dirname(file)\n  try {\n    if (!fs.statSync(dir).isDirectory()) {\n      // parent is not a directory\n      // This is just to cause an internal ENOTDIR error to be thrown\n      fs.readdirSync(dir)\n    }\n  } catch (err) {\n    // If the stat call above failed because the directory doesn't exist, create it\n    if (err && err.code === 'ENOENT') mkdir.mkdirsSync(dir)\n    else throw err\n  }\n\n  fs.writeFileSync(file, '')\n}\n\nmodule.exports = {\n  createFile: u(createFile),\n  createFileSync\n}\n","'use strict'\n\nconst file = require('./file')\nconst link = require('./link')\nconst symlink = require('./symlink')\n\nmodule.exports = {\n  // file\n  createFile: file.createFile,\n  createFileSync: file.createFileSync,\n  ensureFile: file.createFile,\n  ensureFileSync: file.createFileSync,\n  // link\n  createLink: link.createLink,\n  createLinkSync: link.createLinkSync,\n  ensureLink: link.createLink,\n  ensureLinkSync: link.createLinkSync,\n  // symlink\n  createSymlink: symlink.createSymlink,\n  createSymlinkSync: symlink.createSymlinkSync,\n  ensureSymlink: symlink.createSymlink,\n  ensureSymlinkSync: symlink.createSymlinkSync\n}\n","'use strict'\n\nconst u = require('universalify').fromCallback\nconst path = require('path')\nconst fs = require('graceful-fs')\nconst mkdir = require('../mkdirs')\nconst pathExists = require('../path-exists').pathExists\n\nfunction createLink (srcpath, dstpath, callback) {\n  function makeLink (srcpath, dstpath) {\n    fs.link(srcpath, dstpath, err => {\n      if (err) return callback(err)\n      callback(null)\n    })\n  }\n\n  pathExists(dstpath, (err, destinationExists) => {\n    if (err) return callback(err)\n    if (destinationExists) return callback(null)\n    fs.lstat(srcpath, (err) => {\n      if (err) {\n        err.message = err.message.replace('lstat', 'ensureLink')\n        return callback(err)\n      }\n\n      const dir = path.dirname(dstpath)\n      pathExists(dir, (err, dirExists) => {\n        if (err) return callback(err)\n        if (dirExists) return makeLink(srcpath, dstpath)\n        mkdir.mkdirs(dir, err => {\n          if (err) return callback(err)\n          makeLink(srcpath, dstpath)\n        })\n      })\n    })\n  })\n}\n\nfunction createLinkSync (srcpath, dstpath) {\n  const destinationExists = fs.existsSync(dstpath)\n  if (destinationExists) return undefined\n\n  try {\n    fs.lstatSync(srcpath)\n  } catch (err) {\n    err.message = err.message.replace('lstat', 'ensureLink')\n    throw err\n  }\n\n  const dir = path.dirname(dstpath)\n  const dirExists = fs.existsSync(dir)\n  if (dirExists) return fs.linkSync(srcpath, dstpath)\n  mkdir.mkdirsSync(dir)\n\n  return fs.linkSync(srcpath, dstpath)\n}\n\nmodule.exports = {\n  createLink: u(createLink),\n  createLinkSync\n}\n","'use strict'\n\nconst path = require('path')\nconst fs = require('graceful-fs')\nconst pathExists = require('../path-exists').pathExists\n\n/**\n * Function that returns two types of paths, one relative to symlink, and one\n * relative to the current working directory. Checks if path is absolute or\n * relative. If the path is relative, this function checks if the path is\n * relative to symlink or relative to current working directory. This is an\n * initiative to find a smarter `srcpath` to supply when building symlinks.\n * This allows you to determine which path to use out of one of three possible\n * types of source paths. The first is an absolute path. This is detected by\n * `path.isAbsolute()`. When an absolute path is provided, it is checked to\n * see if it exists. If it does it's used, if not an error is returned\n * (callback)/ thrown (sync). The other two options for `srcpath` are a\n * relative url. By default Node's `fs.symlink` works by creating a symlink\n * using `dstpath` and expects the `srcpath` to be relative to the newly\n * created symlink. If you provide a `srcpath` that does not exist on the file\n * system it results in a broken symlink. To minimize this, the function\n * checks to see if the 'relative to symlink' source file exists, and if it\n * does it will use it. If it does not, it checks if there's a file that\n * exists that is relative to the current working directory, if does its used.\n * This preserves the expectations of the original fs.symlink spec and adds\n * the ability to pass in `relative to current working direcotry` paths.\n */\n\nfunction symlinkPaths (srcpath, dstpath, callback) {\n  if (path.isAbsolute(srcpath)) {\n    return fs.lstat(srcpath, (err) => {\n      if (err) {\n        err.message = err.message.replace('lstat', 'ensureSymlink')\n        return callback(err)\n      }\n      return callback(null, {\n        toCwd: srcpath,\n        toDst: srcpath\n      })\n    })\n  } else {\n    const dstdir = path.dirname(dstpath)\n    const relativeToDst = path.join(dstdir, srcpath)\n    return pathExists(relativeToDst, (err, exists) => {\n      if (err) return callback(err)\n      if (exists) {\n        return callback(null, {\n          toCwd: relativeToDst,\n          toDst: srcpath\n        })\n      } else {\n        return fs.lstat(srcpath, (err) => {\n          if (err) {\n            err.message = err.message.replace('lstat', 'ensureSymlink')\n            return callback(err)\n          }\n          return callback(null, {\n            toCwd: srcpath,\n            toDst: path.relative(dstdir, srcpath)\n          })\n        })\n      }\n    })\n  }\n}\n\nfunction symlinkPathsSync (srcpath, dstpath) {\n  let exists\n  if (path.isAbsolute(srcpath)) {\n    exists = fs.existsSync(srcpath)\n    if (!exists) throw new Error('absolute srcpath does not exist')\n    return {\n      toCwd: srcpath,\n      toDst: srcpath\n    }\n  } else {\n    const dstdir = path.dirname(dstpath)\n    const relativeToDst = path.join(dstdir, srcpath)\n    exists = fs.existsSync(relativeToDst)\n    if (exists) {\n      return {\n        toCwd: relativeToDst,\n        toDst: srcpath\n      }\n    } else {\n      exists = fs.existsSync(srcpath)\n      if (!exists) throw new Error('relative srcpath does not exist')\n      return {\n        toCwd: srcpath,\n        toDst: path.relative(dstdir, srcpath)\n      }\n    }\n  }\n}\n\nmodule.exports = {\n  symlinkPaths,\n  symlinkPathsSync\n}\n","'use strict'\n\nconst fs = require('graceful-fs')\n\nfunction symlinkType (srcpath, type, callback) {\n  callback = (typeof type === 'function') ? type : callback\n  type = (typeof type === 'function') ? false : type\n  if (type) return callback(null, type)\n  fs.lstat(srcpath, (err, stats) => {\n    if (err) return callback(null, 'file')\n    type = (stats && stats.isDirectory()) ? 'dir' : 'file'\n    callback(null, type)\n  })\n}\n\nfunction symlinkTypeSync (srcpath, type) {\n  let stats\n\n  if (type) return type\n  try {\n    stats = fs.lstatSync(srcpath)\n  } catch {\n    return 'file'\n  }\n  return (stats && stats.isDirectory()) ? 'dir' : 'file'\n}\n\nmodule.exports = {\n  symlinkType,\n  symlinkTypeSync\n}\n","'use strict'\n\nconst u = require('universalify').fromCallback\nconst path = require('path')\nconst fs = require('graceful-fs')\nconst _mkdirs = require('../mkdirs')\nconst mkdirs = _mkdirs.mkdirs\nconst mkdirsSync = _mkdirs.mkdirsSync\n\nconst _symlinkPaths = require('./symlink-paths')\nconst symlinkPaths = _symlinkPaths.symlinkPaths\nconst symlinkPathsSync = _symlinkPaths.symlinkPathsSync\n\nconst _symlinkType = require('./symlink-type')\nconst symlinkType = _symlinkType.symlinkType\nconst symlinkTypeSync = _symlinkType.symlinkTypeSync\n\nconst pathExists = require('../path-exists').pathExists\n\nfunction createSymlink (srcpath, dstpath, type, callback) {\n  callback = (typeof type === 'function') ? type : callback\n  type = (typeof type === 'function') ? false : type\n\n  pathExists(dstpath, (err, destinationExists) => {\n    if (err) return callback(err)\n    if (destinationExists) return callback(null)\n    symlinkPaths(srcpath, dstpath, (err, relative) => {\n      if (err) return callback(err)\n      srcpath = relative.toDst\n      symlinkType(relative.toCwd, type, (err, type) => {\n        if (err) return callback(err)\n        const dir = path.dirname(dstpath)\n        pathExists(dir, (err, dirExists) => {\n          if (err) return callback(err)\n          if (dirExists) return fs.symlink(srcpath, dstpath, type, callback)\n          mkdirs(dir, err => {\n            if (err) return callback(err)\n            fs.symlink(srcpath, dstpath, type, callback)\n          })\n        })\n      })\n    })\n  })\n}\n\nfunction createSymlinkSync (srcpath, dstpath, type) {\n  const destinationExists = fs.existsSync(dstpath)\n  if (destinationExists) return undefined\n\n  const relative = symlinkPathsSync(srcpath, dstpath)\n  srcpath = relative.toDst\n  type = symlinkTypeSync(relative.toCwd, type)\n  const dir = path.dirname(dstpath)\n  const exists = fs.existsSync(dir)\n  if (exists) return fs.symlinkSync(srcpath, dstpath, type)\n  mkdirsSync(dir)\n  return fs.symlinkSync(srcpath, dstpath, type)\n}\n\nmodule.exports = {\n  createSymlink: u(createSymlink),\n  createSymlinkSync\n}\n","'use strict'\n// This is adapted from https://github.com/normalize/mz\n// Copyright (c) 2014-2016 Jonathan Ong me@jongleberry.com and Contributors\nconst u = require('universalify').fromCallback\nconst fs = require('graceful-fs')\n\nconst api = [\n  'access',\n  'appendFile',\n  'chmod',\n  'chown',\n  'close',\n  'copyFile',\n  'fchmod',\n  'fchown',\n  'fdatasync',\n  'fstat',\n  'fsync',\n  'ftruncate',\n  'futimes',\n  'lchmod',\n  'lchown',\n  'link',\n  'lstat',\n  'mkdir',\n  'mkdtemp',\n  'open',\n  'opendir',\n  'readdir',\n  'readFile',\n  'readlink',\n  'realpath',\n  'rename',\n  'rmdir',\n  'stat',\n  'symlink',\n  'truncate',\n  'unlink',\n  'utimes',\n  'writeFile'\n].filter(key => {\n  // Some commands are not available on some systems. Ex:\n  // fs.opendir was added in Node.js v12.12.0\n  // fs.lchown is not available on at least some Linux\n  return typeof fs[key] === 'function'\n})\n\n// Export all keys:\nObject.keys(fs).forEach(key => {\n  if (key === 'promises') {\n    // fs.promises is a getter property that triggers ExperimentalWarning\n    // Don't re-export it here, the getter is defined in \"lib/index.js\"\n    return\n  }\n  exports[key] = fs[key]\n})\n\n// Universalify async methods:\napi.forEach(method => {\n  exports[method] = u(fs[method])\n})\n\n// We differ from mz/fs in that we still ship the old, broken, fs.exists()\n// since we are a drop-in replacement for the native module\nexports.exists = function (filename, callback) {\n  if (typeof callback === 'function') {\n    return fs.exists(filename, callback)\n  }\n  return new Promise(resolve => {\n    return fs.exists(filename, resolve)\n  })\n}\n\n// fs.read(), fs.write(), & fs.writev() need special treatment due to multiple callback args\n\nexports.read = function (fd, buffer, offset, length, position, callback) {\n  if (typeof callback === 'function') {\n    return fs.read(fd, buffer, offset, length, position, callback)\n  }\n  return new Promise((resolve, reject) => {\n    fs.read(fd, buffer, offset, length, position, (err, bytesRead, buffer) => {\n      if (err) return reject(err)\n      resolve({ bytesRead, buffer })\n    })\n  })\n}\n\n// Function signature can be\n// fs.write(fd, buffer[, offset[, length[, position]]], callback)\n// OR\n// fs.write(fd, string[, position[, encoding]], callback)\n// We need to handle both cases, so we use ...args\nexports.write = function (fd, buffer, ...args) {\n  if (typeof args[args.length - 1] === 'function') {\n    return fs.write(fd, buffer, ...args)\n  }\n\n  return new Promise((resolve, reject) => {\n    fs.write(fd, buffer, ...args, (err, bytesWritten, buffer) => {\n      if (err) return reject(err)\n      resolve({ bytesWritten, buffer })\n    })\n  })\n}\n\n// fs.writev only available in Node v12.9.0+\nif (typeof fs.writev === 'function') {\n  // Function signature is\n  // s.writev(fd, buffers[, position], callback)\n  // We need to handle the optional arg, so we use ...args\n  exports.writev = function (fd, buffers, ...args) {\n    if (typeof args[args.length - 1] === 'function') {\n      return fs.writev(fd, buffers, ...args)\n    }\n\n    return new Promise((resolve, reject) => {\n      fs.writev(fd, buffers, ...args, (err, bytesWritten, buffers) => {\n        if (err) return reject(err)\n        resolve({ bytesWritten, buffers })\n      })\n    })\n  }\n}\n\n// fs.realpath.native only available in Node v9.2+\nif (typeof fs.realpath.native === 'function') {\n  exports.realpath.native = u(fs.realpath.native)\n}\n","'use strict'\n\nmodule.exports = {\n  // Export promiseified graceful-fs:\n  ...require('./fs'),\n  // Export extra methods:\n  ...require('./copy-sync'),\n  ...require('./copy'),\n  ...require('./empty'),\n  ...require('./ensure'),\n  ...require('./json'),\n  ...require('./mkdirs'),\n  ...require('./move-sync'),\n  ...require('./move'),\n  ...require('./output'),\n  ...require('./path-exists'),\n  ...require('./remove')\n}\n\n// Export fs.promises as a getter property so that we don't trigger\n// ExperimentalWarning before fs.promises is actually accessed.\nconst fs = require('fs')\nif (Object.getOwnPropertyDescriptor(fs, 'promises')) {\n  Object.defineProperty(module.exports, 'promises', {\n    get () { return fs.promises }\n  })\n}\n","'use strict'\n\nconst u = require('universalify').fromPromise\nconst jsonFile = require('./jsonfile')\n\njsonFile.outputJson = u(require('./output-json'))\njsonFile.outputJsonSync = require('./output-json-sync')\n// aliases\njsonFile.outputJSON = jsonFile.outputJson\njsonFile.outputJSONSync = jsonFile.outputJsonSync\njsonFile.writeJSON = jsonFile.writeJson\njsonFile.writeJSONSync = jsonFile.writeJsonSync\njsonFile.readJSON = jsonFile.readJson\njsonFile.readJSONSync = jsonFile.readJsonSync\n\nmodule.exports = jsonFile\n","'use strict'\n\nconst jsonFile = require('jsonfile')\n\nmodule.exports = {\n  // jsonfile exports\n  readJson: jsonFile.readFile,\n  readJsonSync: jsonFile.readFileSync,\n  writeJson: jsonFile.writeFile,\n  writeJsonSync: jsonFile.writeFileSync\n}\n","'use strict'\n\nconst { stringify } = require('jsonfile/utils')\nconst { outputFileSync } = require('../output')\n\nfunction outputJsonSync (file, data, options) {\n  const str = stringify(data, options)\n\n  outputFileSync(file, str, options)\n}\n\nmodule.exports = outputJsonSync\n","'use strict'\n\nconst { stringify } = require('jsonfile/utils')\nconst { outputFile } = require('../output')\n\nasync function outputJson (file, data, options = {}) {\n  const str = stringify(data, options)\n\n  await outputFile(file, str, options)\n}\n\nmodule.exports = outputJson\n","'use strict'\nconst u = require('universalify').fromPromise\nconst { makeDir: _makeDir, makeDirSync } = require('./make-dir')\nconst makeDir = u(_makeDir)\n\nmodule.exports = {\n  mkdirs: makeDir,\n  mkdirsSync: makeDirSync,\n  // alias\n  mkdirp: makeDir,\n  mkdirpSync: makeDirSync,\n  ensureDir: makeDir,\n  ensureDirSync: makeDirSync\n}\n","// Adapted from https://github.com/sindresorhus/make-dir\n// Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n'use strict'\nconst fs = require('../fs')\nconst path = require('path')\nconst atLeastNode = require('at-least-node')\n\nconst useNativeRecursiveOption = atLeastNode('10.12.0')\n\n// https://github.com/nodejs/node/issues/8987\n// https://github.com/libuv/libuv/pull/1088\nconst checkPath = pth => {\n  if (process.platform === 'win32') {\n    const pathHasInvalidWinCharacters = /[<>:\"|?*]/.test(pth.replace(path.parse(pth).root, ''))\n\n    if (pathHasInvalidWinCharacters) {\n      const error = new Error(`Path contains invalid characters: ${pth}`)\n      error.code = 'EINVAL'\n      throw error\n    }\n  }\n}\n\nconst processOptions = options => {\n  const defaults = { mode: 0o777 }\n  if (typeof options === 'number') options = { mode: options }\n  return { ...defaults, ...options }\n}\n\nconst permissionError = pth => {\n  // This replicates the exception of `fs.mkdir` with native the\n  // `recusive` option when run on an invalid drive under Windows.\n  const error = new Error(`operation not permitted, mkdir '${pth}'`)\n  error.code = 'EPERM'\n  error.errno = -4048\n  error.path = pth\n  error.syscall = 'mkdir'\n  return error\n}\n\nmodule.exports.makeDir = async (input, options) => {\n  checkPath(input)\n  options = processOptions(options)\n\n  if (useNativeRecursiveOption) {\n    const pth = path.resolve(input)\n\n    return fs.mkdir(pth, {\n      mode: options.mode,\n      recursive: true\n    })\n  }\n\n  const make = async pth => {\n    try {\n      await fs.mkdir(pth, options.mode)\n    } catch (error) {\n      if (error.code === 'EPERM') {\n        throw error\n      }\n\n      if (error.code === 'ENOENT') {\n        if (path.dirname(pth) === pth) {\n          throw permissionError(pth)\n        }\n\n        if (error.message.includes('null bytes')) {\n          throw error\n        }\n\n        await make(path.dirname(pth))\n        return make(pth)\n      }\n\n      try {\n        const stats = await fs.stat(pth)\n        if (!stats.isDirectory()) {\n          // This error is never exposed to the user\n          // it is caught below, and the original error is thrown\n          throw new Error('The path is not a directory')\n        }\n      } catch {\n        throw error\n      }\n    }\n  }\n\n  return make(path.resolve(input))\n}\n\nmodule.exports.makeDirSync = (input, options) => {\n  checkPath(input)\n  options = processOptions(options)\n\n  if (useNativeRecursiveOption) {\n    const pth = path.resolve(input)\n\n    return fs.mkdirSync(pth, {\n      mode: options.mode,\n      recursive: true\n    })\n  }\n\n  const make = pth => {\n    try {\n      fs.mkdirSync(pth, options.mode)\n    } catch (error) {\n      if (error.code === 'EPERM') {\n        throw error\n      }\n\n      if (error.code === 'ENOENT') {\n        if (path.dirname(pth) === pth) {\n          throw permissionError(pth)\n        }\n\n        if (error.message.includes('null bytes')) {\n          throw error\n        }\n\n        make(path.dirname(pth))\n        return make(pth)\n      }\n\n      try {\n        if (!fs.statSync(pth).isDirectory()) {\n          // This error is never exposed to the user\n          // it is caught below, and the original error is thrown\n          throw new Error('The path is not a directory')\n        }\n      } catch {\n        throw error\n      }\n    }\n  }\n\n  return make(path.resolve(input))\n}\n","'use strict'\n\nmodule.exports = {\n  moveSync: require('./move-sync')\n}\n","'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst copySync = require('../copy-sync').copySync\nconst removeSync = require('../remove').removeSync\nconst mkdirpSync = require('../mkdirs').mkdirpSync\nconst stat = require('../util/stat')\n\nfunction moveSync (src, dest, opts) {\n  opts = opts || {}\n  const overwrite = opts.overwrite || opts.clobber || false\n\n  const { srcStat } = stat.checkPathsSync(src, dest, 'move')\n  stat.checkParentPathsSync(src, srcStat, dest, 'move')\n  mkdirpSync(path.dirname(dest))\n  return doRename(src, dest, overwrite)\n}\n\nfunction doRename (src, dest, overwrite) {\n  if (overwrite) {\n    removeSync(dest)\n    return rename(src, dest, overwrite)\n  }\n  if (fs.existsSync(dest)) throw new Error('dest already exists.')\n  return rename(src, dest, overwrite)\n}\n\nfunction rename (src, dest, overwrite) {\n  try {\n    fs.renameSync(src, dest)\n  } catch (err) {\n    if (err.code !== 'EXDEV') throw err\n    return moveAcrossDevice(src, dest, overwrite)\n  }\n}\n\nfunction moveAcrossDevice (src, dest, overwrite) {\n  const opts = {\n    overwrite,\n    errorOnExist: true\n  }\n  copySync(src, dest, opts)\n  return removeSync(src)\n}\n\nmodule.exports = moveSync\n","'use strict'\n\nconst u = require('universalify').fromCallback\nmodule.exports = {\n  move: u(require('./move'))\n}\n","'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst copy = require('../copy').copy\nconst remove = require('../remove').remove\nconst mkdirp = require('../mkdirs').mkdirp\nconst pathExists = require('../path-exists').pathExists\nconst stat = require('../util/stat')\n\nfunction move (src, dest, opts, cb) {\n  if (typeof opts === 'function') {\n    cb = opts\n    opts = {}\n  }\n\n  const overwrite = opts.overwrite || opts.clobber || false\n\n  stat.checkPaths(src, dest, 'move', (err, stats) => {\n    if (err) return cb(err)\n    const { srcStat } = stats\n    stat.checkParentPaths(src, srcStat, dest, 'move', err => {\n      if (err) return cb(err)\n      mkdirp(path.dirname(dest), err => {\n        if (err) return cb(err)\n        return doRename(src, dest, overwrite, cb)\n      })\n    })\n  })\n}\n\nfunction doRename (src, dest, overwrite, cb) {\n  if (overwrite) {\n    return remove(dest, err => {\n      if (err) return cb(err)\n      return rename(src, dest, overwrite, cb)\n    })\n  }\n  pathExists(dest, (err, destExists) => {\n    if (err) return cb(err)\n    if (destExists) return cb(new Error('dest already exists.'))\n    return rename(src, dest, overwrite, cb)\n  })\n}\n\nfunction rename (src, dest, overwrite, cb) {\n  fs.rename(src, dest, err => {\n    if (!err) return cb()\n    if (err.code !== 'EXDEV') return cb(err)\n    return moveAcrossDevice(src, dest, overwrite, cb)\n  })\n}\n\nfunction moveAcrossDevice (src, dest, overwrite, cb) {\n  const opts = {\n    overwrite,\n    errorOnExist: true\n  }\n  copy(src, dest, opts, err => {\n    if (err) return cb(err)\n    return remove(src, cb)\n  })\n}\n\nmodule.exports = move\n","'use strict'\n\nconst u = require('universalify').fromCallback\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst mkdir = require('../mkdirs')\nconst pathExists = require('../path-exists').pathExists\n\nfunction outputFile (file, data, encoding, callback) {\n  if (typeof encoding === 'function') {\n    callback = encoding\n    encoding = 'utf8'\n  }\n\n  const dir = path.dirname(file)\n  pathExists(dir, (err, itDoes) => {\n    if (err) return callback(err)\n    if (itDoes) return fs.writeFile(file, data, encoding, callback)\n\n    mkdir.mkdirs(dir, err => {\n      if (err) return callback(err)\n\n      fs.writeFile(file, data, encoding, callback)\n    })\n  })\n}\n\nfunction outputFileSync (file, ...args) {\n  const dir = path.dirname(file)\n  if (fs.existsSync(dir)) {\n    return fs.writeFileSync(file, ...args)\n  }\n  mkdir.mkdirsSync(dir)\n  fs.writeFileSync(file, ...args)\n}\n\nmodule.exports = {\n  outputFile: u(outputFile),\n  outputFileSync\n}\n","'use strict'\nconst u = require('universalify').fromPromise\nconst fs = require('../fs')\n\nfunction pathExists (path) {\n  return fs.access(path).then(() => true).catch(() => false)\n}\n\nmodule.exports = {\n  pathExists: u(pathExists),\n  pathExistsSync: fs.existsSync\n}\n","'use strict'\n\nconst u = require('universalify').fromCallback\nconst rimraf = require('./rimraf')\n\nmodule.exports = {\n  remove: u(rimraf),\n  removeSync: rimraf.sync\n}\n","'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst assert = require('assert')\n\nconst isWindows = (process.platform === 'win32')\n\nfunction defaults (options) {\n  const methods = [\n    'unlink',\n    'chmod',\n    'stat',\n    'lstat',\n    'rmdir',\n    'readdir'\n  ]\n  methods.forEach(m => {\n    options[m] = options[m] || fs[m]\n    m = m + 'Sync'\n    options[m] = options[m] || fs[m]\n  })\n\n  options.maxBusyTries = options.maxBusyTries || 3\n}\n\nfunction rimraf (p, options, cb) {\n  let busyTries = 0\n\n  if (typeof options === 'function') {\n    cb = options\n    options = {}\n  }\n\n  assert(p, 'rimraf: missing path')\n  assert.strictEqual(typeof p, 'string', 'rimraf: path should be a string')\n  assert.strictEqual(typeof cb, 'function', 'rimraf: callback function required')\n  assert(options, 'rimraf: invalid options argument provided')\n  assert.strictEqual(typeof options, 'object', 'rimraf: options should be object')\n\n  defaults(options)\n\n  rimraf_(p, options, function CB (er) {\n    if (er) {\n      if ((er.code === 'EBUSY' || er.code === 'ENOTEMPTY' || er.code === 'EPERM') &&\n          busyTries < options.maxBusyTries) {\n        busyTries++\n        const time = busyTries * 100\n        // try again, with the same exact callback as this one.\n        return setTimeout(() => rimraf_(p, options, CB), time)\n      }\n\n      // already gone\n      if (er.code === 'ENOENT') er = null\n    }\n\n    cb(er)\n  })\n}\n\n// Two possible strategies.\n// 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR\n// 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR\n//\n// Both result in an extra syscall when you guess wrong.  However, there\n// are likely far more normal files in the world than directories.  This\n// is based on the assumption that a the average number of files per\n// directory is >= 1.\n//\n// If anyone ever complains about this, then I guess the strategy could\n// be made configurable somehow.  But until then, YAGNI.\nfunction rimraf_ (p, options, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n\n  // sunos lets the root user unlink directories, which is... weird.\n  // so we have to lstat here and make sure it's not a dir.\n  options.lstat(p, (er, st) => {\n    if (er && er.code === 'ENOENT') {\n      return cb(null)\n    }\n\n    // Windows can EPERM on stat.  Life is suffering.\n    if (er && er.code === 'EPERM' && isWindows) {\n      return fixWinEPERM(p, options, er, cb)\n    }\n\n    if (st && st.isDirectory()) {\n      return rmdir(p, options, er, cb)\n    }\n\n    options.unlink(p, er => {\n      if (er) {\n        if (er.code === 'ENOENT') {\n          return cb(null)\n        }\n        if (er.code === 'EPERM') {\n          return (isWindows)\n            ? fixWinEPERM(p, options, er, cb)\n            : rmdir(p, options, er, cb)\n        }\n        if (er.code === 'EISDIR') {\n          return rmdir(p, options, er, cb)\n        }\n      }\n      return cb(er)\n    })\n  })\n}\n\nfunction fixWinEPERM (p, options, er, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n\n  options.chmod(p, 0o666, er2 => {\n    if (er2) {\n      cb(er2.code === 'ENOENT' ? null : er)\n    } else {\n      options.stat(p, (er3, stats) => {\n        if (er3) {\n          cb(er3.code === 'ENOENT' ? null : er)\n        } else if (stats.isDirectory()) {\n          rmdir(p, options, er, cb)\n        } else {\n          options.unlink(p, cb)\n        }\n      })\n    }\n  })\n}\n\nfunction fixWinEPERMSync (p, options, er) {\n  let stats\n\n  assert(p)\n  assert(options)\n\n  try {\n    options.chmodSync(p, 0o666)\n  } catch (er2) {\n    if (er2.code === 'ENOENT') {\n      return\n    } else {\n      throw er\n    }\n  }\n\n  try {\n    stats = options.statSync(p)\n  } catch (er3) {\n    if (er3.code === 'ENOENT') {\n      return\n    } else {\n      throw er\n    }\n  }\n\n  if (stats.isDirectory()) {\n    rmdirSync(p, options, er)\n  } else {\n    options.unlinkSync(p)\n  }\n}\n\nfunction rmdir (p, options, originalEr, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n\n  // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)\n  // if we guessed wrong, and it's not a directory, then\n  // raise the original error.\n  options.rmdir(p, er => {\n    if (er && (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM')) {\n      rmkids(p, options, cb)\n    } else if (er && er.code === 'ENOTDIR') {\n      cb(originalEr)\n    } else {\n      cb(er)\n    }\n  })\n}\n\nfunction rmkids (p, options, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n\n  options.readdir(p, (er, files) => {\n    if (er) return cb(er)\n\n    let n = files.length\n    let errState\n\n    if (n === 0) return options.rmdir(p, cb)\n\n    files.forEach(f => {\n      rimraf(path.join(p, f), options, er => {\n        if (errState) {\n          return\n        }\n        if (er) return cb(errState = er)\n        if (--n === 0) {\n          options.rmdir(p, cb)\n        }\n      })\n    })\n  })\n}\n\n// this looks simpler, and is strictly *faster*, but will\n// tie up the JavaScript thread and fail on excessively\n// deep directory trees.\nfunction rimrafSync (p, options) {\n  let st\n\n  options = options || {}\n  defaults(options)\n\n  assert(p, 'rimraf: missing path')\n  assert.strictEqual(typeof p, 'string', 'rimraf: path should be a string')\n  assert(options, 'rimraf: missing options')\n  assert.strictEqual(typeof options, 'object', 'rimraf: options should be object')\n\n  try {\n    st = options.lstatSync(p)\n  } catch (er) {\n    if (er.code === 'ENOENT') {\n      return\n    }\n\n    // Windows can EPERM on stat.  Life is suffering.\n    if (er.code === 'EPERM' && isWindows) {\n      fixWinEPERMSync(p, options, er)\n    }\n  }\n\n  try {\n    // sunos lets the root user unlink directories, which is... weird.\n    if (st && st.isDirectory()) {\n      rmdirSync(p, options, null)\n    } else {\n      options.unlinkSync(p)\n    }\n  } catch (er) {\n    if (er.code === 'ENOENT') {\n      return\n    } else if (er.code === 'EPERM') {\n      return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er)\n    } else if (er.code !== 'EISDIR') {\n      throw er\n    }\n    rmdirSync(p, options, er)\n  }\n}\n\nfunction rmdirSync (p, options, originalEr) {\n  assert(p)\n  assert(options)\n\n  try {\n    options.rmdirSync(p)\n  } catch (er) {\n    if (er.code === 'ENOTDIR') {\n      throw originalEr\n    } else if (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM') {\n      rmkidsSync(p, options)\n    } else if (er.code !== 'ENOENT') {\n      throw er\n    }\n  }\n}\n\nfunction rmkidsSync (p, options) {\n  assert(p)\n  assert(options)\n  options.readdirSync(p).forEach(f => rimrafSync(path.join(p, f), options))\n\n  if (isWindows) {\n    // We only end up here once we got ENOTEMPTY at least once, and\n    // at this point, we are guaranteed to have removed all the kids.\n    // So, we know that it won't be ENOENT or ENOTDIR or anything else.\n    // try really hard to delete stuff on windows, because it has a\n    // PROFOUNDLY annoying habit of not closing handles promptly when\n    // files are deleted, resulting in spurious ENOTEMPTY errors.\n    const startTime = Date.now()\n    do {\n      try {\n        const ret = options.rmdirSync(p, options)\n        return ret\n      } catch {}\n    } while (Date.now() - startTime < 500) // give up after 500ms\n  } else {\n    const ret = options.rmdirSync(p, options)\n    return ret\n  }\n}\n\nmodule.exports = rimraf\nrimraf.sync = rimrafSync\n","'use strict'\n\nconst fs = require('../fs')\nconst path = require('path')\nconst util = require('util')\nconst atLeastNode = require('at-least-node')\n\nconst nodeSupportsBigInt = atLeastNode('10.5.0')\nconst stat = (file) => nodeSupportsBigInt ? fs.stat(file, { bigint: true }) : fs.stat(file)\nconst statSync = (file) => nodeSupportsBigInt ? fs.statSync(file, { bigint: true }) : fs.statSync(file)\n\nfunction getStats (src, dest) {\n  return Promise.all([\n    stat(src),\n    stat(dest).catch(err => {\n      if (err.code === 'ENOENT') return null\n      throw err\n    })\n  ]).then(([srcStat, destStat]) => ({ srcStat, destStat }))\n}\n\nfunction getStatsSync (src, dest) {\n  let destStat\n  const srcStat = statSync(src)\n  try {\n    destStat = statSync(dest)\n  } catch (err) {\n    if (err.code === 'ENOENT') return { srcStat, destStat: null }\n    throw err\n  }\n  return { srcStat, destStat }\n}\n\nfunction checkPaths (src, dest, funcName, cb) {\n  util.callbackify(getStats)(src, dest, (err, stats) => {\n    if (err) return cb(err)\n    const { srcStat, destStat } = stats\n    if (destStat && areIdentical(srcStat, destStat)) {\n      return cb(new Error('Source and destination must not be the same.'))\n    }\n    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n      return cb(new Error(errMsg(src, dest, funcName)))\n    }\n    return cb(null, { srcStat, destStat })\n  })\n}\n\nfunction checkPathsSync (src, dest, funcName) {\n  const { srcStat, destStat } = getStatsSync(src, dest)\n  if (destStat && areIdentical(srcStat, destStat)) {\n    throw new Error('Source and destination must not be the same.')\n  }\n  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n    throw new Error(errMsg(src, dest, funcName))\n  }\n  return { srcStat, destStat }\n}\n\n// recursively check if dest parent is a subdirectory of src.\n// It works for all file types including symlinks since it\n// checks the src and dest inodes. It starts from the deepest\n// parent and stops once it reaches the src parent or the root path.\nfunction checkParentPaths (src, srcStat, dest, funcName, cb) {\n  const srcParent = path.resolve(path.dirname(src))\n  const destParent = path.resolve(path.dirname(dest))\n  if (destParent === srcParent || destParent === path.parse(destParent).root) return cb()\n  const callback = (err, destStat) => {\n    if (err) {\n      if (err.code === 'ENOENT') return cb()\n      return cb(err)\n    }\n    if (areIdentical(srcStat, destStat)) {\n      return cb(new Error(errMsg(src, dest, funcName)))\n    }\n    return checkParentPaths(src, srcStat, destParent, funcName, cb)\n  }\n  if (nodeSupportsBigInt) fs.stat(destParent, { bigint: true }, callback)\n  else fs.stat(destParent, callback)\n}\n\nfunction checkParentPathsSync (src, srcStat, dest, funcName) {\n  const srcParent = path.resolve(path.dirname(src))\n  const destParent = path.resolve(path.dirname(dest))\n  if (destParent === srcParent || destParent === path.parse(destParent).root) return\n  let destStat\n  try {\n    destStat = statSync(destParent)\n  } catch (err) {\n    if (err.code === 'ENOENT') return\n    throw err\n  }\n  if (areIdentical(srcStat, destStat)) {\n    throw new Error(errMsg(src, dest, funcName))\n  }\n  return checkParentPathsSync(src, srcStat, destParent, funcName)\n}\n\nfunction areIdentical (srcStat, destStat) {\n  if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {\n    if (nodeSupportsBigInt || destStat.ino < Number.MAX_SAFE_INTEGER) {\n      // definitive answer\n      return true\n    }\n    // Use additional heuristics if we can't use 'bigint'.\n    // Different 'ino' could be represented the same if they are >= Number.MAX_SAFE_INTEGER\n    // See issue 657\n    if (destStat.size === srcStat.size &&\n        destStat.mode === srcStat.mode &&\n        destStat.nlink === srcStat.nlink &&\n        destStat.atimeMs === srcStat.atimeMs &&\n        destStat.mtimeMs === srcStat.mtimeMs &&\n        destStat.ctimeMs === srcStat.ctimeMs &&\n        destStat.birthtimeMs === srcStat.birthtimeMs) {\n      // heuristic answer\n      return true\n    }\n  }\n  return false\n}\n\n// return true if dest is a subdir of src, otherwise false.\n// It only checks the path strings.\nfunction isSrcSubdir (src, dest) {\n  const srcArr = path.resolve(src).split(path.sep).filter(i => i)\n  const destArr = path.resolve(dest).split(path.sep).filter(i => i)\n  return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, true)\n}\n\nfunction errMsg (src, dest, funcName) {\n  return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`\n}\n\nmodule.exports = {\n  checkPaths,\n  checkPathsSync,\n  checkParentPaths,\n  checkParentPathsSync,\n  isSrcSubdir\n}\n","'use strict'\n\nconst fs = require('graceful-fs')\n\nfunction utimesMillis (path, atime, mtime, callback) {\n  // if (!HAS_MILLIS_RES) return fs.utimes(path, atime, mtime, callback)\n  fs.open(path, 'r+', (err, fd) => {\n    if (err) return callback(err)\n    fs.futimes(fd, atime, mtime, futimesErr => {\n      fs.close(fd, closeErr => {\n        if (callback) callback(futimesErr || closeErr)\n      })\n    })\n  })\n}\n\nfunction utimesMillisSync (path, atime, mtime) {\n  const fd = fs.openSync(path, 'r+')\n  fs.futimesSync(fd, atime, mtime)\n  return fs.closeSync(fd)\n}\n\nmodule.exports = {\n  utimesMillis,\n  utimesMillisSync\n}\n","module.exports = realpath\nrealpath.realpath = realpath\nrealpath.sync = realpathSync\nrealpath.realpathSync = realpathSync\nrealpath.monkeypatch = monkeypatch\nrealpath.unmonkeypatch = unmonkeypatch\n\nvar fs = require('fs')\nvar origRealpath = fs.realpath\nvar origRealpathSync = fs.realpathSync\n\nvar version = process.version\nvar ok = /^v[0-5]\\./.test(version)\nvar old = require('./old.js')\n\nfunction newError (er) {\n  return er && er.syscall === 'realpath' && (\n    er.code === 'ELOOP' ||\n    er.code === 'ENOMEM' ||\n    er.code === 'ENAMETOOLONG'\n  )\n}\n\nfunction realpath (p, cache, cb) {\n  if (ok) {\n    return origRealpath(p, cache, cb)\n  }\n\n  if (typeof cache === 'function') {\n    cb = cache\n    cache = null\n  }\n  origRealpath(p, cache, function (er, result) {\n    if (newError(er)) {\n      old.realpath(p, cache, cb)\n    } else {\n      cb(er, result)\n    }\n  })\n}\n\nfunction realpathSync (p, cache) {\n  if (ok) {\n    return origRealpathSync(p, cache)\n  }\n\n  try {\n    return origRealpathSync(p, cache)\n  } catch (er) {\n    if (newError(er)) {\n      return old.realpathSync(p, cache)\n    } else {\n      throw er\n    }\n  }\n}\n\nfunction monkeypatch () {\n  fs.realpath = realpath\n  fs.realpathSync = realpathSync\n}\n\nfunction unmonkeypatch () {\n  fs.realpath = origRealpath\n  fs.realpathSync = origRealpathSync\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar pathModule = require('path');\nvar isWindows = process.platform === 'win32';\nvar fs = require('fs');\n\n// JavaScript implementation of realpath, ported from node pre-v6\n\nvar DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);\n\nfunction rethrow() {\n  // Only enable in debug mode. A backtrace uses ~1000 bytes of heap space and\n  // is fairly slow to generate.\n  var callback;\n  if (DEBUG) {\n    var backtrace = new Error;\n    callback = debugCallback;\n  } else\n    callback = missingCallback;\n\n  return callback;\n\n  function debugCallback(err) {\n    if (err) {\n      backtrace.message = err.message;\n      err = backtrace;\n      missingCallback(err);\n    }\n  }\n\n  function missingCallback(err) {\n    if (err) {\n      if (process.throwDeprecation)\n        throw err;  // Forgot a callback but don't know where? Use NODE_DEBUG=fs\n      else if (!process.noDeprecation) {\n        var msg = 'fs: missing callback ' + (err.stack || err.message);\n        if (process.traceDeprecation)\n          console.trace(msg);\n        else\n          console.error(msg);\n      }\n    }\n  }\n}\n\nfunction maybeCallback(cb) {\n  return typeof cb === 'function' ? cb : rethrow();\n}\n\nvar normalize = pathModule.normalize;\n\n// Regexp that finds the next partion of a (partial) path\n// result is [base_with_slash, base], e.g. ['somedir/', 'somedir']\nif (isWindows) {\n  var nextPartRe = /(.*?)(?:[\\/\\\\]+|$)/g;\n} else {\n  var nextPartRe = /(.*?)(?:[\\/]+|$)/g;\n}\n\n// Regex to find the device root, including trailing slash. E.g. 'c:\\\\'.\nif (isWindows) {\n  var splitRootRe = /^(?:[a-zA-Z]:|[\\\\\\/]{2}[^\\\\\\/]+[\\\\\\/][^\\\\\\/]+)?[\\\\\\/]*/;\n} else {\n  var splitRootRe = /^[\\/]*/;\n}\n\nexports.realpathSync = function realpathSync(p, cache) {\n  // make p is absolute\n  p = pathModule.resolve(p);\n\n  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {\n    return cache[p];\n  }\n\n  var original = p,\n      seenLinks = {},\n      knownHard = {};\n\n  // current character position in p\n  var pos;\n  // the partial path so far, including a trailing slash if any\n  var current;\n  // the partial path without a trailing slash (except when pointing at a root)\n  var base;\n  // the partial path scanned in the previous round, with slash\n  var previous;\n\n  start();\n\n  function start() {\n    // Skip over roots\n    var m = splitRootRe.exec(p);\n    pos = m[0].length;\n    current = m[0];\n    base = m[0];\n    previous = '';\n\n    // On windows, check that the root exists. On unix there is no need.\n    if (isWindows && !knownHard[base]) {\n      fs.lstatSync(base);\n      knownHard[base] = true;\n    }\n  }\n\n  // walk down the path, swapping out linked pathparts for their real\n  // values\n  // NB: p.length changes.\n  while (pos < p.length) {\n    // find the next part\n    nextPartRe.lastIndex = pos;\n    var result = nextPartRe.exec(p);\n    previous = current;\n    current += result[0];\n    base = previous + result[1];\n    pos = nextPartRe.lastIndex;\n\n    // continue if not a symlink\n    if (knownHard[base] || (cache && cache[base] === base)) {\n      continue;\n    }\n\n    var resolvedLink;\n    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {\n      // some known symbolic link.  no need to stat again.\n      resolvedLink = cache[base];\n    } else {\n      var stat = fs.lstatSync(base);\n      if (!stat.isSymbolicLink()) {\n        knownHard[base] = true;\n        if (cache) cache[base] = base;\n        continue;\n      }\n\n      // read the link if it wasn't read before\n      // dev/ino always return 0 on windows, so skip the check.\n      var linkTarget = null;\n      if (!isWindows) {\n        var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);\n        if (seenLinks.hasOwnProperty(id)) {\n          linkTarget = seenLinks[id];\n        }\n      }\n      if (linkTarget === null) {\n        fs.statSync(base);\n        linkTarget = fs.readlinkSync(base);\n      }\n      resolvedLink = pathModule.resolve(previous, linkTarget);\n      // track this, if given a cache.\n      if (cache) cache[base] = resolvedLink;\n      if (!isWindows) seenLinks[id] = linkTarget;\n    }\n\n    // resolve the link, then start over\n    p = pathModule.resolve(resolvedLink, p.slice(pos));\n    start();\n  }\n\n  if (cache) cache[original] = p;\n\n  return p;\n};\n\n\nexports.realpath = function realpath(p, cache, cb) {\n  if (typeof cb !== 'function') {\n    cb = maybeCallback(cache);\n    cache = null;\n  }\n\n  // make p is absolute\n  p = pathModule.resolve(p);\n\n  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {\n    return process.nextTick(cb.bind(null, null, cache[p]));\n  }\n\n  var original = p,\n      seenLinks = {},\n      knownHard = {};\n\n  // current character position in p\n  var pos;\n  // the partial path so far, including a trailing slash if any\n  var current;\n  // the partial path without a trailing slash (except when pointing at a root)\n  var base;\n  // the partial path scanned in the previous round, with slash\n  var previous;\n\n  start();\n\n  function start() {\n    // Skip over roots\n    var m = splitRootRe.exec(p);\n    pos = m[0].length;\n    current = m[0];\n    base = m[0];\n    previous = '';\n\n    // On windows, check that the root exists. On unix there is no need.\n    if (isWindows && !knownHard[base]) {\n      fs.lstat(base, function(err) {\n        if (err) return cb(err);\n        knownHard[base] = true;\n        LOOP();\n      });\n    } else {\n      process.nextTick(LOOP);\n    }\n  }\n\n  // walk down the path, swapping out linked pathparts for their real\n  // values\n  function LOOP() {\n    // stop if scanned past end of path\n    if (pos >= p.length) {\n      if (cache) cache[original] = p;\n      return cb(null, p);\n    }\n\n    // find the next part\n    nextPartRe.lastIndex = pos;\n    var result = nextPartRe.exec(p);\n    previous = current;\n    current += result[0];\n    base = previous + result[1];\n    pos = nextPartRe.lastIndex;\n\n    // continue if not a symlink\n    if (knownHard[base] || (cache && cache[base] === base)) {\n      return process.nextTick(LOOP);\n    }\n\n    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {\n      // known symbolic link.  no need to stat again.\n      return gotResolvedLink(cache[base]);\n    }\n\n    return fs.lstat(base, gotStat);\n  }\n\n  function gotStat(err, stat) {\n    if (err) return cb(err);\n\n    // if not a symlink, skip to the next path part\n    if (!stat.isSymbolicLink()) {\n      knownHard[base] = true;\n      if (cache) cache[base] = base;\n      return process.nextTick(LOOP);\n    }\n\n    // stat & read the link if not read before\n    // call gotTarget as soon as the link target is known\n    // dev/ino always return 0 on windows, so skip the check.\n    if (!isWindows) {\n      var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);\n      if (seenLinks.hasOwnProperty(id)) {\n        return gotTarget(null, seenLinks[id], base);\n      }\n    }\n    fs.stat(base, function(err) {\n      if (err) return cb(err);\n\n      fs.readlink(base, function(err, target) {\n        if (!isWindows) seenLinks[id] = target;\n        gotTarget(err, target);\n      });\n    });\n  }\n\n  function gotTarget(err, target, base) {\n    if (err) return cb(err);\n\n    var resolvedLink = pathModule.resolve(previous, target);\n    if (cache) cache[base] = resolvedLink;\n    gotResolvedLink(resolvedLink);\n  }\n\n  function gotResolvedLink(resolvedLink) {\n    // resolve the link, then start over\n    p = pathModule.resolve(resolvedLink, p.slice(pos));\n    start();\n  }\n};\n","exports.alphasort = alphasort\nexports.alphasorti = alphasorti\nexports.setopts = setopts\nexports.ownProp = ownProp\nexports.makeAbs = makeAbs\nexports.finish = finish\nexports.mark = mark\nexports.isIgnored = isIgnored\nexports.childrenIgnored = childrenIgnored\n\nfunction ownProp (obj, field) {\n  return Object.prototype.hasOwnProperty.call(obj, field)\n}\n\nvar path = require(\"path\")\nvar minimatch = require(\"minimatch\")\nvar isAbsolute = require(\"path-is-absolute\")\nvar Minimatch = minimatch.Minimatch\n\nfunction alphasorti (a, b) {\n  return a.toLowerCase().localeCompare(b.toLowerCase())\n}\n\nfunction alphasort (a, b) {\n  return a.localeCompare(b)\n}\n\nfunction setupIgnores (self, options) {\n  self.ignore = options.ignore || []\n\n  if (!Array.isArray(self.ignore))\n    self.ignore = [self.ignore]\n\n  if (self.ignore.length) {\n    self.ignore = self.ignore.map(ignoreMap)\n  }\n}\n\n// ignore patterns are always in dot:true mode.\nfunction ignoreMap (pattern) {\n  var gmatcher = null\n  if (pattern.slice(-3) === '/**') {\n    var gpattern = pattern.replace(/(\\/\\*\\*)+$/, '')\n    gmatcher = new Minimatch(gpattern, { dot: true })\n  }\n\n  return {\n    matcher: new Minimatch(pattern, { dot: true }),\n    gmatcher: gmatcher\n  }\n}\n\nfunction setopts (self, pattern, options) {\n  if (!options)\n    options = {}\n\n  // base-matching: just use globstar for that.\n  if (options.matchBase && -1 === pattern.indexOf(\"/\")) {\n    if (options.noglobstar) {\n      throw new Error(\"base matching requires globstar\")\n    }\n    pattern = \"**/\" + pattern\n  }\n\n  self.silent = !!options.silent\n  self.pattern = pattern\n  self.strict = options.strict !== false\n  self.realpath = !!options.realpath\n  self.realpathCache = options.realpathCache || Object.create(null)\n  self.follow = !!options.follow\n  self.dot = !!options.dot\n  self.mark = !!options.mark\n  self.nodir = !!options.nodir\n  if (self.nodir)\n    self.mark = true\n  self.sync = !!options.sync\n  self.nounique = !!options.nounique\n  self.nonull = !!options.nonull\n  self.nosort = !!options.nosort\n  self.nocase = !!options.nocase\n  self.stat = !!options.stat\n  self.noprocess = !!options.noprocess\n  self.absolute = !!options.absolute\n\n  self.maxLength = options.maxLength || Infinity\n  self.cache = options.cache || Object.create(null)\n  self.statCache = options.statCache || Object.create(null)\n  self.symlinks = options.symlinks || Object.create(null)\n\n  setupIgnores(self, options)\n\n  self.changedCwd = false\n  var cwd = process.cwd()\n  if (!ownProp(options, \"cwd\"))\n    self.cwd = cwd\n  else {\n    self.cwd = path.resolve(options.cwd)\n    self.changedCwd = self.cwd !== cwd\n  }\n\n  self.root = options.root || path.resolve(self.cwd, \"/\")\n  self.root = path.resolve(self.root)\n  if (process.platform === \"win32\")\n    self.root = self.root.replace(/\\\\/g, \"/\")\n\n  // TODO: is an absolute `cwd` supposed to be resolved against `root`?\n  // e.g. { cwd: '/test', root: __dirname } === path.join(__dirname, '/test')\n  self.cwdAbs = isAbsolute(self.cwd) ? self.cwd : makeAbs(self, self.cwd)\n  if (process.platform === \"win32\")\n    self.cwdAbs = self.cwdAbs.replace(/\\\\/g, \"/\")\n  self.nomount = !!options.nomount\n\n  // disable comments and negation in Minimatch.\n  // Note that they are not supported in Glob itself anyway.\n  options.nonegate = true\n  options.nocomment = true\n\n  self.minimatch = new Minimatch(pattern, options)\n  self.options = self.minimatch.options\n}\n\nfunction finish (self) {\n  var nou = self.nounique\n  var all = nou ? [] : Object.create(null)\n\n  for (var i = 0, l = self.matches.length; i < l; i ++) {\n    var matches = self.matches[i]\n    if (!matches || Object.keys(matches).length === 0) {\n      if (self.nonull) {\n        // do like the shell, and spit out the literal glob\n        var literal = self.minimatch.globSet[i]\n        if (nou)\n          all.push(literal)\n        else\n          all[literal] = true\n      }\n    } else {\n      // had matches\n      var m = Object.keys(matches)\n      if (nou)\n        all.push.apply(all, m)\n      else\n        m.forEach(function (m) {\n          all[m] = true\n        })\n    }\n  }\n\n  if (!nou)\n    all = Object.keys(all)\n\n  if (!self.nosort)\n    all = all.sort(self.nocase ? alphasorti : alphasort)\n\n  // at *some* point we statted all of these\n  if (self.mark) {\n    for (var i = 0; i < all.length; i++) {\n      all[i] = self._mark(all[i])\n    }\n    if (self.nodir) {\n      all = all.filter(function (e) {\n        var notDir = !(/\\/$/.test(e))\n        var c = self.cache[e] || self.cache[makeAbs(self, e)]\n        if (notDir && c)\n          notDir = c !== 'DIR' && !Array.isArray(c)\n        return notDir\n      })\n    }\n  }\n\n  if (self.ignore.length)\n    all = all.filter(function(m) {\n      return !isIgnored(self, m)\n    })\n\n  self.found = all\n}\n\nfunction mark (self, p) {\n  var abs = makeAbs(self, p)\n  var c = self.cache[abs]\n  var m = p\n  if (c) {\n    var isDir = c === 'DIR' || Array.isArray(c)\n    var slash = p.slice(-1) === '/'\n\n    if (isDir && !slash)\n      m += '/'\n    else if (!isDir && slash)\n      m = m.slice(0, -1)\n\n    if (m !== p) {\n      var mabs = makeAbs(self, m)\n      self.statCache[mabs] = self.statCache[abs]\n      self.cache[mabs] = self.cache[abs]\n    }\n  }\n\n  return m\n}\n\n// lotta situps...\nfunction makeAbs (self, f) {\n  var abs = f\n  if (f.charAt(0) === '/') {\n    abs = path.join(self.root, f)\n  } else if (isAbsolute(f) || f === '') {\n    abs = f\n  } else if (self.changedCwd) {\n    abs = path.resolve(self.cwd, f)\n  } else {\n    abs = path.resolve(f)\n  }\n\n  if (process.platform === 'win32')\n    abs = abs.replace(/\\\\/g, '/')\n\n  return abs\n}\n\n\n// Return true, if pattern ends with globstar '**', for the accompanying parent directory.\n// Ex:- If node_modules/** is the pattern, add 'node_modules' to ignore list along with it's contents\nfunction isIgnored (self, path) {\n  if (!self.ignore.length)\n    return false\n\n  return self.ignore.some(function(item) {\n    return item.matcher.match(path) || !!(item.gmatcher && item.gmatcher.match(path))\n  })\n}\n\nfunction childrenIgnored (self, path) {\n  if (!self.ignore.length)\n    return false\n\n  return self.ignore.some(function(item) {\n    return !!(item.gmatcher && item.gmatcher.match(path))\n  })\n}\n","// Approach:\n//\n// 1. Get the minimatch set\n// 2. For each pattern in the set, PROCESS(pattern, false)\n// 3. Store matches per-set, then uniq them\n//\n// PROCESS(pattern, inGlobStar)\n// Get the first [n] items from pattern that are all strings\n// Join these together.  This is PREFIX.\n//   If there is no more remaining, then stat(PREFIX) and\n//   add to matches if it succeeds.  END.\n//\n// If inGlobStar and PREFIX is symlink and points to dir\n//   set ENTRIES = []\n// else readdir(PREFIX) as ENTRIES\n//   If fail, END\n//\n// with ENTRIES\n//   If pattern[n] is GLOBSTAR\n//     // handle the case where the globstar match is empty\n//     // by pruning it out, and testing the resulting pattern\n//     PROCESS(pattern[0..n] + pattern[n+1 .. $], false)\n//     // handle other cases.\n//     for ENTRY in ENTRIES (not dotfiles)\n//       // attach globstar + tail onto the entry\n//       // Mark that this entry is a globstar match\n//       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $], true)\n//\n//   else // not globstar\n//     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)\n//       Test ENTRY against pattern[n]\n//       If fails, continue\n//       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])\n//\n// Caveat:\n//   Cache all stats and readdirs results to minimize syscall.  Since all\n//   we ever care about is existence and directory-ness, we can just keep\n//   `true` for files, and [children,...] for directories, or `false` for\n//   things that don't exist.\n\nmodule.exports = glob\n\nvar fs = require('fs')\nvar rp = require('fs.realpath')\nvar minimatch = require('minimatch')\nvar Minimatch = minimatch.Minimatch\nvar inherits = require('inherits')\nvar EE = require('events').EventEmitter\nvar path = require('path')\nvar assert = require('assert')\nvar isAbsolute = require('path-is-absolute')\nvar globSync = require('./sync.js')\nvar common = require('./common.js')\nvar alphasort = common.alphasort\nvar alphasorti = common.alphasorti\nvar setopts = common.setopts\nvar ownProp = common.ownProp\nvar inflight = require('inflight')\nvar util = require('util')\nvar childrenIgnored = common.childrenIgnored\nvar isIgnored = common.isIgnored\n\nvar once = require('once')\n\nfunction glob (pattern, options, cb) {\n  if (typeof options === 'function') cb = options, options = {}\n  if (!options) options = {}\n\n  if (options.sync) {\n    if (cb)\n      throw new TypeError('callback provided to sync glob')\n    return globSync(pattern, options)\n  }\n\n  return new Glob(pattern, options, cb)\n}\n\nglob.sync = globSync\nvar GlobSync = glob.GlobSync = globSync.GlobSync\n\n// old api surface\nglob.glob = glob\n\nfunction extend (origin, add) {\n  if (add === null || typeof add !== 'object') {\n    return origin\n  }\n\n  var keys = Object.keys(add)\n  var i = keys.length\n  while (i--) {\n    origin[keys[i]] = add[keys[i]]\n  }\n  return origin\n}\n\nglob.hasMagic = function (pattern, options_) {\n  var options = extend({}, options_)\n  options.noprocess = true\n\n  var g = new Glob(pattern, options)\n  var set = g.minimatch.set\n\n  if (!pattern)\n    return false\n\n  if (set.length > 1)\n    return true\n\n  for (var j = 0; j < set[0].length; j++) {\n    if (typeof set[0][j] !== 'string')\n      return true\n  }\n\n  return false\n}\n\nglob.Glob = Glob\ninherits(Glob, EE)\nfunction Glob (pattern, options, cb) {\n  if (typeof options === 'function') {\n    cb = options\n    options = null\n  }\n\n  if (options && options.sync) {\n    if (cb)\n      throw new TypeError('callback provided to sync glob')\n    return new GlobSync(pattern, options)\n  }\n\n  if (!(this instanceof Glob))\n    return new Glob(pattern, options, cb)\n\n  setopts(this, pattern, options)\n  this._didRealPath = false\n\n  // process each pattern in the minimatch set\n  var n = this.minimatch.set.length\n\n  // The matches are stored as {<filename>: true,...} so that\n  // duplicates are automagically pruned.\n  // Later, we do an Object.keys() on these.\n  // Keep them as a list so we can fill in when nonull is set.\n  this.matches = new Array(n)\n\n  if (typeof cb === 'function') {\n    cb = once(cb)\n    this.on('error', cb)\n    this.on('end', function (matches) {\n      cb(null, matches)\n    })\n  }\n\n  var self = this\n  this._processing = 0\n\n  this._emitQueue = []\n  this._processQueue = []\n  this.paused = false\n\n  if (this.noprocess)\n    return this\n\n  if (n === 0)\n    return done()\n\n  var sync = true\n  for (var i = 0; i < n; i ++) {\n    this._process(this.minimatch.set[i], i, false, done)\n  }\n  sync = false\n\n  function done () {\n    --self._processing\n    if (self._processing <= 0) {\n      if (sync) {\n        process.nextTick(function () {\n          self._finish()\n        })\n      } else {\n        self._finish()\n      }\n    }\n  }\n}\n\nGlob.prototype._finish = function () {\n  assert(this instanceof Glob)\n  if (this.aborted)\n    return\n\n  if (this.realpath && !this._didRealpath)\n    return this._realpath()\n\n  common.finish(this)\n  this.emit('end', this.found)\n}\n\nGlob.prototype._realpath = function () {\n  if (this._didRealpath)\n    return\n\n  this._didRealpath = true\n\n  var n = this.matches.length\n  if (n === 0)\n    return this._finish()\n\n  var self = this\n  for (var i = 0; i < this.matches.length; i++)\n    this._realpathSet(i, next)\n\n  function next () {\n    if (--n === 0)\n      self._finish()\n  }\n}\n\nGlob.prototype._realpathSet = function (index, cb) {\n  var matchset = this.matches[index]\n  if (!matchset)\n    return cb()\n\n  var found = Object.keys(matchset)\n  var self = this\n  var n = found.length\n\n  if (n === 0)\n    return cb()\n\n  var set = this.matches[index] = Object.create(null)\n  found.forEach(function (p, i) {\n    // If there's a problem with the stat, then it means that\n    // one or more of the links in the realpath couldn't be\n    // resolved.  just return the abs value in that case.\n    p = self._makeAbs(p)\n    rp.realpath(p, self.realpathCache, function (er, real) {\n      if (!er)\n        set[real] = true\n      else if (er.syscall === 'stat')\n        set[p] = true\n      else\n        self.emit('error', er) // srsly wtf right here\n\n      if (--n === 0) {\n        self.matches[index] = set\n        cb()\n      }\n    })\n  })\n}\n\nGlob.prototype._mark = function (p) {\n  return common.mark(this, p)\n}\n\nGlob.prototype._makeAbs = function (f) {\n  return common.makeAbs(this, f)\n}\n\nGlob.prototype.abort = function () {\n  this.aborted = true\n  this.emit('abort')\n}\n\nGlob.prototype.pause = function () {\n  if (!this.paused) {\n    this.paused = true\n    this.emit('pause')\n  }\n}\n\nGlob.prototype.resume = function () {\n  if (this.paused) {\n    this.emit('resume')\n    this.paused = false\n    if (this._emitQueue.length) {\n      var eq = this._emitQueue.slice(0)\n      this._emitQueue.length = 0\n      for (var i = 0; i < eq.length; i ++) {\n        var e = eq[i]\n        this._emitMatch(e[0], e[1])\n      }\n    }\n    if (this._processQueue.length) {\n      var pq = this._processQueue.slice(0)\n      this._processQueue.length = 0\n      for (var i = 0; i < pq.length; i ++) {\n        var p = pq[i]\n        this._processing--\n        this._process(p[0], p[1], p[2], p[3])\n      }\n    }\n  }\n}\n\nGlob.prototype._process = function (pattern, index, inGlobStar, cb) {\n  assert(this instanceof Glob)\n  assert(typeof cb === 'function')\n\n  if (this.aborted)\n    return\n\n  this._processing++\n  if (this.paused) {\n    this._processQueue.push([pattern, index, inGlobStar, cb])\n    return\n  }\n\n  //console.error('PROCESS %d', this._processing, pattern)\n\n  // Get the first [n] parts of pattern that are all strings.\n  var n = 0\n  while (typeof pattern[n] === 'string') {\n    n ++\n  }\n  // now n is the index of the first one that is *not* a string.\n\n  // see if there's anything else\n  var prefix\n  switch (n) {\n    // if not, then this is rather simple\n    case pattern.length:\n      this._processSimple(pattern.join('/'), index, cb)\n      return\n\n    case 0:\n      // pattern *starts* with some non-trivial item.\n      // going to readdir(cwd), but not include the prefix in matches.\n      prefix = null\n      break\n\n    default:\n      // pattern has some string bits in the front.\n      // whatever it starts with, whether that's 'absolute' like /foo/bar,\n      // or 'relative' like '../baz'\n      prefix = pattern.slice(0, n).join('/')\n      break\n  }\n\n  var remain = pattern.slice(n)\n\n  // get the list of entries.\n  var read\n  if (prefix === null)\n    read = '.'\n  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {\n    if (!prefix || !isAbsolute(prefix))\n      prefix = '/' + prefix\n    read = prefix\n  } else\n    read = prefix\n\n  var abs = this._makeAbs(read)\n\n  //if ignored, skip _processing\n  if (childrenIgnored(this, read))\n    return cb()\n\n  var isGlobStar = remain[0] === minimatch.GLOBSTAR\n  if (isGlobStar)\n    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb)\n  else\n    this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb)\n}\n\nGlob.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar, cb) {\n  var self = this\n  this._readdir(abs, inGlobStar, function (er, entries) {\n    return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb)\n  })\n}\n\nGlob.prototype._processReaddir2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {\n\n  // if the abs isn't a dir, then nothing can match!\n  if (!entries)\n    return cb()\n\n  // It will only match dot entries if it starts with a dot, or if\n  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.\n  var pn = remain[0]\n  var negate = !!this.minimatch.negate\n  var rawGlob = pn._glob\n  var dotOk = this.dot || rawGlob.charAt(0) === '.'\n\n  var matchedEntries = []\n  for (var i = 0; i < entries.length; i++) {\n    var e = entries[i]\n    if (e.charAt(0) !== '.' || dotOk) {\n      var m\n      if (negate && !prefix) {\n        m = !e.match(pn)\n      } else {\n        m = e.match(pn)\n      }\n      if (m)\n        matchedEntries.push(e)\n    }\n  }\n\n  //console.error('prd2', prefix, entries, remain[0]._glob, matchedEntries)\n\n  var len = matchedEntries.length\n  // If there are no matched entries, then nothing matches.\n  if (len === 0)\n    return cb()\n\n  // if this is the last remaining pattern bit, then no need for\n  // an additional stat *unless* the user has specified mark or\n  // stat explicitly.  We know they exist, since readdir returned\n  // them.\n\n  if (remain.length === 1 && !this.mark && !this.stat) {\n    if (!this.matches[index])\n      this.matches[index] = Object.create(null)\n\n    for (var i = 0; i < len; i ++) {\n      var e = matchedEntries[i]\n      if (prefix) {\n        if (prefix !== '/')\n          e = prefix + '/' + e\n        else\n          e = prefix + e\n      }\n\n      if (e.charAt(0) === '/' && !this.nomount) {\n        e = path.join(this.root, e)\n      }\n      this._emitMatch(index, e)\n    }\n    // This was the last one, and no stats were needed\n    return cb()\n  }\n\n  // now test all matched entries as stand-ins for that part\n  // of the pattern.\n  remain.shift()\n  for (var i = 0; i < len; i ++) {\n    var e = matchedEntries[i]\n    var newPattern\n    if (prefix) {\n      if (prefix !== '/')\n        e = prefix + '/' + e\n      else\n        e = prefix + e\n    }\n    this._process([e].concat(remain), index, inGlobStar, cb)\n  }\n  cb()\n}\n\nGlob.prototype._emitMatch = function (index, e) {\n  if (this.aborted)\n    return\n\n  if (isIgnored(this, e))\n    return\n\n  if (this.paused) {\n    this._emitQueue.push([index, e])\n    return\n  }\n\n  var abs = isAbsolute(e) ? e : this._makeAbs(e)\n\n  if (this.mark)\n    e = this._mark(e)\n\n  if (this.absolute)\n    e = abs\n\n  if (this.matches[index][e])\n    return\n\n  if (this.nodir) {\n    var c = this.cache[abs]\n    if (c === 'DIR' || Array.isArray(c))\n      return\n  }\n\n  this.matches[index][e] = true\n\n  var st = this.statCache[abs]\n  if (st)\n    this.emit('stat', e, st)\n\n  this.emit('match', e)\n}\n\nGlob.prototype._readdirInGlobStar = function (abs, cb) {\n  if (this.aborted)\n    return\n\n  // follow all symlinked directories forever\n  // just proceed as if this is a non-globstar situation\n  if (this.follow)\n    return this._readdir(abs, false, cb)\n\n  var lstatkey = 'lstat\\0' + abs\n  var self = this\n  var lstatcb = inflight(lstatkey, lstatcb_)\n\n  if (lstatcb)\n    fs.lstat(abs, lstatcb)\n\n  function lstatcb_ (er, lstat) {\n    if (er && er.code === 'ENOENT')\n      return cb()\n\n    var isSym = lstat && lstat.isSymbolicLink()\n    self.symlinks[abs] = isSym\n\n    // If it's not a symlink or a dir, then it's definitely a regular file.\n    // don't bother doing a readdir in that case.\n    if (!isSym && lstat && !lstat.isDirectory()) {\n      self.cache[abs] = 'FILE'\n      cb()\n    } else\n      self._readdir(abs, false, cb)\n  }\n}\n\nGlob.prototype._readdir = function (abs, inGlobStar, cb) {\n  if (this.aborted)\n    return\n\n  cb = inflight('readdir\\0'+abs+'\\0'+inGlobStar, cb)\n  if (!cb)\n    return\n\n  //console.error('RD %j %j', +inGlobStar, abs)\n  if (inGlobStar && !ownProp(this.symlinks, abs))\n    return this._readdirInGlobStar(abs, cb)\n\n  if (ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n    if (!c || c === 'FILE')\n      return cb()\n\n    if (Array.isArray(c))\n      return cb(null, c)\n  }\n\n  var self = this\n  fs.readdir(abs, readdirCb(this, abs, cb))\n}\n\nfunction readdirCb (self, abs, cb) {\n  return function (er, entries) {\n    if (er)\n      self._readdirError(abs, er, cb)\n    else\n      self._readdirEntries(abs, entries, cb)\n  }\n}\n\nGlob.prototype._readdirEntries = function (abs, entries, cb) {\n  if (this.aborted)\n    return\n\n  // if we haven't asked to stat everything, then just\n  // assume that everything in there exists, so we can avoid\n  // having to stat it a second time.\n  if (!this.mark && !this.stat) {\n    for (var i = 0; i < entries.length; i ++) {\n      var e = entries[i]\n      if (abs === '/')\n        e = abs + e\n      else\n        e = abs + '/' + e\n      this.cache[e] = true\n    }\n  }\n\n  this.cache[abs] = entries\n  return cb(null, entries)\n}\n\nGlob.prototype._readdirError = function (f, er, cb) {\n  if (this.aborted)\n    return\n\n  // handle errors, and cache the information\n  switch (er.code) {\n    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205\n    case 'ENOTDIR': // totally normal. means it *does* exist.\n      var abs = this._makeAbs(f)\n      this.cache[abs] = 'FILE'\n      if (abs === this.cwdAbs) {\n        var error = new Error(er.code + ' invalid cwd ' + this.cwd)\n        error.path = this.cwd\n        error.code = er.code\n        this.emit('error', error)\n        this.abort()\n      }\n      break\n\n    case 'ENOENT': // not terribly unusual\n    case 'ELOOP':\n    case 'ENAMETOOLONG':\n    case 'UNKNOWN':\n      this.cache[this._makeAbs(f)] = false\n      break\n\n    default: // some unusual error.  Treat as failure.\n      this.cache[this._makeAbs(f)] = false\n      if (this.strict) {\n        this.emit('error', er)\n        // If the error is handled, then we abort\n        // if not, we threw out of here\n        this.abort()\n      }\n      if (!this.silent)\n        console.error('glob error', er)\n      break\n  }\n\n  return cb()\n}\n\nGlob.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar, cb) {\n  var self = this\n  this._readdir(abs, inGlobStar, function (er, entries) {\n    self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb)\n  })\n}\n\n\nGlob.prototype._processGlobStar2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {\n  //console.error('pgs2', prefix, remain[0], entries)\n\n  // no entries means not a dir, so it can never have matches\n  // foo.txt/** doesn't match foo.txt\n  if (!entries)\n    return cb()\n\n  // test without the globstar, and with every child both below\n  // and replacing the globstar.\n  var remainWithoutGlobStar = remain.slice(1)\n  var gspref = prefix ? [ prefix ] : []\n  var noGlobStar = gspref.concat(remainWithoutGlobStar)\n\n  // the noGlobStar pattern exits the inGlobStar state\n  this._process(noGlobStar, index, false, cb)\n\n  var isSym = this.symlinks[abs]\n  var len = entries.length\n\n  // If it's a symlink, and we're in a globstar, then stop\n  if (isSym && inGlobStar)\n    return cb()\n\n  for (var i = 0; i < len; i++) {\n    var e = entries[i]\n    if (e.charAt(0) === '.' && !this.dot)\n      continue\n\n    // these two cases enter the inGlobStar state\n    var instead = gspref.concat(entries[i], remainWithoutGlobStar)\n    this._process(instead, index, true, cb)\n\n    var below = gspref.concat(entries[i], remain)\n    this._process(below, index, true, cb)\n  }\n\n  cb()\n}\n\nGlob.prototype._processSimple = function (prefix, index, cb) {\n  // XXX review this.  Shouldn't it be doing the mounting etc\n  // before doing stat?  kinda weird?\n  var self = this\n  this._stat(prefix, function (er, exists) {\n    self._processSimple2(prefix, index, er, exists, cb)\n  })\n}\nGlob.prototype._processSimple2 = function (prefix, index, er, exists, cb) {\n\n  //console.error('ps2', prefix, exists)\n\n  if (!this.matches[index])\n    this.matches[index] = Object.create(null)\n\n  // If it doesn't exist, then just mark the lack of results\n  if (!exists)\n    return cb()\n\n  if (prefix && isAbsolute(prefix) && !this.nomount) {\n    var trail = /[\\/\\\\]$/.test(prefix)\n    if (prefix.charAt(0) === '/') {\n      prefix = path.join(this.root, prefix)\n    } else {\n      prefix = path.resolve(this.root, prefix)\n      if (trail)\n        prefix += '/'\n    }\n  }\n\n  if (process.platform === 'win32')\n    prefix = prefix.replace(/\\\\/g, '/')\n\n  // Mark this as a match\n  this._emitMatch(index, prefix)\n  cb()\n}\n\n// Returns either 'DIR', 'FILE', or false\nGlob.prototype._stat = function (f, cb) {\n  var abs = this._makeAbs(f)\n  var needDir = f.slice(-1) === '/'\n\n  if (f.length > this.maxLength)\n    return cb()\n\n  if (!this.stat && ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n\n    if (Array.isArray(c))\n      c = 'DIR'\n\n    // It exists, but maybe not how we need it\n    if (!needDir || c === 'DIR')\n      return cb(null, c)\n\n    if (needDir && c === 'FILE')\n      return cb()\n\n    // otherwise we have to stat, because maybe c=true\n    // if we know it exists, but not what it is.\n  }\n\n  var exists\n  var stat = this.statCache[abs]\n  if (stat !== undefined) {\n    if (stat === false)\n      return cb(null, stat)\n    else {\n      var type = stat.isDirectory() ? 'DIR' : 'FILE'\n      if (needDir && type === 'FILE')\n        return cb()\n      else\n        return cb(null, type, stat)\n    }\n  }\n\n  var self = this\n  var statcb = inflight('stat\\0' + abs, lstatcb_)\n  if (statcb)\n    fs.lstat(abs, statcb)\n\n  function lstatcb_ (er, lstat) {\n    if (lstat && lstat.isSymbolicLink()) {\n      // If it's a symlink, then treat it as the target, unless\n      // the target does not exist, then treat it as a file.\n      return fs.stat(abs, function (er, stat) {\n        if (er)\n          self._stat2(f, abs, null, lstat, cb)\n        else\n          self._stat2(f, abs, er, stat, cb)\n      })\n    } else {\n      self._stat2(f, abs, er, lstat, cb)\n    }\n  }\n}\n\nGlob.prototype._stat2 = function (f, abs, er, stat, cb) {\n  if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {\n    this.statCache[abs] = false\n    return cb()\n  }\n\n  var needDir = f.slice(-1) === '/'\n  this.statCache[abs] = stat\n\n  if (abs.slice(-1) === '/' && stat && !stat.isDirectory())\n    return cb(null, false, stat)\n\n  var c = true\n  if (stat)\n    c = stat.isDirectory() ? 'DIR' : 'FILE'\n  this.cache[abs] = this.cache[abs] || c\n\n  if (needDir && c === 'FILE')\n    return cb()\n\n  return cb(null, c, stat)\n}\n","module.exports = globSync\nglobSync.GlobSync = GlobSync\n\nvar fs = require('fs')\nvar rp = require('fs.realpath')\nvar minimatch = require('minimatch')\nvar Minimatch = minimatch.Minimatch\nvar Glob = require('./glob.js').Glob\nvar util = require('util')\nvar path = require('path')\nvar assert = require('assert')\nvar isAbsolute = require('path-is-absolute')\nvar common = require('./common.js')\nvar alphasort = common.alphasort\nvar alphasorti = common.alphasorti\nvar setopts = common.setopts\nvar ownProp = common.ownProp\nvar childrenIgnored = common.childrenIgnored\nvar isIgnored = common.isIgnored\n\nfunction globSync (pattern, options) {\n  if (typeof options === 'function' || arguments.length === 3)\n    throw new TypeError('callback provided to sync glob\\n'+\n                        'See: https://github.com/isaacs/node-glob/issues/167')\n\n  return new GlobSync(pattern, options).found\n}\n\nfunction GlobSync (pattern, options) {\n  if (!pattern)\n    throw new Error('must provide pattern')\n\n  if (typeof options === 'function' || arguments.length === 3)\n    throw new TypeError('callback provided to sync glob\\n'+\n                        'See: https://github.com/isaacs/node-glob/issues/167')\n\n  if (!(this instanceof GlobSync))\n    return new GlobSync(pattern, options)\n\n  setopts(this, pattern, options)\n\n  if (this.noprocess)\n    return this\n\n  var n = this.minimatch.set.length\n  this.matches = new Array(n)\n  for (var i = 0; i < n; i ++) {\n    this._process(this.minimatch.set[i], i, false)\n  }\n  this._finish()\n}\n\nGlobSync.prototype._finish = function () {\n  assert(this instanceof GlobSync)\n  if (this.realpath) {\n    var self = this\n    this.matches.forEach(function (matchset, index) {\n      var set = self.matches[index] = Object.create(null)\n      for (var p in matchset) {\n        try {\n          p = self._makeAbs(p)\n          var real = rp.realpathSync(p, self.realpathCache)\n          set[real] = true\n        } catch (er) {\n          if (er.syscall === 'stat')\n            set[self._makeAbs(p)] = true\n          else\n            throw er\n        }\n      }\n    })\n  }\n  common.finish(this)\n}\n\n\nGlobSync.prototype._process = function (pattern, index, inGlobStar) {\n  assert(this instanceof GlobSync)\n\n  // Get the first [n] parts of pattern that are all strings.\n  var n = 0\n  while (typeof pattern[n] === 'string') {\n    n ++\n  }\n  // now n is the index of the first one that is *not* a string.\n\n  // See if there's anything else\n  var prefix\n  switch (n) {\n    // if not, then this is rather simple\n    case pattern.length:\n      this._processSimple(pattern.join('/'), index)\n      return\n\n    case 0:\n      // pattern *starts* with some non-trivial item.\n      // going to readdir(cwd), but not include the prefix in matches.\n      prefix = null\n      break\n\n    default:\n      // pattern has some string bits in the front.\n      // whatever it starts with, whether that's 'absolute' like /foo/bar,\n      // or 'relative' like '../baz'\n      prefix = pattern.slice(0, n).join('/')\n      break\n  }\n\n  var remain = pattern.slice(n)\n\n  // get the list of entries.\n  var read\n  if (prefix === null)\n    read = '.'\n  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {\n    if (!prefix || !isAbsolute(prefix))\n      prefix = '/' + prefix\n    read = prefix\n  } else\n    read = prefix\n\n  var abs = this._makeAbs(read)\n\n  //if ignored, skip processing\n  if (childrenIgnored(this, read))\n    return\n\n  var isGlobStar = remain[0] === minimatch.GLOBSTAR\n  if (isGlobStar)\n    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar)\n  else\n    this._processReaddir(prefix, read, abs, remain, index, inGlobStar)\n}\n\n\nGlobSync.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar) {\n  var entries = this._readdir(abs, inGlobStar)\n\n  // if the abs isn't a dir, then nothing can match!\n  if (!entries)\n    return\n\n  // It will only match dot entries if it starts with a dot, or if\n  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.\n  var pn = remain[0]\n  var negate = !!this.minimatch.negate\n  var rawGlob = pn._glob\n  var dotOk = this.dot || rawGlob.charAt(0) === '.'\n\n  var matchedEntries = []\n  for (var i = 0; i < entries.length; i++) {\n    var e = entries[i]\n    if (e.charAt(0) !== '.' || dotOk) {\n      var m\n      if (negate && !prefix) {\n        m = !e.match(pn)\n      } else {\n        m = e.match(pn)\n      }\n      if (m)\n        matchedEntries.push(e)\n    }\n  }\n\n  var len = matchedEntries.length\n  // If there are no matched entries, then nothing matches.\n  if (len === 0)\n    return\n\n  // if this is the last remaining pattern bit, then no need for\n  // an additional stat *unless* the user has specified mark or\n  // stat explicitly.  We know they exist, since readdir returned\n  // them.\n\n  if (remain.length === 1 && !this.mark && !this.stat) {\n    if (!this.matches[index])\n      this.matches[index] = Object.create(null)\n\n    for (var i = 0; i < len; i ++) {\n      var e = matchedEntries[i]\n      if (prefix) {\n        if (prefix.slice(-1) !== '/')\n          e = prefix + '/' + e\n        else\n          e = prefix + e\n      }\n\n      if (e.charAt(0) === '/' && !this.nomount) {\n        e = path.join(this.root, e)\n      }\n      this._emitMatch(index, e)\n    }\n    // This was the last one, and no stats were needed\n    return\n  }\n\n  // now test all matched entries as stand-ins for that part\n  // of the pattern.\n  remain.shift()\n  for (var i = 0; i < len; i ++) {\n    var e = matchedEntries[i]\n    var newPattern\n    if (prefix)\n      newPattern = [prefix, e]\n    else\n      newPattern = [e]\n    this._process(newPattern.concat(remain), index, inGlobStar)\n  }\n}\n\n\nGlobSync.prototype._emitMatch = function (index, e) {\n  if (isIgnored(this, e))\n    return\n\n  var abs = this._makeAbs(e)\n\n  if (this.mark)\n    e = this._mark(e)\n\n  if (this.absolute) {\n    e = abs\n  }\n\n  if (this.matches[index][e])\n    return\n\n  if (this.nodir) {\n    var c = this.cache[abs]\n    if (c === 'DIR' || Array.isArray(c))\n      return\n  }\n\n  this.matches[index][e] = true\n\n  if (this.stat)\n    this._stat(e)\n}\n\n\nGlobSync.prototype._readdirInGlobStar = function (abs) {\n  // follow all symlinked directories forever\n  // just proceed as if this is a non-globstar situation\n  if (this.follow)\n    return this._readdir(abs, false)\n\n  var entries\n  var lstat\n  var stat\n  try {\n    lstat = fs.lstatSync(abs)\n  } catch (er) {\n    if (er.code === 'ENOENT') {\n      // lstat failed, doesn't exist\n      return null\n    }\n  }\n\n  var isSym = lstat && lstat.isSymbolicLink()\n  this.symlinks[abs] = isSym\n\n  // If it's not a symlink or a dir, then it's definitely a regular file.\n  // don't bother doing a readdir in that case.\n  if (!isSym && lstat && !lstat.isDirectory())\n    this.cache[abs] = 'FILE'\n  else\n    entries = this._readdir(abs, false)\n\n  return entries\n}\n\nGlobSync.prototype._readdir = function (abs, inGlobStar) {\n  var entries\n\n  if (inGlobStar && !ownProp(this.symlinks, abs))\n    return this._readdirInGlobStar(abs)\n\n  if (ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n    if (!c || c === 'FILE')\n      return null\n\n    if (Array.isArray(c))\n      return c\n  }\n\n  try {\n    return this._readdirEntries(abs, fs.readdirSync(abs))\n  } catch (er) {\n    this._readdirError(abs, er)\n    return null\n  }\n}\n\nGlobSync.prototype._readdirEntries = function (abs, entries) {\n  // if we haven't asked to stat everything, then just\n  // assume that everything in there exists, so we can avoid\n  // having to stat it a second time.\n  if (!this.mark && !this.stat) {\n    for (var i = 0; i < entries.length; i ++) {\n      var e = entries[i]\n      if (abs === '/')\n        e = abs + e\n      else\n        e = abs + '/' + e\n      this.cache[e] = true\n    }\n  }\n\n  this.cache[abs] = entries\n\n  // mark and cache dir-ness\n  return entries\n}\n\nGlobSync.prototype._readdirError = function (f, er) {\n  // handle errors, and cache the information\n  switch (er.code) {\n    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205\n    case 'ENOTDIR': // totally normal. means it *does* exist.\n      var abs = this._makeAbs(f)\n      this.cache[abs] = 'FILE'\n      if (abs === this.cwdAbs) {\n        var error = new Error(er.code + ' invalid cwd ' + this.cwd)\n        error.path = this.cwd\n        error.code = er.code\n        throw error\n      }\n      break\n\n    case 'ENOENT': // not terribly unusual\n    case 'ELOOP':\n    case 'ENAMETOOLONG':\n    case 'UNKNOWN':\n      this.cache[this._makeAbs(f)] = false\n      break\n\n    default: // some unusual error.  Treat as failure.\n      this.cache[this._makeAbs(f)] = false\n      if (this.strict)\n        throw er\n      if (!this.silent)\n        console.error('glob error', er)\n      break\n  }\n}\n\nGlobSync.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar) {\n\n  var entries = this._readdir(abs, inGlobStar)\n\n  // no entries means not a dir, so it can never have matches\n  // foo.txt/** doesn't match foo.txt\n  if (!entries)\n    return\n\n  // test without the globstar, and with every child both below\n  // and replacing the globstar.\n  var remainWithoutGlobStar = remain.slice(1)\n  var gspref = prefix ? [ prefix ] : []\n  var noGlobStar = gspref.concat(remainWithoutGlobStar)\n\n  // the noGlobStar pattern exits the inGlobStar state\n  this._process(noGlobStar, index, false)\n\n  var len = entries.length\n  var isSym = this.symlinks[abs]\n\n  // If it's a symlink, and we're in a globstar, then stop\n  if (isSym && inGlobStar)\n    return\n\n  for (var i = 0; i < len; i++) {\n    var e = entries[i]\n    if (e.charAt(0) === '.' && !this.dot)\n      continue\n\n    // these two cases enter the inGlobStar state\n    var instead = gspref.concat(entries[i], remainWithoutGlobStar)\n    this._process(instead, index, true)\n\n    var below = gspref.concat(entries[i], remain)\n    this._process(below, index, true)\n  }\n}\n\nGlobSync.prototype._processSimple = function (prefix, index) {\n  // XXX review this.  Shouldn't it be doing the mounting etc\n  // before doing stat?  kinda weird?\n  var exists = this._stat(prefix)\n\n  if (!this.matches[index])\n    this.matches[index] = Object.create(null)\n\n  // If it doesn't exist, then just mark the lack of results\n  if (!exists)\n    return\n\n  if (prefix && isAbsolute(prefix) && !this.nomount) {\n    var trail = /[\\/\\\\]$/.test(prefix)\n    if (prefix.charAt(0) === '/') {\n      prefix = path.join(this.root, prefix)\n    } else {\n      prefix = path.resolve(this.root, prefix)\n      if (trail)\n        prefix += '/'\n    }\n  }\n\n  if (process.platform === 'win32')\n    prefix = prefix.replace(/\\\\/g, '/')\n\n  // Mark this as a match\n  this._emitMatch(index, prefix)\n}\n\n// Returns either 'DIR', 'FILE', or false\nGlobSync.prototype._stat = function (f) {\n  var abs = this._makeAbs(f)\n  var needDir = f.slice(-1) === '/'\n\n  if (f.length > this.maxLength)\n    return false\n\n  if (!this.stat && ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n\n    if (Array.isArray(c))\n      c = 'DIR'\n\n    // It exists, but maybe not how we need it\n    if (!needDir || c === 'DIR')\n      return c\n\n    if (needDir && c === 'FILE')\n      return false\n\n    // otherwise we have to stat, because maybe c=true\n    // if we know it exists, but not what it is.\n  }\n\n  var exists\n  var stat = this.statCache[abs]\n  if (!stat) {\n    var lstat\n    try {\n      lstat = fs.lstatSync(abs)\n    } catch (er) {\n      if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {\n        this.statCache[abs] = false\n        return false\n      }\n    }\n\n    if (lstat && lstat.isSymbolicLink()) {\n      try {\n        stat = fs.statSync(abs)\n      } catch (er) {\n        stat = lstat\n      }\n    } else {\n      stat = lstat\n    }\n  }\n\n  this.statCache[abs] = stat\n\n  var c = true\n  if (stat)\n    c = stat.isDirectory() ? 'DIR' : 'FILE'\n\n  this.cache[abs] = this.cache[abs] || c\n\n  if (needDir && c === 'FILE')\n    return false\n\n  return c\n}\n\nGlobSync.prototype._mark = function (p) {\n  return common.mark(this, p)\n}\n\nGlobSync.prototype._makeAbs = function (f) {\n  return common.makeAbs(this, f)\n}\n","'use strict'\n\nmodule.exports = clone\n\nfunction clone (obj) {\n  if (obj === null || typeof obj !== 'object')\n    return obj\n\n  if (obj instanceof Object)\n    var copy = { __proto__: obj.__proto__ }\n  else\n    var copy = Object.create(null)\n\n  Object.getOwnPropertyNames(obj).forEach(function (key) {\n    Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key))\n  })\n\n  return copy\n}\n","var fs = require('fs')\nvar polyfills = require('./polyfills.js')\nvar legacy = require('./legacy-streams.js')\nvar clone = require('./clone.js')\n\nvar util = require('util')\n\n/* istanbul ignore next - node 0.x polyfill */\nvar gracefulQueue\nvar previousSymbol\n\n/* istanbul ignore else - node 0.x polyfill */\nif (typeof Symbol === 'function' && typeof Symbol.for === 'function') {\n  gracefulQueue = Symbol.for('graceful-fs.queue')\n  // This is used in testing by future versions\n  previousSymbol = Symbol.for('graceful-fs.previous')\n} else {\n  gracefulQueue = '___graceful-fs.queue'\n  previousSymbol = '___graceful-fs.previous'\n}\n\nfunction noop () {}\n\nfunction publishQueue(context, queue) {\n  Object.defineProperty(context, gracefulQueue, {\n    get: function() {\n      return queue\n    }\n  })\n}\n\nvar debug = noop\nif (util.debuglog)\n  debug = util.debuglog('gfs4')\nelse if (/\\bgfs4\\b/i.test(process.env.NODE_DEBUG || ''))\n  debug = function() {\n    var m = util.format.apply(util, arguments)\n    m = 'GFS4: ' + m.split(/\\n/).join('\\nGFS4: ')\n    console.error(m)\n  }\n\n// Once time initialization\nif (!fs[gracefulQueue]) {\n  // This queue can be shared by multiple loaded instances\n  var queue = global[gracefulQueue] || []\n  publishQueue(fs, queue)\n\n  // Patch fs.close/closeSync to shared queue version, because we need\n  // to retry() whenever a close happens *anywhere* in the program.\n  // This is essential when multiple graceful-fs instances are\n  // in play at the same time.\n  fs.close = (function (fs$close) {\n    function close (fd, cb) {\n      return fs$close.call(fs, fd, function (err) {\n        // This function uses the graceful-fs shared queue\n        if (!err) {\n          retry()\n        }\n\n        if (typeof cb === 'function')\n          cb.apply(this, arguments)\n      })\n    }\n\n    Object.defineProperty(close, previousSymbol, {\n      value: fs$close\n    })\n    return close\n  })(fs.close)\n\n  fs.closeSync = (function (fs$closeSync) {\n    function closeSync (fd) {\n      // This function uses the graceful-fs shared queue\n      fs$closeSync.apply(fs, arguments)\n      retry()\n    }\n\n    Object.defineProperty(closeSync, previousSymbol, {\n      value: fs$closeSync\n    })\n    return closeSync\n  })(fs.closeSync)\n\n  if (/\\bgfs4\\b/i.test(process.env.NODE_DEBUG || '')) {\n    process.on('exit', function() {\n      debug(fs[gracefulQueue])\n      require('assert').equal(fs[gracefulQueue].length, 0)\n    })\n  }\n}\n\nif (!global[gracefulQueue]) {\n  publishQueue(global, fs[gracefulQueue]);\n}\n\nmodule.exports = patch(clone(fs))\nif (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs.__patched) {\n    module.exports = patch(fs)\n    fs.__patched = true;\n}\n\nfunction patch (fs) {\n  // Everything that references the open() function needs to be in here\n  polyfills(fs)\n  fs.gracefulify = patch\n\n  fs.createReadStream = createReadStream\n  fs.createWriteStream = createWriteStream\n  var fs$readFile = fs.readFile\n  fs.readFile = readFile\n  function readFile (path, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$readFile(path, options, cb)\n\n    function go$readFile (path, options, cb) {\n      return fs$readFile(path, options, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$readFile, [path, options, cb]])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n          retry()\n        }\n      })\n    }\n  }\n\n  var fs$writeFile = fs.writeFile\n  fs.writeFile = writeFile\n  function writeFile (path, data, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$writeFile(path, data, options, cb)\n\n    function go$writeFile (path, data, options, cb) {\n      return fs$writeFile(path, data, options, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$writeFile, [path, data, options, cb]])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n          retry()\n        }\n      })\n    }\n  }\n\n  var fs$appendFile = fs.appendFile\n  if (fs$appendFile)\n    fs.appendFile = appendFile\n  function appendFile (path, data, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$appendFile(path, data, options, cb)\n\n    function go$appendFile (path, data, options, cb) {\n      return fs$appendFile(path, data, options, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$appendFile, [path, data, options, cb]])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n          retry()\n        }\n      })\n    }\n  }\n\n  var fs$readdir = fs.readdir\n  fs.readdir = readdir\n  function readdir (path, options, cb) {\n    var args = [path]\n    if (typeof options !== 'function') {\n      args.push(options)\n    } else {\n      cb = options\n    }\n    args.push(go$readdir$cb)\n\n    return go$readdir(args)\n\n    function go$readdir$cb (err, files) {\n      if (files && files.sort)\n        files.sort()\n\n      if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n        enqueue([go$readdir, [args]])\n\n      else {\n        if (typeof cb === 'function')\n          cb.apply(this, arguments)\n        retry()\n      }\n    }\n  }\n\n  function go$readdir (args) {\n    return fs$readdir.apply(fs, args)\n  }\n\n  if (process.version.substr(0, 4) === 'v0.8') {\n    var legStreams = legacy(fs)\n    ReadStream = legStreams.ReadStream\n    WriteStream = legStreams.WriteStream\n  }\n\n  var fs$ReadStream = fs.ReadStream\n  if (fs$ReadStream) {\n    ReadStream.prototype = Object.create(fs$ReadStream.prototype)\n    ReadStream.prototype.open = ReadStream$open\n  }\n\n  var fs$WriteStream = fs.WriteStream\n  if (fs$WriteStream) {\n    WriteStream.prototype = Object.create(fs$WriteStream.prototype)\n    WriteStream.prototype.open = WriteStream$open\n  }\n\n  Object.defineProperty(fs, 'ReadStream', {\n    get: function () {\n      return ReadStream\n    },\n    set: function (val) {\n      ReadStream = val\n    },\n    enumerable: true,\n    configurable: true\n  })\n  Object.defineProperty(fs, 'WriteStream', {\n    get: function () {\n      return WriteStream\n    },\n    set: function (val) {\n      WriteStream = val\n    },\n    enumerable: true,\n    configurable: true\n  })\n\n  // legacy names\n  var FileReadStream = ReadStream\n  Object.defineProperty(fs, 'FileReadStream', {\n    get: function () {\n      return FileReadStream\n    },\n    set: function (val) {\n      FileReadStream = val\n    },\n    enumerable: true,\n    configurable: true\n  })\n  var FileWriteStream = WriteStream\n  Object.defineProperty(fs, 'FileWriteStream', {\n    get: function () {\n      return FileWriteStream\n    },\n    set: function (val) {\n      FileWriteStream = val\n    },\n    enumerable: true,\n    configurable: true\n  })\n\n  function ReadStream (path, options) {\n    if (this instanceof ReadStream)\n      return fs$ReadStream.apply(this, arguments), this\n    else\n      return ReadStream.apply(Object.create(ReadStream.prototype), arguments)\n  }\n\n  function ReadStream$open () {\n    var that = this\n    open(that.path, that.flags, that.mode, function (err, fd) {\n      if (err) {\n        if (that.autoClose)\n          that.destroy()\n\n        that.emit('error', err)\n      } else {\n        that.fd = fd\n        that.emit('open', fd)\n        that.read()\n      }\n    })\n  }\n\n  function WriteStream (path, options) {\n    if (this instanceof WriteStream)\n      return fs$WriteStream.apply(this, arguments), this\n    else\n      return WriteStream.apply(Object.create(WriteStream.prototype), arguments)\n  }\n\n  function WriteStream$open () {\n    var that = this\n    open(that.path, that.flags, that.mode, function (err, fd) {\n      if (err) {\n        that.destroy()\n        that.emit('error', err)\n      } else {\n        that.fd = fd\n        that.emit('open', fd)\n      }\n    })\n  }\n\n  function createReadStream (path, options) {\n    return new fs.ReadStream(path, options)\n  }\n\n  function createWriteStream (path, options) {\n    return new fs.WriteStream(path, options)\n  }\n\n  var fs$open = fs.open\n  fs.open = open\n  function open (path, flags, mode, cb) {\n    if (typeof mode === 'function')\n      cb = mode, mode = null\n\n    return go$open(path, flags, mode, cb)\n\n    function go$open (path, flags, mode, cb) {\n      return fs$open(path, flags, mode, function (err, fd) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$open, [path, flags, mode, cb]])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n          retry()\n        }\n      })\n    }\n  }\n\n  return fs\n}\n\nfunction enqueue (elem) {\n  debug('ENQUEUE', elem[0].name, elem[1])\n  fs[gracefulQueue].push(elem)\n}\n\nfunction retry () {\n  var elem = fs[gracefulQueue].shift()\n  if (elem) {\n    debug('RETRY', elem[0].name, elem[1])\n    elem[0].apply(null, elem[1])\n  }\n}\n","var Stream = require('stream').Stream\n\nmodule.exports = legacy\n\nfunction legacy (fs) {\n  return {\n    ReadStream: ReadStream,\n    WriteStream: WriteStream\n  }\n\n  function ReadStream (path, options) {\n    if (!(this instanceof ReadStream)) return new ReadStream(path, options);\n\n    Stream.call(this);\n\n    var self = this;\n\n    this.path = path;\n    this.fd = null;\n    this.readable = true;\n    this.paused = false;\n\n    this.flags = 'r';\n    this.mode = 438; /*=0666*/\n    this.bufferSize = 64 * 1024;\n\n    options = options || {};\n\n    // Mixin options into this\n    var keys = Object.keys(options);\n    for (var index = 0, length = keys.length; index < length; index++) {\n      var key = keys[index];\n      this[key] = options[key];\n    }\n\n    if (this.encoding) this.setEncoding(this.encoding);\n\n    if (this.start !== undefined) {\n      if ('number' !== typeof this.start) {\n        throw TypeError('start must be a Number');\n      }\n      if (this.end === undefined) {\n        this.end = Infinity;\n      } else if ('number' !== typeof this.end) {\n        throw TypeError('end must be a Number');\n      }\n\n      if (this.start > this.end) {\n        throw new Error('start must be <= end');\n      }\n\n      this.pos = this.start;\n    }\n\n    if (this.fd !== null) {\n      process.nextTick(function() {\n        self._read();\n      });\n      return;\n    }\n\n    fs.open(this.path, this.flags, this.mode, function (err, fd) {\n      if (err) {\n        self.emit('error', err);\n        self.readable = false;\n        return;\n      }\n\n      self.fd = fd;\n      self.emit('open', fd);\n      self._read();\n    })\n  }\n\n  function WriteStream (path, options) {\n    if (!(this instanceof WriteStream)) return new WriteStream(path, options);\n\n    Stream.call(this);\n\n    this.path = path;\n    this.fd = null;\n    this.writable = true;\n\n    this.flags = 'w';\n    this.encoding = 'binary';\n    this.mode = 438; /*=0666*/\n    this.bytesWritten = 0;\n\n    options = options || {};\n\n    // Mixin options into this\n    var keys = Object.keys(options);\n    for (var index = 0, length = keys.length; index < length; index++) {\n      var key = keys[index];\n      this[key] = options[key];\n    }\n\n    if (this.start !== undefined) {\n      if ('number' !== typeof this.start) {\n        throw TypeError('start must be a Number');\n      }\n      if (this.start < 0) {\n        throw new Error('start must be >= zero');\n      }\n\n      this.pos = this.start;\n    }\n\n    this.busy = false;\n    this._queue = [];\n\n    if (this.fd === null) {\n      this._open = fs.open;\n      this._queue.push([this._open, this.path, this.flags, this.mode, undefined]);\n      this.flush();\n    }\n  }\n}\n","var constants = require('constants')\n\nvar origCwd = process.cwd\nvar cwd = null\n\nvar platform = process.env.GRACEFUL_FS_PLATFORM || process.platform\n\nprocess.cwd = function() {\n  if (!cwd)\n    cwd = origCwd.call(process)\n  return cwd\n}\ntry {\n  process.cwd()\n} catch (er) {}\n\nvar chdir = process.chdir\nprocess.chdir = function(d) {\n  cwd = null\n  chdir.call(process, d)\n}\n\nmodule.exports = patch\n\nfunction patch (fs) {\n  // (re-)implement some things that are known busted or missing.\n\n  // lchmod, broken prior to 0.6.2\n  // back-port the fix here.\n  if (constants.hasOwnProperty('O_SYMLINK') &&\n      process.version.match(/^v0\\.6\\.[0-2]|^v0\\.5\\./)) {\n    patchLchmod(fs)\n  }\n\n  // lutimes implementation, or no-op\n  if (!fs.lutimes) {\n    patchLutimes(fs)\n  }\n\n  // https://github.com/isaacs/node-graceful-fs/issues/4\n  // Chown should not fail on einval or eperm if non-root.\n  // It should not fail on enosys ever, as this just indicates\n  // that a fs doesn't support the intended operation.\n\n  fs.chown = chownFix(fs.chown)\n  fs.fchown = chownFix(fs.fchown)\n  fs.lchown = chownFix(fs.lchown)\n\n  fs.chmod = chmodFix(fs.chmod)\n  fs.fchmod = chmodFix(fs.fchmod)\n  fs.lchmod = chmodFix(fs.lchmod)\n\n  fs.chownSync = chownFixSync(fs.chownSync)\n  fs.fchownSync = chownFixSync(fs.fchownSync)\n  fs.lchownSync = chownFixSync(fs.lchownSync)\n\n  fs.chmodSync = chmodFixSync(fs.chmodSync)\n  fs.fchmodSync = chmodFixSync(fs.fchmodSync)\n  fs.lchmodSync = chmodFixSync(fs.lchmodSync)\n\n  fs.stat = statFix(fs.stat)\n  fs.fstat = statFix(fs.fstat)\n  fs.lstat = statFix(fs.lstat)\n\n  fs.statSync = statFixSync(fs.statSync)\n  fs.fstatSync = statFixSync(fs.fstatSync)\n  fs.lstatSync = statFixSync(fs.lstatSync)\n\n  // if lchmod/lchown do not exist, then make them no-ops\n  if (!fs.lchmod) {\n    fs.lchmod = function (path, mode, cb) {\n      if (cb) process.nextTick(cb)\n    }\n    fs.lchmodSync = function () {}\n  }\n  if (!fs.lchown) {\n    fs.lchown = function (path, uid, gid, cb) {\n      if (cb) process.nextTick(cb)\n    }\n    fs.lchownSync = function () {}\n  }\n\n  // on Windows, A/V software can lock the directory, causing this\n  // to fail with an EACCES or EPERM if the directory contains newly\n  // created files.  Try again on failure, for up to 60 seconds.\n\n  // Set the timeout this long because some Windows Anti-Virus, such as Parity\n  // bit9, may lock files for up to a minute, causing npm package install\n  // failures. Also, take care to yield the scheduler. Windows scheduling gives\n  // CPU to a busy looping process, which can cause the program causing the lock\n  // contention to be starved of CPU by node, so the contention doesn't resolve.\n  if (platform === \"win32\") {\n    fs.rename = (function (fs$rename) { return function (from, to, cb) {\n      var start = Date.now()\n      var backoff = 0;\n      fs$rename(from, to, function CB (er) {\n        if (er\n            && (er.code === \"EACCES\" || er.code === \"EPERM\")\n            && Date.now() - start < 60000) {\n          setTimeout(function() {\n            fs.stat(to, function (stater, st) {\n              if (stater && stater.code === \"ENOENT\")\n                fs$rename(from, to, CB);\n              else\n                cb(er)\n            })\n          }, backoff)\n          if (backoff < 100)\n            backoff += 10;\n          return;\n        }\n        if (cb) cb(er)\n      })\n    }})(fs.rename)\n  }\n\n  // if read() returns EAGAIN, then just try it again.\n  fs.read = (function (fs$read) {\n    function read (fd, buffer, offset, length, position, callback_) {\n      var callback\n      if (callback_ && typeof callback_ === 'function') {\n        var eagCounter = 0\n        callback = function (er, _, __) {\n          if (er && er.code === 'EAGAIN' && eagCounter < 10) {\n            eagCounter ++\n            return fs$read.call(fs, fd, buffer, offset, length, position, callback)\n          }\n          callback_.apply(this, arguments)\n        }\n      }\n      return fs$read.call(fs, fd, buffer, offset, length, position, callback)\n    }\n\n    // This ensures `util.promisify` works as it does for native `fs.read`.\n    read.__proto__ = fs$read\n    return read\n  })(fs.read)\n\n  fs.readSync = (function (fs$readSync) { return function (fd, buffer, offset, length, position) {\n    var eagCounter = 0\n    while (true) {\n      try {\n        return fs$readSync.call(fs, fd, buffer, offset, length, position)\n      } catch (er) {\n        if (er.code === 'EAGAIN' && eagCounter < 10) {\n          eagCounter ++\n          continue\n        }\n        throw er\n      }\n    }\n  }})(fs.readSync)\n\n  function patchLchmod (fs) {\n    fs.lchmod = function (path, mode, callback) {\n      fs.open( path\n             , constants.O_WRONLY | constants.O_SYMLINK\n             , mode\n             , function (err, fd) {\n        if (err) {\n          if (callback) callback(err)\n          return\n        }\n        // prefer to return the chmod error, if one occurs,\n        // but still try to close, and report closing errors if they occur.\n        fs.fchmod(fd, mode, function (err) {\n          fs.close(fd, function(err2) {\n            if (callback) callback(err || err2)\n          })\n        })\n      })\n    }\n\n    fs.lchmodSync = function (path, mode) {\n      var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode)\n\n      // prefer to return the chmod error, if one occurs,\n      // but still try to close, and report closing errors if they occur.\n      var threw = true\n      var ret\n      try {\n        ret = fs.fchmodSync(fd, mode)\n        threw = false\n      } finally {\n        if (threw) {\n          try {\n            fs.closeSync(fd)\n          } catch (er) {}\n        } else {\n          fs.closeSync(fd)\n        }\n      }\n      return ret\n    }\n  }\n\n  function patchLutimes (fs) {\n    if (constants.hasOwnProperty(\"O_SYMLINK\")) {\n      fs.lutimes = function (path, at, mt, cb) {\n        fs.open(path, constants.O_SYMLINK, function (er, fd) {\n          if (er) {\n            if (cb) cb(er)\n            return\n          }\n          fs.futimes(fd, at, mt, function (er) {\n            fs.close(fd, function (er2) {\n              if (cb) cb(er || er2)\n            })\n          })\n        })\n      }\n\n      fs.lutimesSync = function (path, at, mt) {\n        var fd = fs.openSync(path, constants.O_SYMLINK)\n        var ret\n        var threw = true\n        try {\n          ret = fs.futimesSync(fd, at, mt)\n          threw = false\n        } finally {\n          if (threw) {\n            try {\n              fs.closeSync(fd)\n            } catch (er) {}\n          } else {\n            fs.closeSync(fd)\n          }\n        }\n        return ret\n      }\n\n    } else {\n      fs.lutimes = function (_a, _b, _c, cb) { if (cb) process.nextTick(cb) }\n      fs.lutimesSync = function () {}\n    }\n  }\n\n  function chmodFix (orig) {\n    if (!orig) return orig\n    return function (target, mode, cb) {\n      return orig.call(fs, target, mode, function (er) {\n        if (chownErOk(er)) er = null\n        if (cb) cb.apply(this, arguments)\n      })\n    }\n  }\n\n  function chmodFixSync (orig) {\n    if (!orig) return orig\n    return function (target, mode) {\n      try {\n        return orig.call(fs, target, mode)\n      } catch (er) {\n        if (!chownErOk(er)) throw er\n      }\n    }\n  }\n\n\n  function chownFix (orig) {\n    if (!orig) return orig\n    return function (target, uid, gid, cb) {\n      return orig.call(fs, target, uid, gid, function (er) {\n        if (chownErOk(er)) er = null\n        if (cb) cb.apply(this, arguments)\n      })\n    }\n  }\n\n  function chownFixSync (orig) {\n    if (!orig) return orig\n    return function (target, uid, gid) {\n      try {\n        return orig.call(fs, target, uid, gid)\n      } catch (er) {\n        if (!chownErOk(er)) throw er\n      }\n    }\n  }\n\n  function statFix (orig) {\n    if (!orig) return orig\n    // Older versions of Node erroneously returned signed integers for\n    // uid + gid.\n    return function (target, options, cb) {\n      if (typeof options === 'function') {\n        cb = options\n        options = null\n      }\n      function callback (er, stats) {\n        if (stats) {\n          if (stats.uid < 0) stats.uid += 0x100000000\n          if (stats.gid < 0) stats.gid += 0x100000000\n        }\n        if (cb) cb.apply(this, arguments)\n      }\n      return options ? orig.call(fs, target, options, callback)\n        : orig.call(fs, target, callback)\n    }\n  }\n\n  function statFixSync (orig) {\n    if (!orig) return orig\n    // Older versions of Node erroneously returned signed integers for\n    // uid + gid.\n    return function (target, options) {\n      var stats = options ? orig.call(fs, target, options)\n        : orig.call(fs, target)\n      if (stats.uid < 0) stats.uid += 0x100000000\n      if (stats.gid < 0) stats.gid += 0x100000000\n      return stats;\n    }\n  }\n\n  // ENOSYS means that the fs doesn't support the op. Just ignore\n  // that, because it doesn't matter.\n  //\n  // if there's no getuid, or if getuid() is something other\n  // than 0, and the error is EINVAL or EPERM, then just ignore\n  // it.\n  //\n  // This specific case is a silent failure in cp, install, tar,\n  // and most other unix tools that manage permissions.\n  //\n  // When running as root, or if other types of errors are\n  // encountered, then it's strict.\n  function chownErOk (er) {\n    if (!er)\n      return true\n\n    if (er.code === \"ENOSYS\")\n      return true\n\n    var nonroot = !process.getuid || process.getuid() !== 0\n    if (nonroot) {\n      if (er.code === \"EINVAL\" || er.code === \"EPERM\")\n        return true\n    }\n\n    return false\n  }\n}\n","(function () {\n\t'use strict';\n\n\tvar crc32 = require('crc32'),\n\t\tdeflate = require('deflate-js'),\n\t\t// magic numbers marking this file as GZIP\n\t\tID1 = 0x1F,\n\t\tID2 = 0x8B,\n\t\tcompressionMethods = {\n\t\t\t'deflate': 8\n\t\t},\n\t\tpossibleFlags = {\n\t\t\t'FTEXT': 0x01,\n\t\t\t'FHCRC': 0x02,\n\t\t\t'FEXTRA': 0x04,\n\t\t\t'FNAME': 0x08,\n\t\t\t'FCOMMENT': 0x10\n\t\t},\n\t\tosMap = {\n\t\t\t'fat': 0, // FAT file system (DOS, OS/2, NT) + PKZIPW 2.50 VFAT, NTFS\n\t\t\t'amiga': 1, // Amiga\n\t\t\t'vmz': 2, // VMS (VAX or Alpha AXP)\n\t\t\t'unix': 3, // Unix\n\t\t\t'vm/cms': 4, // VM/CMS\n\t\t\t'atari': 5, // Atari\n\t\t\t'hpfs': 6, // HPFS file system (OS/2, NT 3.x)\n\t\t\t'macintosh': 7, // Macintosh\n\t\t\t'z-system': 8, // Z-System\n\t\t\t'cplm': 9, // CP/M\n\t\t\t'tops-20': 10, // TOPS-20\n\t\t\t'ntfs': 11, // NTFS file system (NT)\n\t\t\t'qdos': 12, // SMS/QDOS\n\t\t\t'acorn': 13, // Acorn RISC OS\n\t\t\t'vfat': 14, // VFAT file system (Win95, NT)\n\t\t\t'vms': 15, // MVS (code also taken for PRIMOS)\n\t\t\t'beos': 16, // BeOS (BeBox or PowerMac)\n\t\t\t'tandem': 17, // Tandem/NSK\n\t\t\t'theos': 18 // THEOS\n\t\t},\n\t\tos = 'unix',\n\t\tDEFAULT_LEVEL = 6;\n\n\tfunction putByte(n, arr) {\n\t\tarr.push(n & 0xFF);\n\t}\n\n\t// LSB first\n\tfunction putShort(n, arr) {\n\t\tarr.push(n & 0xFF);\n\t\tarr.push(n >>> 8);\n\t}\n\n\t// LSB first\n\tfunction putLong(n, arr) {\n\t\tputShort(n & 0xffff, arr);\n\t\tputShort(n >>> 16, arr);\n\t}\n\n\tfunction putString(s, arr) {\n\t\tvar i, len = s.length;\n\t\tfor (i = 0; i < len; i += 1) {\n\t\t\tputByte(s.charCodeAt(i), arr);\n\t\t}\n\t}\n\n\tfunction readByte(arr) {\n\t\treturn arr.shift();\n\t}\n\n\tfunction readShort(arr) {\n\t\treturn arr.shift() | (arr.shift() << 8);\n\t}\n\n\tfunction readLong(arr) {\n\t\tvar n1 = readShort(arr),\n\t\t\tn2 = readShort(arr);\n\n\t\t// JavaScript can't handle bits in the position 32\n\t\t// we'll emulate this by removing the left-most bit (if it exists)\n\t\t// and add it back in via multiplication, which does work\n\t\tif (n2 > 32768) {\n\t\t\tn2 -= 32768;\n\n\t\t\treturn ((n2 << 16) | n1) + 32768 * Math.pow(2, 16);\n\t\t}\n\n\t\treturn (n2 << 16) | n1;\n\t}\n\n\tfunction readString(arr) {\n\t\tvar charArr = [];\n\n\t\t// turn all bytes into chars until the terminating null\n\t\twhile (arr[0] !== 0) {\n\t\t\tcharArr.push(String.fromCharCode(arr.shift()));\n\t\t}\n\n\t\t// throw away terminating null\n\t\tarr.shift();\n\n\t\t// join all characters into a cohesive string\n\t\treturn charArr.join('');\n\t}\n\n\t/*\n\t * Reads n number of bytes and return as an array.\n\t *\n\t * @param arr- Array of bytes to read from\n\t * @param n- Number of bytes to read\n\t */\n\tfunction readBytes(arr, n) {\n\t\tvar i, ret = [];\n\t\tfor (i = 0; i < n; i += 1) {\n\t\t\tret.push(arr.shift());\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\t/*\n\t * ZIPs a file in GZIP format. The format is as given by the spec, found at:\n\t * http://www.gzip.org/zlib/rfc-gzip.html\n\t *\n\t * Omitted parts in this implementation:\n\t */\n\tfunction zip(data, options) {\n\t\tvar flags = 0,\n\t\t\tlevel,\n\t\t\tcrc, out = [];\n\n\t\tif (!options) {\n\t\t\toptions = {};\n\t\t}\n\t\tlevel = options.level || DEFAULT_LEVEL;\n\n\t\tif (typeof data === 'string') {\n\t\t\tdata = Array.prototype.map.call(data, function (char) {\n\t\t\t\treturn char.charCodeAt(0);\n\t\t\t});\n\t\t}\n\n\t\t// magic number marking this file as GZIP\n\t\tputByte(ID1, out);\n\t\tputByte(ID2, out);\n\n\t\tputByte(compressionMethods['deflate'], out);\n\n\t\tif (options.name) {\n\t\t\tflags |= possibleFlags['FNAME'];\n\t\t}\n\n\t\tputByte(flags, out);\n\t\tputLong(options.timestamp || parseInt(Date.now() / 1000, 10), out);\n\n\t\t// put deflate args (extra flags)\n\t\tif (level === 1) {\n\t\t\t// fastest algorithm\n\t\t\tputByte(4, out);\n\t\t} else if (level === 9) {\n\t\t\t// maximum compression (fastest algorithm)\n\t\t\tputByte(2, out);\n\t\t} else {\n\t\t\tputByte(0, out);\n\t\t}\n\n\t\t// OS identifier\n\t\tputByte(osMap[os], out);\n\n\t\tif (options.name) {\n\t\t\t// ignore the directory part\n\t\t\tputString(options.name.substring(options.name.lastIndexOf('/') + 1), out);\n\n\t\t\t// terminating null\n\t\t\tputByte(0, out);\n\t\t}\n\n\t\tdeflate.deflate(data, level).forEach(function (byte) {\n\t\t\tputByte(byte, out);\n\t\t});\n\n\t\tputLong(parseInt(crc32(data), 16), out);\n\t\tputLong(data.length, out);\n\n\t\treturn out;\n\t}\n\n\tfunction unzip(data, options) {\n\t\t// start with a copy of the array\n\t\tvar arr = Array.prototype.slice.call(data, 0),\n\t\t\tt,\n\t\t\tcompressionMethod,\n\t\t\tflags,\n\t\t\tmtime,\n\t\t\txFlags,\n\t\t\tkey,\n\t\t\tos,\n\t\t\tcrc,\n\t\t\tsize,\n\t\t\tres;\n\n\t\t// check the first two bytes for the magic numbers\n\t\tif (readByte(arr) !== ID1 || readByte(arr) !== ID2) {\n\t\t\tthrow 'Not a GZIP file';\n\t\t}\n\n\t\tt = readByte(arr);\n\t\tt = Object.keys(compressionMethods).some(function (key) {\n\t\t\tcompressionMethod = key;\n\t\t\treturn compressionMethods[key] === t;\n\t\t});\n\n\t\tif (!t) {\n\t\t\tthrow 'Unsupported compression method';\n\t\t}\n\n\t\tflags = readByte(arr);\n\t\tmtime = readLong(arr);\n\t\txFlags = readByte(arr);\n\t\tt = readByte(arr);\n\t\tObject.keys(osMap).some(function (key) {\n\t\t\tif (osMap[key] === t) {\n\t\t\t\tos = key;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\t// just throw away the bytes for now\n\t\tif (flags & possibleFlags['FEXTRA']) {\n\t\t\tt = readShort(arr);\n\t\t\treadBytes(arr, t);\n\t\t}\n\n\t\t// just throw away for now\n\t\tif (flags & possibleFlags['FNAME']) {\n\t\t\treadString(arr);\n\t\t}\n\n\t\t// just throw away for now\n\t\tif (flags & possibleFlags['FCOMMENT']) {\n\t\t\treadString(arr);\n\t\t}\n\n\t\t// just throw away for now\n\t\tif (flags & possibleFlags['FHCRC']) {\n\t\t\treadShort(arr);\n\t\t}\n\n\t\tif (compressionMethod === 'deflate') {\n\t\t\t// give deflate everything but the last 8 bytes\n\t\t\t// the last 8 bytes are for the CRC32 checksum and filesize\n\t\t\tres = deflate.inflate(arr.splice(0, arr.length - 8));\n\t\t}\n\n\t\tif (flags & possibleFlags['FTEXT']) {\n\t\t\tres = Array.prototype.map.call(res, function (byte) {\n\t\t\t\treturn String.fromCharCode(byte);\n\t\t\t}).join('');\n\t\t}\n\n\t\tcrc = readLong(arr);\n\t\tif (crc !== parseInt(crc32(res), 16)) {\n\t\t\tthrow 'Checksum does not match';\n\t\t}\n\n\t\tsize = readLong(arr);\n\t\tif (size !== res.length) {\n\t\t\tthrow 'Size of decompressed file not correct';\n\t\t}\n\n\t\treturn res;\n\t}\n\n\tmodule.exports = {\n\t\tzip: zip,\n\t\tunzip: unzip,\n\t\tget DEFAULT_LEVEL() {\n\t\t\treturn DEFAULT_LEVEL;\n\t\t}\n\t};\n}());\n","var wrappy = require('wrappy')\nvar reqs = Object.create(null)\nvar once = require('once')\n\nmodule.exports = wrappy(inflight)\n\nfunction inflight (key, cb) {\n  if (reqs[key]) {\n    reqs[key].push(cb)\n    return null\n  } else {\n    reqs[key] = [cb]\n    return makeres(key)\n  }\n}\n\nfunction makeres (key) {\n  return once(function RES () {\n    var cbs = reqs[key]\n    var len = cbs.length\n    var args = slice(arguments)\n\n    // XXX It's somewhat ambiguous whether a new callback added in this\n    // pass should be queued for later execution if something in the\n    // list of callbacks throws, or if it should just be discarded.\n    // However, it's such an edge case that it hardly matters, and either\n    // choice is likely as surprising as the other.\n    // As it happens, we do go ahead and schedule it for later execution.\n    try {\n      for (var i = 0; i < len; i++) {\n        cbs[i].apply(null, args)\n      }\n    } finally {\n      if (cbs.length > len) {\n        // added more in the interim.\n        // de-zalgo, just in case, but don't call again.\n        cbs.splice(0, len)\n        process.nextTick(function () {\n          RES.apply(null, args)\n        })\n      } else {\n        delete reqs[key]\n      }\n    }\n  })\n}\n\nfunction slice (args) {\n  var length = args.length\n  var array = []\n\n  for (var i = 0; i < length; i++) array[i] = args[i]\n  return array\n}\n","try {\n  var util = require('util');\n  /* istanbul ignore next */\n  if (typeof util.inherits !== 'function') throw '';\n  module.exports = util.inherits;\n} catch (e) {\n  /* istanbul ignore next */\n  module.exports = require('./inherits_browser.js');\n}\n","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n","let _fs\ntry {\n  _fs = require('graceful-fs')\n} catch (_) {\n  _fs = require('fs')\n}\nconst universalify = require('universalify')\nconst { stringify, stripBom } = require('./utils')\n\nasync function _readFile (file, options = {}) {\n  if (typeof options === 'string') {\n    options = { encoding: options }\n  }\n\n  const fs = options.fs || _fs\n\n  const shouldThrow = 'throws' in options ? options.throws : true\n\n  let data = await universalify.fromCallback(fs.readFile)(file, options)\n\n  data = stripBom(data)\n\n  let obj\n  try {\n    obj = JSON.parse(data, options ? options.reviver : null)\n  } catch (err) {\n    if (shouldThrow) {\n      err.message = `${file}: ${err.message}`\n      throw err\n    } else {\n      return null\n    }\n  }\n\n  return obj\n}\n\nconst readFile = universalify.fromPromise(_readFile)\n\nfunction readFileSync (file, options = {}) {\n  if (typeof options === 'string') {\n    options = { encoding: options }\n  }\n\n  const fs = options.fs || _fs\n\n  const shouldThrow = 'throws' in options ? options.throws : true\n\n  try {\n    let content = fs.readFileSync(file, options)\n    content = stripBom(content)\n    return JSON.parse(content, options.reviver)\n  } catch (err) {\n    if (shouldThrow) {\n      err.message = `${file}: ${err.message}`\n      throw err\n    } else {\n      return null\n    }\n  }\n}\n\nasync function _writeFile (file, obj, options = {}) {\n  const fs = options.fs || _fs\n\n  const str = stringify(obj, options)\n\n  await universalify.fromCallback(fs.writeFile)(file, str, options)\n}\n\nconst writeFile = universalify.fromPromise(_writeFile)\n\nfunction writeFileSync (file, obj, options = {}) {\n  const fs = options.fs || _fs\n\n  const str = stringify(obj, options)\n  // not sure if fs.writeFileSync returns anything, but just in case\n  return fs.writeFileSync(file, str, options)\n}\n\nconst jsonfile = {\n  readFile,\n  readFileSync,\n  writeFile,\n  writeFileSync\n}\n\nmodule.exports = jsonfile\n","'use strict'\n\nexports.fromCallback = function (fn) {\n  return Object.defineProperty(function (...args) {\n    if (typeof args[args.length - 1] === 'function') fn.apply(this, args)\n    else {\n      return new Promise((resolve, reject) => {\n        fn.call(\n          this,\n          ...args,\n          (err, res) => (err != null) ? reject(err) : resolve(res)\n        )\n      })\n    }\n  }, 'name', { value: fn.name })\n}\n\nexports.fromPromise = function (fn) {\n  return Object.defineProperty(function (...args) {\n    const cb = args[args.length - 1]\n    if (typeof cb !== 'function') return fn.apply(this, args)\n    else fn.apply(this, args.slice(0, -1)).then(r => cb(null, r), cb)\n  }, 'name', { value: fn.name })\n}\n","function stringify (obj, { EOL = '\\n', finalEOL = true, replacer = null, spaces } = {}) {\n  const EOF = finalEOL ? EOL : ''\n  const str = JSON.stringify(obj, replacer, spaces)\n\n  return str.replace(/\\n/g, EOL) + EOF\n}\n\nfunction stripBom (content) {\n  // we do this because JSON.parse would convert it to a utf8 string if encoding wasn't specified\n  if (Buffer.isBuffer(content)) content = content.toString('utf8')\n  return content.replace(/^\\uFEFF/, '')\n}\n\nmodule.exports = { stringify, stripBom }\n","module.exports = minimatch\nminimatch.Minimatch = Minimatch\n\nvar path = { sep: '/' }\ntry {\n  path = require('path')\n} catch (er) {}\n\nvar GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}\nvar expand = require('brace-expansion')\n\nvar plTypes = {\n  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},\n  '?': { open: '(?:', close: ')?' },\n  '+': { open: '(?:', close: ')+' },\n  '*': { open: '(?:', close: ')*' },\n  '@': { open: '(?:', close: ')' }\n}\n\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nvar qmark = '[^/]'\n\n// * => any number of characters\nvar star = qmark + '*?'\n\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nvar twoStarDot = '(?:(?!(?:\\\\\\/|^)(?:\\\\.{1,2})($|\\\\\\/)).)*?'\n\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nvar twoStarNoDot = '(?:(?!(?:\\\\\\/|^)\\\\.).)*?'\n\n// characters that need to be escaped in RegExp.\nvar reSpecials = charSet('().*{}+?[]^$\\\\!')\n\n// \"abc\" -> { a:true, b:true, c:true }\nfunction charSet (s) {\n  return s.split('').reduce(function (set, c) {\n    set[c] = true\n    return set\n  }, {})\n}\n\n// normalizes slashes.\nvar slashSplit = /\\/+/\n\nminimatch.filter = filter\nfunction filter (pattern, options) {\n  options = options || {}\n  return function (p, i, list) {\n    return minimatch(p, pattern, options)\n  }\n}\n\nfunction ext (a, b) {\n  a = a || {}\n  b = b || {}\n  var t = {}\n  Object.keys(b).forEach(function (k) {\n    t[k] = b[k]\n  })\n  Object.keys(a).forEach(function (k) {\n    t[k] = a[k]\n  })\n  return t\n}\n\nminimatch.defaults = function (def) {\n  if (!def || !Object.keys(def).length) return minimatch\n\n  var orig = minimatch\n\n  var m = function minimatch (p, pattern, options) {\n    return orig.minimatch(p, pattern, ext(def, options))\n  }\n\n  m.Minimatch = function Minimatch (pattern, options) {\n    return new orig.Minimatch(pattern, ext(def, options))\n  }\n\n  return m\n}\n\nMinimatch.defaults = function (def) {\n  if (!def || !Object.keys(def).length) return Minimatch\n  return minimatch.defaults(def).Minimatch\n}\n\nfunction minimatch (p, pattern, options) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('glob pattern string required')\n  }\n\n  if (!options) options = {}\n\n  // shortcut: comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    return false\n  }\n\n  // \"\" only matches \"\"\n  if (pattern.trim() === '') return p === ''\n\n  return new Minimatch(pattern, options).match(p)\n}\n\nfunction Minimatch (pattern, options) {\n  if (!(this instanceof Minimatch)) {\n    return new Minimatch(pattern, options)\n  }\n\n  if (typeof pattern !== 'string') {\n    throw new TypeError('glob pattern string required')\n  }\n\n  if (!options) options = {}\n  pattern = pattern.trim()\n\n  // windows support: need to use /, not \\\n  if (path.sep !== '/') {\n    pattern = pattern.split(path.sep).join('/')\n  }\n\n  this.options = options\n  this.set = []\n  this.pattern = pattern\n  this.regexp = null\n  this.negate = false\n  this.comment = false\n  this.empty = false\n\n  // make the set of regexps etc.\n  this.make()\n}\n\nMinimatch.prototype.debug = function () {}\n\nMinimatch.prototype.make = make\nfunction make () {\n  // don't do it more than once.\n  if (this._made) return\n\n  var pattern = this.pattern\n  var options = this.options\n\n  // empty patterns and comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    this.comment = true\n    return\n  }\n  if (!pattern) {\n    this.empty = true\n    return\n  }\n\n  // step 1: figure out negation, etc.\n  this.parseNegate()\n\n  // step 2: expand braces\n  var set = this.globSet = this.braceExpand()\n\n  if (options.debug) this.debug = console.error\n\n  this.debug(this.pattern, set)\n\n  // step 3: now we have a set, so turn each one into a series of path-portion\n  // matching patterns.\n  // These will be regexps, except in the case of \"**\", which is\n  // set to the GLOBSTAR object for globstar behavior,\n  // and will not contain any / characters\n  set = this.globParts = set.map(function (s) {\n    return s.split(slashSplit)\n  })\n\n  this.debug(this.pattern, set)\n\n  // glob --> regexps\n  set = set.map(function (s, si, set) {\n    return s.map(this.parse, this)\n  }, this)\n\n  this.debug(this.pattern, set)\n\n  // filter out everything that didn't compile properly.\n  set = set.filter(function (s) {\n    return s.indexOf(false) === -1\n  })\n\n  this.debug(this.pattern, set)\n\n  this.set = set\n}\n\nMinimatch.prototype.parseNegate = parseNegate\nfunction parseNegate () {\n  var pattern = this.pattern\n  var negate = false\n  var options = this.options\n  var negateOffset = 0\n\n  if (options.nonegate) return\n\n  for (var i = 0, l = pattern.length\n    ; i < l && pattern.charAt(i) === '!'\n    ; i++) {\n    negate = !negate\n    negateOffset++\n  }\n\n  if (negateOffset) this.pattern = pattern.substr(negateOffset)\n  this.negate = negate\n}\n\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nminimatch.braceExpand = function (pattern, options) {\n  return braceExpand(pattern, options)\n}\n\nMinimatch.prototype.braceExpand = braceExpand\n\nfunction braceExpand (pattern, options) {\n  if (!options) {\n    if (this instanceof Minimatch) {\n      options = this.options\n    } else {\n      options = {}\n    }\n  }\n\n  pattern = typeof pattern === 'undefined'\n    ? this.pattern : pattern\n\n  if (typeof pattern === 'undefined') {\n    throw new TypeError('undefined pattern')\n  }\n\n  if (options.nobrace ||\n    !pattern.match(/\\{.*\\}/)) {\n    // shortcut. no need to expand.\n    return [pattern]\n  }\n\n  return expand(pattern)\n}\n\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nMinimatch.prototype.parse = parse\nvar SUBPARSE = {}\nfunction parse (pattern, isSub) {\n  if (pattern.length > 1024 * 64) {\n    throw new TypeError('pattern is too long')\n  }\n\n  var options = this.options\n\n  // shortcuts\n  if (!options.noglobstar && pattern === '**') return GLOBSTAR\n  if (pattern === '') return ''\n\n  var re = ''\n  var hasMagic = !!options.nocase\n  var escaping = false\n  // ? => one single character\n  var patternListStack = []\n  var negativeLists = []\n  var stateChar\n  var inClass = false\n  var reClassStart = -1\n  var classStart = -1\n  // . and .. never match anything that doesn't start with .,\n  // even when options.dot is set.\n  var patternStart = pattern.charAt(0) === '.' ? '' // anything\n  // not (start or / followed by . or .. followed by / or end)\n  : options.dot ? '(?!(?:^|\\\\\\/)\\\\.{1,2}(?:$|\\\\\\/))'\n  : '(?!\\\\.)'\n  var self = this\n\n  function clearStateChar () {\n    if (stateChar) {\n      // we had some state-tracking character\n      // that wasn't consumed by this pass.\n      switch (stateChar) {\n        case '*':\n          re += star\n          hasMagic = true\n        break\n        case '?':\n          re += qmark\n          hasMagic = true\n        break\n        default:\n          re += '\\\\' + stateChar\n        break\n      }\n      self.debug('clearStateChar %j %j', stateChar, re)\n      stateChar = false\n    }\n  }\n\n  for (var i = 0, len = pattern.length, c\n    ; (i < len) && (c = pattern.charAt(i))\n    ; i++) {\n    this.debug('%s\\t%s %s %j', pattern, i, re, c)\n\n    // skip over any that are escaped.\n    if (escaping && reSpecials[c]) {\n      re += '\\\\' + c\n      escaping = false\n      continue\n    }\n\n    switch (c) {\n      case '/':\n        // completely not allowed, even escaped.\n        // Should already be path-split by now.\n        return false\n\n      case '\\\\':\n        clearStateChar()\n        escaping = true\n      continue\n\n      // the various stateChar values\n      // for the \"extglob\" stuff.\n      case '?':\n      case '*':\n      case '+':\n      case '@':\n      case '!':\n        this.debug('%s\\t%s %s %j <-- stateChar', pattern, i, re, c)\n\n        // all of those are literals inside a class, except that\n        // the glob [!a] means [^a] in regexp\n        if (inClass) {\n          this.debug('  in class')\n          if (c === '!' && i === classStart + 1) c = '^'\n          re += c\n          continue\n        }\n\n        // if we already have a stateChar, then it means\n        // that there was something like ** or +? in there.\n        // Handle the stateChar, then proceed with this one.\n        self.debug('call clearStateChar %j', stateChar)\n        clearStateChar()\n        stateChar = c\n        // if extglob is disabled, then +(asdf|foo) isn't a thing.\n        // just clear the statechar *now*, rather than even diving into\n        // the patternList stuff.\n        if (options.noext) clearStateChar()\n      continue\n\n      case '(':\n        if (inClass) {\n          re += '('\n          continue\n        }\n\n        if (!stateChar) {\n          re += '\\\\('\n          continue\n        }\n\n        patternListStack.push({\n          type: stateChar,\n          start: i - 1,\n          reStart: re.length,\n          open: plTypes[stateChar].open,\n          close: plTypes[stateChar].close\n        })\n        // negation is (?:(?!js)[^/]*)\n        re += stateChar === '!' ? '(?:(?!(?:' : '(?:'\n        this.debug('plType %j %j', stateChar, re)\n        stateChar = false\n      continue\n\n      case ')':\n        if (inClass || !patternListStack.length) {\n          re += '\\\\)'\n          continue\n        }\n\n        clearStateChar()\n        hasMagic = true\n        var pl = patternListStack.pop()\n        // negation is (?:(?!js)[^/]*)\n        // The others are (?:<pattern>)<type>\n        re += pl.close\n        if (pl.type === '!') {\n          negativeLists.push(pl)\n        }\n        pl.reEnd = re.length\n      continue\n\n      case '|':\n        if (inClass || !patternListStack.length || escaping) {\n          re += '\\\\|'\n          escaping = false\n          continue\n        }\n\n        clearStateChar()\n        re += '|'\n      continue\n\n      // these are mostly the same in regexp and glob\n      case '[':\n        // swallow any state-tracking char before the [\n        clearStateChar()\n\n        if (inClass) {\n          re += '\\\\' + c\n          continue\n        }\n\n        inClass = true\n        classStart = i\n        reClassStart = re.length\n        re += c\n      continue\n\n      case ']':\n        //  a right bracket shall lose its special\n        //  meaning and represent itself in\n        //  a bracket expression if it occurs\n        //  first in the list.  -- POSIX.2 2.8.3.2\n        if (i === classStart + 1 || !inClass) {\n          re += '\\\\' + c\n          escaping = false\n          continue\n        }\n\n        // handle the case where we left a class open.\n        // \"[z-a]\" is valid, equivalent to \"\\[z-a\\]\"\n        if (inClass) {\n          // split where the last [ was, make sure we don't have\n          // an invalid re. if so, re-walk the contents of the\n          // would-be class to re-translate any characters that\n          // were passed through as-is\n          // TODO: It would probably be faster to determine this\n          // without a try/catch and a new RegExp, but it's tricky\n          // to do safely.  For now, this is safe and works.\n          var cs = pattern.substring(classStart + 1, i)\n          try {\n            RegExp('[' + cs + ']')\n          } catch (er) {\n            // not a valid class!\n            var sp = this.parse(cs, SUBPARSE)\n            re = re.substr(0, reClassStart) + '\\\\[' + sp[0] + '\\\\]'\n            hasMagic = hasMagic || sp[1]\n            inClass = false\n            continue\n          }\n        }\n\n        // finish up the class.\n        hasMagic = true\n        inClass = false\n        re += c\n      continue\n\n      default:\n        // swallow any state char that wasn't consumed\n        clearStateChar()\n\n        if (escaping) {\n          // no need\n          escaping = false\n        } else if (reSpecials[c]\n          && !(c === '^' && inClass)) {\n          re += '\\\\'\n        }\n\n        re += c\n\n    } // switch\n  } // for\n\n  // handle the case where we left a class open.\n  // \"[abc\" is valid, equivalent to \"\\[abc\"\n  if (inClass) {\n    // split where the last [ was, and escape it\n    // this is a huge pita.  We now have to re-walk\n    // the contents of the would-be class to re-translate\n    // any characters that were passed through as-is\n    cs = pattern.substr(classStart + 1)\n    sp = this.parse(cs, SUBPARSE)\n    re = re.substr(0, reClassStart) + '\\\\[' + sp[0]\n    hasMagic = hasMagic || sp[1]\n  }\n\n  // handle the case where we had a +( thing at the *end*\n  // of the pattern.\n  // each pattern list stack adds 3 chars, and we need to go through\n  // and escape any | chars that were passed through as-is for the regexp.\n  // Go through and escape them, taking care not to double-escape any\n  // | chars that were already escaped.\n  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {\n    var tail = re.slice(pl.reStart + pl.open.length)\n    this.debug('setting tail', re, pl)\n    // maybe some even number of \\, then maybe 1 \\, followed by a |\n    tail = tail.replace(/((?:\\\\{2}){0,64})(\\\\?)\\|/g, function (_, $1, $2) {\n      if (!$2) {\n        // the | isn't already escaped, so escape it.\n        $2 = '\\\\'\n      }\n\n      // need to escape all those slashes *again*, without escaping the\n      // one that we need for escaping the | character.  As it works out,\n      // escaping an even number of slashes can be done by simply repeating\n      // it exactly after itself.  That's why this trick works.\n      //\n      // I am sorry that you have to see this.\n      return $1 + $1 + $2 + '|'\n    })\n\n    this.debug('tail=%j\\n   %s', tail, tail, pl, re)\n    var t = pl.type === '*' ? star\n      : pl.type === '?' ? qmark\n      : '\\\\' + pl.type\n\n    hasMagic = true\n    re = re.slice(0, pl.reStart) + t + '\\\\(' + tail\n  }\n\n  // handle trailing things that only matter at the very end.\n  clearStateChar()\n  if (escaping) {\n    // trailing \\\\\n    re += '\\\\\\\\'\n  }\n\n  // only need to apply the nodot start if the re starts with\n  // something that could conceivably capture a dot\n  var addPatternStart = false\n  switch (re.charAt(0)) {\n    case '.':\n    case '[':\n    case '(': addPatternStart = true\n  }\n\n  // Hack to work around lack of negative lookbehind in JS\n  // A pattern like: *.!(x).!(y|z) needs to ensure that a name\n  // like 'a.xyz.yz' doesn't match.  So, the first negative\n  // lookahead, has to look ALL the way ahead, to the end of\n  // the pattern.\n  for (var n = negativeLists.length - 1; n > -1; n--) {\n    var nl = negativeLists[n]\n\n    var nlBefore = re.slice(0, nl.reStart)\n    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)\n    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)\n    var nlAfter = re.slice(nl.reEnd)\n\n    nlLast += nlAfter\n\n    // Handle nested stuff like *(*.js|!(*.json)), where open parens\n    // mean that we should *not* include the ) in the bit that is considered\n    // \"after\" the negated section.\n    var openParensBefore = nlBefore.split('(').length - 1\n    var cleanAfter = nlAfter\n    for (i = 0; i < openParensBefore; i++) {\n      cleanAfter = cleanAfter.replace(/\\)[+*?]?/, '')\n    }\n    nlAfter = cleanAfter\n\n    var dollar = ''\n    if (nlAfter === '' && isSub !== SUBPARSE) {\n      dollar = '$'\n    }\n    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast\n    re = newRe\n  }\n\n  // if the re is not \"\" at this point, then we need to make sure\n  // it doesn't match against an empty path part.\n  // Otherwise a/* will match a/, which it should not.\n  if (re !== '' && hasMagic) {\n    re = '(?=.)' + re\n  }\n\n  if (addPatternStart) {\n    re = patternStart + re\n  }\n\n  // parsing just a piece of a larger pattern.\n  if (isSub === SUBPARSE) {\n    return [re, hasMagic]\n  }\n\n  // skip the regexp for non-magical patterns\n  // unescape anything in it, though, so that it'll be\n  // an exact match against a file etc.\n  if (!hasMagic) {\n    return globUnescape(pattern)\n  }\n\n  var flags = options.nocase ? 'i' : ''\n  try {\n    var regExp = new RegExp('^' + re + '$', flags)\n  } catch (er) {\n    // If it was an invalid regular expression, then it can't match\n    // anything.  This trick looks for a character after the end of\n    // the string, which is of course impossible, except in multi-line\n    // mode, but it's not a /m regex.\n    return new RegExp('$.')\n  }\n\n  regExp._glob = pattern\n  regExp._src = re\n\n  return regExp\n}\n\nminimatch.makeRe = function (pattern, options) {\n  return new Minimatch(pattern, options || {}).makeRe()\n}\n\nMinimatch.prototype.makeRe = makeRe\nfunction makeRe () {\n  if (this.regexp || this.regexp === false) return this.regexp\n\n  // at this point, this.set is a 2d array of partial\n  // pattern strings, or \"**\".\n  //\n  // It's better to use .match().  This function shouldn't\n  // be used, really, but it's pretty convenient sometimes,\n  // when you just want to work with a regex.\n  var set = this.set\n\n  if (!set.length) {\n    this.regexp = false\n    return this.regexp\n  }\n  var options = this.options\n\n  var twoStar = options.noglobstar ? star\n    : options.dot ? twoStarDot\n    : twoStarNoDot\n  var flags = options.nocase ? 'i' : ''\n\n  var re = set.map(function (pattern) {\n    return pattern.map(function (p) {\n      return (p === GLOBSTAR) ? twoStar\n      : (typeof p === 'string') ? regExpEscape(p)\n      : p._src\n    }).join('\\\\\\/')\n  }).join('|')\n\n  // must match entire pattern\n  // ending in a * or ** will make it less strict.\n  re = '^(?:' + re + ')$'\n\n  // can match anything, as long as it's not this.\n  if (this.negate) re = '^(?!' + re + ').*$'\n\n  try {\n    this.regexp = new RegExp(re, flags)\n  } catch (ex) {\n    this.regexp = false\n  }\n  return this.regexp\n}\n\nminimatch.match = function (list, pattern, options) {\n  options = options || {}\n  var mm = new Minimatch(pattern, options)\n  list = list.filter(function (f) {\n    return mm.match(f)\n  })\n  if (mm.options.nonull && !list.length) {\n    list.push(pattern)\n  }\n  return list\n}\n\nMinimatch.prototype.match = match\nfunction match (f, partial) {\n  this.debug('match', f, this.pattern)\n  // short-circuit in the case of busted things.\n  // comments, etc.\n  if (this.comment) return false\n  if (this.empty) return f === ''\n\n  if (f === '/' && partial) return true\n\n  var options = this.options\n\n  // windows: need to use /, not \\\n  if (path.sep !== '/') {\n    f = f.split(path.sep).join('/')\n  }\n\n  // treat the test path as a set of pathparts.\n  f = f.split(slashSplit)\n  this.debug(this.pattern, 'split', f)\n\n  // just ONE of the pattern sets in this.set needs to match\n  // in order for it to be valid.  If negating, then just one\n  // match means that we have failed.\n  // Either way, return on the first hit.\n\n  var set = this.set\n  this.debug(this.pattern, 'set', set)\n\n  // Find the basename of the path by looking for the last non-empty segment\n  var filename\n  var i\n  for (i = f.length - 1; i >= 0; i--) {\n    filename = f[i]\n    if (filename) break\n  }\n\n  for (i = 0; i < set.length; i++) {\n    var pattern = set[i]\n    var file = f\n    if (options.matchBase && pattern.length === 1) {\n      file = [filename]\n    }\n    var hit = this.matchOne(file, pattern, partial)\n    if (hit) {\n      if (options.flipNegate) return true\n      return !this.negate\n    }\n  }\n\n  // didn't get any hits.  this is success if it's a negative\n  // pattern, failure otherwise.\n  if (options.flipNegate) return false\n  return this.negate\n}\n\n// set partial to true to test if, for example,\n// \"/a/b\" matches the start of \"/*/b/*/d\"\n// Partial means, if you run out of file before you run\n// out of pattern, then that's fine, as long as all\n// the parts match.\nMinimatch.prototype.matchOne = function (file, pattern, partial) {\n  var options = this.options\n\n  this.debug('matchOne',\n    { 'this': this, file: file, pattern: pattern })\n\n  this.debug('matchOne', file.length, pattern.length)\n\n  for (var fi = 0,\n      pi = 0,\n      fl = file.length,\n      pl = pattern.length\n      ; (fi < fl) && (pi < pl)\n      ; fi++, pi++) {\n    this.debug('matchOne loop')\n    var p = pattern[pi]\n    var f = file[fi]\n\n    this.debug(pattern, p, f)\n\n    // should be impossible.\n    // some invalid regexp stuff in the set.\n    if (p === false) return false\n\n    if (p === GLOBSTAR) {\n      this.debug('GLOBSTAR', [pattern, p, f])\n\n      // \"**\"\n      // a/**/b/**/c would match the following:\n      // a/b/x/y/z/c\n      // a/x/y/z/b/c\n      // a/b/x/b/x/c\n      // a/b/c\n      // To do this, take the rest of the pattern after\n      // the **, and see if it would match the file remainder.\n      // If so, return success.\n      // If not, the ** \"swallows\" a segment, and try again.\n      // This is recursively awful.\n      //\n      // a/**/b/**/c matching a/b/x/y/z/c\n      // - a matches a\n      // - doublestar\n      //   - matchOne(b/x/y/z/c, b/**/c)\n      //     - b matches b\n      //     - doublestar\n      //       - matchOne(x/y/z/c, c) -> no\n      //       - matchOne(y/z/c, c) -> no\n      //       - matchOne(z/c, c) -> no\n      //       - matchOne(c, c) yes, hit\n      var fr = fi\n      var pr = pi + 1\n      if (pr === pl) {\n        this.debug('** at the end')\n        // a ** at the end will just swallow the rest.\n        // We have found a match.\n        // however, it will not swallow /.x, unless\n        // options.dot is set.\n        // . and .. are *never* matched by **, for explosively\n        // exponential reasons.\n        for (; fi < fl; fi++) {\n          if (file[fi] === '.' || file[fi] === '..' ||\n            (!options.dot && file[fi].charAt(0) === '.')) return false\n        }\n        return true\n      }\n\n      // ok, let's see if we can swallow whatever we can.\n      while (fr < fl) {\n        var swallowee = file[fr]\n\n        this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee)\n\n        // XXX remove this slice.  Just pass the start index.\n        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n          this.debug('globstar found match!', fr, fl, swallowee)\n          // found a match.\n          return true\n        } else {\n          // can't swallow \".\" or \"..\" ever.\n          // can only swallow \".foo\" when explicitly asked.\n          if (swallowee === '.' || swallowee === '..' ||\n            (!options.dot && swallowee.charAt(0) === '.')) {\n            this.debug('dot detected!', file, fr, pattern, pr)\n            break\n          }\n\n          // ** swallows a segment, and continue.\n          this.debug('globstar swallow a segment, and continue')\n          fr++\n        }\n      }\n\n      // no match was found.\n      // However, in partial mode, we can't say this is necessarily over.\n      // If there's more *pattern* left, then\n      if (partial) {\n        // ran out of file\n        this.debug('\\n>>> no match, partial?', file, fr, pattern, pr)\n        if (fr === fl) return true\n      }\n      return false\n    }\n\n    // something other than **\n    // non-magic patterns just have to match exactly\n    // patterns with magic have been turned into regexps.\n    var hit\n    if (typeof p === 'string') {\n      if (options.nocase) {\n        hit = f.toLowerCase() === p.toLowerCase()\n      } else {\n        hit = f === p\n      }\n      this.debug('string match', p, f, hit)\n    } else {\n      hit = f.match(p)\n      this.debug('pattern match', p, f, hit)\n    }\n\n    if (!hit) return false\n  }\n\n  // Note: ending in / means that we'll get a final \"\"\n  // at the end of the pattern.  This can only match a\n  // corresponding \"\" at the end of the file.\n  // If the file ends in /, then it can only match a\n  // a pattern that ends in /, unless the pattern just\n  // doesn't have any more for it. But, a/b/ should *not*\n  // match \"a/b/*\", even though \"\" matches against the\n  // [^/]*? pattern, except in partial mode, where it might\n  // simply not be reached yet.\n  // However, a/b/ should still satisfy a/*\n\n  // now either we fell off the end of the pattern, or we're done.\n  if (fi === fl && pi === pl) {\n    // ran out of pattern and filename at the same time.\n    // an exact hit!\n    return true\n  } else if (fi === fl) {\n    // ran out of file, but still had pattern left.\n    // this is ok if we're doing the match as part of\n    // a glob fs traversal.\n    return partial\n  } else if (pi === pl) {\n    // ran out of pattern, still have file left.\n    // this is only acceptable if we're on the very last\n    // empty segment of a file with a trailing slash.\n    // a/* should match a/b/\n    var emptyFileEnd = (fi === fl - 1) && (file[fi] === '')\n    return emptyFileEnd\n  }\n\n  // should be unreachable.\n  throw new Error('wtf?')\n}\n\n// replace stuff like \\* with *\nfunction globUnescape (s) {\n  return s.replace(/\\\\(.)/g, '$1')\n}\n\nfunction regExpEscape (s) {\n  return s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n}\n","var wrappy = require('wrappy')\nmodule.exports = wrappy(once)\nmodule.exports.strict = wrappy(onceStrict)\n\nonce.proto = once(function () {\n  Object.defineProperty(Function.prototype, 'once', {\n    value: function () {\n      return once(this)\n    },\n    configurable: true\n  })\n\n  Object.defineProperty(Function.prototype, 'onceStrict', {\n    value: function () {\n      return onceStrict(this)\n    },\n    configurable: true\n  })\n})\n\nfunction once (fn) {\n  var f = function () {\n    if (f.called) return f.value\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  f.called = false\n  return f\n}\n\nfunction onceStrict (fn) {\n  var f = function () {\n    if (f.called)\n      throw new Error(f.onceError)\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  var name = fn.name || 'Function wrapped with `once`'\n  f.onceError = name + \" shouldn't be called more than once\"\n  f.called = false\n  return f\n}\n","'use strict';\n\nfunction posix(path) {\n\treturn path.charAt(0) === '/';\n}\n\nfunction win32(path) {\n\t// https://github.com/nodejs/node/blob/b3fcc245fb25539909ef1d5eaa01dbf92e168633/lib/path.js#L56\n\tvar splitDeviceRe = /^([a-zA-Z]:|[\\\\\\/]{2}[^\\\\\\/]+[\\\\\\/]+[^\\\\\\/]+)?([\\\\\\/])?([\\s\\S]*?)$/;\n\tvar result = splitDeviceRe.exec(path);\n\tvar device = result[1] || '';\n\tvar isUnc = Boolean(device && device.charAt(1) !== ':');\n\n\t// UNC paths are always absolute\n\treturn Boolean(result[2] || isUnc);\n}\n\nmodule.exports = process.platform === 'win32' ? win32 : posix;\nmodule.exports.posix = posix;\nmodule.exports.win32 = win32;\n","module.exports = [\n  'cat',\n  'cd',\n  'chmod',\n  'cp',\n  'dirs',\n  'echo',\n  'exec',\n  'find',\n  'grep',\n  'head',\n  'ln',\n  'ls',\n  'mkdir',\n  'mv',\n  'pwd',\n  'rm',\n  'sed',\n  'set',\n  'sort',\n  'tail',\n  'tempdir',\n  'test',\n  'to',\n  'toEnd',\n  'touch',\n  'uniq',\n  'which',\n];\n","//\n// ShellJS\n// Unix shell commands on top of Node's API\n//\n// Copyright (c) 2012 Artur Adib\n// http://github.com/shelljs/shelljs\n//\n\nvar common = require('./src/common');\n\n//@\n//@ All commands run synchronously, unless otherwise stated.\n//@ All commands accept standard bash globbing characters (`*`, `?`, etc.),\n//@ compatible with the [node `glob` module](https://github.com/isaacs/node-glob).\n//@\n//@ For less-commonly used commands and features, please check out our [wiki\n//@ page](https://github.com/shelljs/shelljs/wiki).\n//@\n\n// Include the docs for all the default commands\n//@commands\n\n// Load all default commands\nrequire('./commands').forEach(function (command) {\n  require('./src/' + command);\n});\n\n//@\n//@ ### exit(code)\n//@\n//@ Exits the current process with the given exit `code`.\nexports.exit = process.exit;\n\n//@include ./src/error\nexports.error = require('./src/error');\n\n//@include ./src/common\nexports.ShellString = common.ShellString;\n\n//@\n//@ ### env['VAR_NAME']\n//@\n//@ Object containing environment variables (both getter and setter). Shortcut\n//@ to `process.env`.\nexports.env = process.env;\n\n//@\n//@ ### Pipes\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ grep('foo', 'file1.txt', 'file2.txt').sed(/o/g, 'a').to('output.txt');\n//@ echo('files with o\\'s in the name:\\n' + ls().grep('o'));\n//@ cat('test.js').exec('node'); // pipe to exec() call\n//@ ```\n//@\n//@ Commands can send their output to another command in a pipe-like fashion.\n//@ `sed`, `grep`, `cat`, `exec`, `to`, and `toEnd` can appear on the right-hand\n//@ side of a pipe. Pipes can be chained.\n\n//@\n//@ ## Configuration\n//@\n\nexports.config = common.config;\n\n//@\n//@ ### config.silent\n//@\n//@ Example:\n//@\n//@ ```javascript\n//@ var sh = require('shelljs');\n//@ var silentState = sh.config.silent; // save old silent state\n//@ sh.config.silent = true;\n//@ /* ... */\n//@ sh.config.silent = silentState; // restore old silent state\n//@ ```\n//@\n//@ Suppresses all command output if `true`, except for `echo()` calls.\n//@ Default is `false`.\n\n//@\n//@ ### config.fatal\n//@\n//@ Example:\n//@\n//@ ```javascript\n//@ require('shelljs/global');\n//@ config.fatal = true; // or set('-e');\n//@ cp('this_file_does_not_exist', '/dev/null'); // throws Error here\n//@ /* more commands... */\n//@ ```\n//@\n//@ If `true`, the script will throw a Javascript error when any shell.js\n//@ command encounters an error. Default is `false`. This is analogous to\n//@ Bash's `set -e`.\n\n//@\n//@ ### config.verbose\n//@\n//@ Example:\n//@\n//@ ```javascript\n//@ config.verbose = true; // or set('-v');\n//@ cd('dir/');\n//@ rm('-rf', 'foo.txt', 'bar.txt');\n//@ exec('echo hello');\n//@ ```\n//@\n//@ Will print each command as follows:\n//@\n//@ ```\n//@ cd dir/\n//@ rm -rf foo.txt bar.txt\n//@ exec echo hello\n//@ ```\n\n//@\n//@ ### config.globOptions\n//@\n//@ Example:\n//@\n//@ ```javascript\n//@ config.globOptions = {nodir: true};\n//@ ```\n//@\n//@ Use this value for calls to `glob.sync()` instead of the default options.\n\n//@\n//@ ### config.reset()\n//@\n//@ Example:\n//@\n//@ ```javascript\n//@ var shell = require('shelljs');\n//@ // Make changes to shell.config, and do stuff...\n//@ /* ... */\n//@ shell.config.reset(); // reset to original state\n//@ // Do more stuff, but with original settings\n//@ /* ... */\n//@ ```\n//@\n//@ Reset `shell.config` to the defaults:\n//@\n//@ ```javascript\n//@ {\n//@   fatal: false,\n//@   globOptions: {},\n//@   maxdepth: 255,\n//@   noglob: false,\n//@   silent: false,\n//@   verbose: false,\n//@ }\n//@ ```\n","var map = {\n\t\"./cat\": \"./node_modules/shelljs/src/cat.js\",\n\t\"./cat.js\": \"./node_modules/shelljs/src/cat.js\",\n\t\"./cd\": \"./node_modules/shelljs/src/cd.js\",\n\t\"./cd.js\": \"./node_modules/shelljs/src/cd.js\",\n\t\"./chmod\": \"./node_modules/shelljs/src/chmod.js\",\n\t\"./chmod.js\": \"./node_modules/shelljs/src/chmod.js\",\n\t\"./common\": \"./node_modules/shelljs/src/common.js\",\n\t\"./common.js\": \"./node_modules/shelljs/src/common.js\",\n\t\"./cp\": \"./node_modules/shelljs/src/cp.js\",\n\t\"./cp.js\": \"./node_modules/shelljs/src/cp.js\",\n\t\"./dirs\": \"./node_modules/shelljs/src/dirs.js\",\n\t\"./dirs.js\": \"./node_modules/shelljs/src/dirs.js\",\n\t\"./echo\": \"./node_modules/shelljs/src/echo.js\",\n\t\"./echo.js\": \"./node_modules/shelljs/src/echo.js\",\n\t\"./error\": \"./node_modules/shelljs/src/error.js\",\n\t\"./error.js\": \"./node_modules/shelljs/src/error.js\",\n\t\"./exec\": \"./node_modules/shelljs/src/exec.js\",\n\t\"./exec-child\": \"./node_modules/shelljs/src/exec-child.js\",\n\t\"./exec-child.js\": \"./node_modules/shelljs/src/exec-child.js\",\n\t\"./exec.js\": \"./node_modules/shelljs/src/exec.js\",\n\t\"./find\": \"./node_modules/shelljs/src/find.js\",\n\t\"./find.js\": \"./node_modules/shelljs/src/find.js\",\n\t\"./grep\": \"./node_modules/shelljs/src/grep.js\",\n\t\"./grep.js\": \"./node_modules/shelljs/src/grep.js\",\n\t\"./head\": \"./node_modules/shelljs/src/head.js\",\n\t\"./head.js\": \"./node_modules/shelljs/src/head.js\",\n\t\"./ln\": \"./node_modules/shelljs/src/ln.js\",\n\t\"./ln.js\": \"./node_modules/shelljs/src/ln.js\",\n\t\"./ls\": \"./node_modules/shelljs/src/ls.js\",\n\t\"./ls.js\": \"./node_modules/shelljs/src/ls.js\",\n\t\"./mkdir\": \"./node_modules/shelljs/src/mkdir.js\",\n\t\"./mkdir.js\": \"./node_modules/shelljs/src/mkdir.js\",\n\t\"./mv\": \"./node_modules/shelljs/src/mv.js\",\n\t\"./mv.js\": \"./node_modules/shelljs/src/mv.js\",\n\t\"./popd\": \"./node_modules/shelljs/src/popd.js\",\n\t\"./popd.js\": \"./node_modules/shelljs/src/popd.js\",\n\t\"./pushd\": \"./node_modules/shelljs/src/pushd.js\",\n\t\"./pushd.js\": \"./node_modules/shelljs/src/pushd.js\",\n\t\"./pwd\": \"./node_modules/shelljs/src/pwd.js\",\n\t\"./pwd.js\": \"./node_modules/shelljs/src/pwd.js\",\n\t\"./rm\": \"./node_modules/shelljs/src/rm.js\",\n\t\"./rm.js\": \"./node_modules/shelljs/src/rm.js\",\n\t\"./sed\": \"./node_modules/shelljs/src/sed.js\",\n\t\"./sed.js\": \"./node_modules/shelljs/src/sed.js\",\n\t\"./set\": \"./node_modules/shelljs/src/set.js\",\n\t\"./set.js\": \"./node_modules/shelljs/src/set.js\",\n\t\"./sort\": \"./node_modules/shelljs/src/sort.js\",\n\t\"./sort.js\": \"./node_modules/shelljs/src/sort.js\",\n\t\"./tail\": \"./node_modules/shelljs/src/tail.js\",\n\t\"./tail.js\": \"./node_modules/shelljs/src/tail.js\",\n\t\"./tempdir\": \"./node_modules/shelljs/src/tempdir.js\",\n\t\"./tempdir.js\": \"./node_modules/shelljs/src/tempdir.js\",\n\t\"./test\": \"./node_modules/shelljs/src/test.js\",\n\t\"./test.js\": \"./node_modules/shelljs/src/test.js\",\n\t\"./to\": \"./node_modules/shelljs/src/to.js\",\n\t\"./to.js\": \"./node_modules/shelljs/src/to.js\",\n\t\"./toEnd\": \"./node_modules/shelljs/src/toEnd.js\",\n\t\"./toEnd.js\": \"./node_modules/shelljs/src/toEnd.js\",\n\t\"./touch\": \"./node_modules/shelljs/src/touch.js\",\n\t\"./touch.js\": \"./node_modules/shelljs/src/touch.js\",\n\t\"./uniq\": \"./node_modules/shelljs/src/uniq.js\",\n\t\"./uniq.js\": \"./node_modules/shelljs/src/uniq.js\",\n\t\"./which\": \"./node_modules/shelljs/src/which.js\",\n\t\"./which.js\": \"./node_modules/shelljs/src/which.js\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"./node_modules/shelljs/src sync recursive ^\\\\.\\\\/.*$\";","var common = require('./common');\nvar fs = require('fs');\n\ncommon.register('cat', _cat, {\n  canReceivePipe: true,\n  cmdOptions: {\n    'n': 'number',\n  },\n});\n\n//@\n//@ ### cat([options,] file [, file ...])\n//@ ### cat([options,] file_array)\n//@\n//@ Available options:\n//@\n//@ + `-n`: number all output lines\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ var str = cat('file*.txt');\n//@ var str = cat('file1', 'file2');\n//@ var str = cat(['file1', 'file2']); // same as above\n//@ ```\n//@\n//@ Returns a string containing the given file, or a concatenated string\n//@ containing the files if more than one file is given (a new line character is\n//@ introduced between each file).\nfunction _cat(options, files) {\n  var cat = common.readFromPipe();\n\n  if (!files && !cat) common.error('no paths given');\n\n  files = [].slice.call(arguments, 1);\n\n  files.forEach(function (file) {\n    if (!fs.existsSync(file)) {\n      common.error('no such file or directory: ' + file);\n    } else if (common.statFollowLinks(file).isDirectory()) {\n      common.error(file + ': Is a directory');\n    }\n\n    cat += fs.readFileSync(file, 'utf8');\n  });\n\n  if (options.number) {\n    cat = addNumbers(cat);\n  }\n\n  return cat;\n}\nmodule.exports = _cat;\n\nfunction addNumbers(cat) {\n  var lines = cat.split('\\n');\n  var lastLine = lines.pop();\n\n  lines = lines.map(function (line, i) {\n    return numberedLine(i + 1, line);\n  });\n\n  if (lastLine.length) {\n    lastLine = numberedLine(lines.length + 1, lastLine);\n  }\n  lines.push(lastLine);\n\n  return lines.join('\\n');\n}\n\nfunction numberedLine(n, line) {\n  // GNU cat use six pad start number + tab. See http://lingrok.org/xref/coreutils/src/cat.c#57\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/padStart\n  var number = ('     ' + n).slice(-6) + '\\t';\n  return number + line;\n}\n","var os = require('os');\nvar common = require('./common');\n\ncommon.register('cd', _cd, {});\n\n//@\n//@ ### cd([dir])\n//@\n//@ Changes to directory `dir` for the duration of the script. Changes to home\n//@ directory if no argument is supplied.\nfunction _cd(options, dir) {\n  if (!dir) dir = os.homedir();\n\n  if (dir === '-') {\n    if (!process.env.OLDPWD) {\n      common.error('could not find previous directory');\n    } else {\n      dir = process.env.OLDPWD;\n    }\n  }\n\n  try {\n    var curDir = process.cwd();\n    process.chdir(dir);\n    process.env.OLDPWD = curDir;\n  } catch (e) {\n    // something went wrong, let's figure out the error\n    var err;\n    try {\n      common.statFollowLinks(dir); // if this succeeds, it must be some sort of file\n      err = 'not a directory: ' + dir;\n    } catch (e2) {\n      err = 'no such file or directory: ' + dir;\n    }\n    if (err) common.error(err);\n  }\n  return '';\n}\nmodule.exports = _cd;\n","var common = require('./common');\nvar fs = require('fs');\nvar path = require('path');\n\nvar PERMS = (function (base) {\n  return {\n    OTHER_EXEC: base.EXEC,\n    OTHER_WRITE: base.WRITE,\n    OTHER_READ: base.READ,\n\n    GROUP_EXEC: base.EXEC << 3,\n    GROUP_WRITE: base.WRITE << 3,\n    GROUP_READ: base.READ << 3,\n\n    OWNER_EXEC: base.EXEC << 6,\n    OWNER_WRITE: base.WRITE << 6,\n    OWNER_READ: base.READ << 6,\n\n    // Literal octal numbers are apparently not allowed in \"strict\" javascript.\n    STICKY: parseInt('01000', 8),\n    SETGID: parseInt('02000', 8),\n    SETUID: parseInt('04000', 8),\n\n    TYPE_MASK: parseInt('0770000', 8),\n  };\n}({\n  EXEC: 1,\n  WRITE: 2,\n  READ: 4,\n}));\n\ncommon.register('chmod', _chmod, {\n});\n\n//@\n//@ ### chmod([options,] octal_mode || octal_string, file)\n//@ ### chmod([options,] symbolic_mode, file)\n//@\n//@ Available options:\n//@\n//@ + `-v`: output a diagnostic for every file processed//@\n//@ + `-c`: like verbose, but report only when a change is made//@\n//@ + `-R`: change files and directories recursively//@\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ chmod(755, '/Users/brandon');\n//@ chmod('755', '/Users/brandon'); // same as above\n//@ chmod('u+x', '/Users/brandon');\n//@ chmod('-R', 'a-w', '/Users/brandon');\n//@ ```\n//@\n//@ Alters the permissions of a file or directory by either specifying the\n//@ absolute permissions in octal form or expressing the changes in symbols.\n//@ This command tries to mimic the POSIX behavior as much as possible.\n//@ Notable exceptions:\n//@\n//@ + In symbolic modes, `a-r` and `-r` are identical.  No consideration is\n//@   given to the `umask`.\n//@ + There is no \"quiet\" option, since default behavior is to run silent.\nfunction _chmod(options, mode, filePattern) {\n  if (!filePattern) {\n    if (options.length > 0 && options.charAt(0) === '-') {\n      // Special case where the specified file permissions started with - to subtract perms, which\n      // get picked up by the option parser as command flags.\n      // If we are down by one argument and options starts with -, shift everything over.\n      [].unshift.call(arguments, '');\n    } else {\n      common.error('You must specify a file.');\n    }\n  }\n\n  options = common.parseOptions(options, {\n    'R': 'recursive',\n    'c': 'changes',\n    'v': 'verbose',\n  });\n\n  filePattern = [].slice.call(arguments, 2);\n\n  var files;\n\n  // TODO: replace this with a call to common.expand()\n  if (options.recursive) {\n    files = [];\n    filePattern.forEach(function addFile(expandedFile) {\n      var stat = common.statNoFollowLinks(expandedFile);\n\n      if (!stat.isSymbolicLink()) {\n        files.push(expandedFile);\n\n        if (stat.isDirectory()) {  // intentionally does not follow symlinks.\n          fs.readdirSync(expandedFile).forEach(function (child) {\n            addFile(expandedFile + '/' + child);\n          });\n        }\n      }\n    });\n  } else {\n    files = filePattern;\n  }\n\n  files.forEach(function innerChmod(file) {\n    file = path.resolve(file);\n    if (!fs.existsSync(file)) {\n      common.error('File not found: ' + file);\n    }\n\n    // When recursing, don't follow symlinks.\n    if (options.recursive && common.statNoFollowLinks(file).isSymbolicLink()) {\n      return;\n    }\n\n    var stat = common.statFollowLinks(file);\n    var isDir = stat.isDirectory();\n    var perms = stat.mode;\n    var type = perms & PERMS.TYPE_MASK;\n\n    var newPerms = perms;\n\n    if (isNaN(parseInt(mode, 8))) {\n      // parse options\n      mode.split(',').forEach(function (symbolicMode) {\n        var pattern = /([ugoa]*)([=\\+-])([rwxXst]*)/i;\n        var matches = pattern.exec(symbolicMode);\n\n        if (matches) {\n          var applyTo = matches[1];\n          var operator = matches[2];\n          var change = matches[3];\n\n          var changeOwner = applyTo.indexOf('u') !== -1 || applyTo === 'a' || applyTo === '';\n          var changeGroup = applyTo.indexOf('g') !== -1 || applyTo === 'a' || applyTo === '';\n          var changeOther = applyTo.indexOf('o') !== -1 || applyTo === 'a' || applyTo === '';\n\n          var changeRead = change.indexOf('r') !== -1;\n          var changeWrite = change.indexOf('w') !== -1;\n          var changeExec = change.indexOf('x') !== -1;\n          var changeExecDir = change.indexOf('X') !== -1;\n          var changeSticky = change.indexOf('t') !== -1;\n          var changeSetuid = change.indexOf('s') !== -1;\n\n          if (changeExecDir && isDir) {\n            changeExec = true;\n          }\n\n          var mask = 0;\n          if (changeOwner) {\n            mask |= (changeRead ? PERMS.OWNER_READ : 0) + (changeWrite ? PERMS.OWNER_WRITE : 0) + (changeExec ? PERMS.OWNER_EXEC : 0) + (changeSetuid ? PERMS.SETUID : 0);\n          }\n          if (changeGroup) {\n            mask |= (changeRead ? PERMS.GROUP_READ : 0) + (changeWrite ? PERMS.GROUP_WRITE : 0) + (changeExec ? PERMS.GROUP_EXEC : 0) + (changeSetuid ? PERMS.SETGID : 0);\n          }\n          if (changeOther) {\n            mask |= (changeRead ? PERMS.OTHER_READ : 0) + (changeWrite ? PERMS.OTHER_WRITE : 0) + (changeExec ? PERMS.OTHER_EXEC : 0);\n          }\n\n          // Sticky bit is special - it's not tied to user, group or other.\n          if (changeSticky) {\n            mask |= PERMS.STICKY;\n          }\n\n          switch (operator) {\n            case '+':\n              newPerms |= mask;\n              break;\n\n            case '-':\n              newPerms &= ~mask;\n              break;\n\n            case '=':\n              newPerms = type + mask;\n\n              // According to POSIX, when using = to explicitly set the\n              // permissions, setuid and setgid can never be cleared.\n              if (common.statFollowLinks(file).isDirectory()) {\n                newPerms |= (PERMS.SETUID + PERMS.SETGID) & perms;\n              }\n              break;\n            default:\n              common.error('Could not recognize operator: `' + operator + '`');\n          }\n\n          if (options.verbose) {\n            console.log(file + ' -> ' + newPerms.toString(8));\n          }\n\n          if (perms !== newPerms) {\n            if (!options.verbose && options.changes) {\n              console.log(file + ' -> ' + newPerms.toString(8));\n            }\n            fs.chmodSync(file, newPerms);\n            perms = newPerms; // for the next round of changes!\n          }\n        } else {\n          common.error('Invalid symbolic mode change: ' + symbolicMode);\n        }\n      });\n    } else {\n      // they gave us a full number\n      newPerms = type + parseInt(mode, 8);\n\n      // POSIX rules are that setuid and setgid can only be added using numeric\n      // form, but not cleared.\n      if (common.statFollowLinks(file).isDirectory()) {\n        newPerms |= (PERMS.SETUID + PERMS.SETGID) & perms;\n      }\n\n      fs.chmodSync(file, newPerms);\n    }\n  });\n  return '';\n}\nmodule.exports = _chmod;\n","// Ignore warning about 'new String()'\n/* eslint no-new-wrappers: 0 */\n'use strict';\n\nvar os = require('os');\nvar fs = require('fs');\nvar glob = require('glob');\nvar shell = require('..');\n\nvar shellMethods = Object.create(shell);\n\nexports.extend = Object.assign;\n\n// Check if we're running under electron\nvar isElectron = Boolean(process.versions.electron);\n\n// Module globals (assume no execPath by default)\nvar DEFAULT_CONFIG = {\n  fatal: false,\n  globOptions: {},\n  maxdepth: 255,\n  noglob: false,\n  silent: false,\n  verbose: false,\n  execPath: null,\n  bufLength: 64 * 1024, // 64KB\n};\n\nvar config = {\n  reset: function () {\n    Object.assign(this, DEFAULT_CONFIG);\n    if (!isElectron) {\n      this.execPath = process.execPath;\n    }\n  },\n  resetForTesting: function () {\n    this.reset();\n    this.silent = true;\n  },\n};\n\nconfig.reset();\nexports.config = config;\n\n// Note: commands should generally consider these as read-only values.\nvar state = {\n  error: null,\n  errorCode: 0,\n  currentCmd: 'shell.js',\n};\nexports.state = state;\n\ndelete process.env.OLDPWD; // initially, there's no previous directory\n\n// Reliably test if something is any sort of javascript object\nfunction isObject(a) {\n  return typeof a === 'object' && a !== null;\n}\nexports.isObject = isObject;\n\nfunction log() {\n  /* istanbul ignore next */\n  if (!config.silent) {\n    console.error.apply(console, arguments);\n  }\n}\nexports.log = log;\n\n// Converts strings to be equivalent across all platforms. Primarily responsible\n// for making sure we use '/' instead of '\\' as path separators, but this may be\n// expanded in the future if necessary\nfunction convertErrorOutput(msg) {\n  if (typeof msg !== 'string') {\n    throw new TypeError('input must be a string');\n  }\n  return msg.replace(/\\\\/g, '/');\n}\nexports.convertErrorOutput = convertErrorOutput;\n\n// Shows error message. Throws if config.fatal is true\nfunction error(msg, _code, options) {\n  // Validate input\n  if (typeof msg !== 'string') throw new Error('msg must be a string');\n\n  var DEFAULT_OPTIONS = {\n    continue: false,\n    code: 1,\n    prefix: state.currentCmd + ': ',\n    silent: false,\n  };\n\n  if (typeof _code === 'number' && isObject(options)) {\n    options.code = _code;\n  } else if (isObject(_code)) { // no 'code'\n    options = _code;\n  } else if (typeof _code === 'number') { // no 'options'\n    options = { code: _code };\n  } else if (typeof _code !== 'number') { // only 'msg'\n    options = {};\n  }\n  options = Object.assign({}, DEFAULT_OPTIONS, options);\n\n  if (!state.errorCode) state.errorCode = options.code;\n\n  var logEntry = convertErrorOutput(options.prefix + msg);\n  state.error = state.error ? state.error + '\\n' : '';\n  state.error += logEntry;\n\n  // Throw an error, or log the entry\n  if (config.fatal) throw new Error(logEntry);\n  if (msg.length > 0 && !options.silent) log(logEntry);\n\n  if (!options.continue) {\n    throw {\n      msg: 'earlyExit',\n      retValue: (new ShellString('', state.error, state.errorCode)),\n    };\n  }\n}\nexports.error = error;\n\n//@\n//@ ### ShellString(str)\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ var foo = ShellString('hello world');\n//@ ```\n//@\n//@ Turns a regular string into a string-like object similar to what each\n//@ command returns. This has special methods, like `.to()` and `.toEnd()`.\nfunction ShellString(stdout, stderr, code) {\n  var that;\n  if (stdout instanceof Array) {\n    that = stdout;\n    that.stdout = stdout.join('\\n');\n    if (stdout.length > 0) that.stdout += '\\n';\n  } else {\n    that = new String(stdout);\n    that.stdout = stdout;\n  }\n  that.stderr = stderr;\n  that.code = code;\n  // A list of all commands that can appear on the right-hand side of a pipe\n  // (populated by calls to common.wrap())\n  pipeMethods.forEach(function (cmd) {\n    that[cmd] = shellMethods[cmd].bind(that);\n  });\n  return that;\n}\n\nexports.ShellString = ShellString;\n\n// Returns {'alice': true, 'bob': false} when passed a string and dictionary as follows:\n//   parseOptions('-a', {'a':'alice', 'b':'bob'});\n// Returns {'reference': 'string-value', 'bob': false} when passed two dictionaries of the form:\n//   parseOptions({'-r': 'string-value'}, {'r':'reference', 'b':'bob'});\n// Throws an error when passed a string that does not start with '-':\n//   parseOptions('a', {'a':'alice'}); // throws\nfunction parseOptions(opt, map, errorOptions) {\n  // Validate input\n  if (typeof opt !== 'string' && !isObject(opt)) {\n    throw new Error('options must be strings or key-value pairs');\n  } else if (!isObject(map)) {\n    throw new Error('parseOptions() internal error: map must be an object');\n  } else if (errorOptions && !isObject(errorOptions)) {\n    throw new Error('parseOptions() internal error: errorOptions must be object');\n  }\n\n  if (opt === '--') {\n    // This means there are no options.\n    return {};\n  }\n\n  // All options are false by default\n  var options = {};\n  Object.keys(map).forEach(function (letter) {\n    var optName = map[letter];\n    if (optName[0] !== '!') {\n      options[optName] = false;\n    }\n  });\n\n  if (opt === '') return options; // defaults\n\n  if (typeof opt === 'string') {\n    if (opt[0] !== '-') {\n      throw new Error(\"Options string must start with a '-'\");\n    }\n\n    // e.g. chars = ['R', 'f']\n    var chars = opt.slice(1).split('');\n\n    chars.forEach(function (c) {\n      if (c in map) {\n        var optionName = map[c];\n        if (optionName[0] === '!') {\n          options[optionName.slice(1)] = false;\n        } else {\n          options[optionName] = true;\n        }\n      } else {\n        error('option not recognized: ' + c, errorOptions || {});\n      }\n    });\n  } else { // opt is an Object\n    Object.keys(opt).forEach(function (key) {\n      // key is a string of the form '-r', '-d', etc.\n      var c = key[1];\n      if (c in map) {\n        var optionName = map[c];\n        options[optionName] = opt[key]; // assign the given value\n      } else {\n        error('option not recognized: ' + c, errorOptions || {});\n      }\n    });\n  }\n  return options;\n}\nexports.parseOptions = parseOptions;\n\n// Expands wildcards with matching (ie. existing) file names.\n// For example:\n//   expand(['file*.js']) = ['file1.js', 'file2.js', ...]\n//   (if the files 'file1.js', 'file2.js', etc, exist in the current dir)\nfunction expand(list) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('must be an array');\n  }\n  var expanded = [];\n  list.forEach(function (listEl) {\n    // Don't expand non-strings\n    if (typeof listEl !== 'string') {\n      expanded.push(listEl);\n    } else {\n      var ret;\n      try {\n        ret = glob.sync(listEl, config.globOptions);\n        // if nothing matched, interpret the string literally\n        ret = ret.length > 0 ? ret : [listEl];\n      } catch (e) {\n        // if glob fails, interpret the string literally\n        ret = [listEl];\n      }\n      expanded = expanded.concat(ret);\n    }\n  });\n  return expanded;\n}\nexports.expand = expand;\n\n// Normalizes Buffer creation, using Buffer.alloc if possible.\n// Also provides a good default buffer length for most use cases.\nvar buffer = typeof Buffer.alloc === 'function' ?\n  function (len) {\n    return Buffer.alloc(len || config.bufLength);\n  } :\n  function (len) {\n    return new Buffer(len || config.bufLength);\n  };\nexports.buffer = buffer;\n\n// Normalizes _unlinkSync() across platforms to match Unix behavior, i.e.\n// file can be unlinked even if it's read-only, see https://github.com/joyent/node/issues/3006\nfunction unlinkSync(file) {\n  try {\n    fs.unlinkSync(file);\n  } catch (e) {\n    // Try to override file permission\n    /* istanbul ignore next */\n    if (e.code === 'EPERM') {\n      fs.chmodSync(file, '0666');\n      fs.unlinkSync(file);\n    } else {\n      throw e;\n    }\n  }\n}\nexports.unlinkSync = unlinkSync;\n\n// wrappers around common.statFollowLinks and common.statNoFollowLinks that clarify intent\n// and improve readability\nfunction statFollowLinks() {\n  return fs.statSync.apply(fs, arguments);\n}\nexports.statFollowLinks = statFollowLinks;\n\nfunction statNoFollowLinks() {\n  return fs.lstatSync.apply(fs, arguments);\n}\nexports.statNoFollowLinks = statNoFollowLinks;\n\n// e.g. 'shelljs_a5f185d0443ca...'\nfunction randomFileName() {\n  function randomHash(count) {\n    if (count === 1) {\n      return parseInt(16 * Math.random(), 10).toString(16);\n    }\n    var hash = '';\n    for (var i = 0; i < count; i++) {\n      hash += randomHash(1);\n    }\n    return hash;\n  }\n\n  return 'shelljs_' + randomHash(20);\n}\nexports.randomFileName = randomFileName;\n\n// Common wrapper for all Unix-like commands that performs glob expansion,\n// command-logging, and other nice things\nfunction wrap(cmd, fn, options) {\n  options = options || {};\n  return function () {\n    var retValue = null;\n\n    state.currentCmd = cmd;\n    state.error = null;\n    state.errorCode = 0;\n\n    try {\n      var args = [].slice.call(arguments, 0);\n\n      // Log the command to stderr, if appropriate\n      if (config.verbose) {\n        console.error.apply(console, [cmd].concat(args));\n      }\n\n      // If this is coming from a pipe, let's set the pipedValue (otherwise, set\n      // it to the empty string)\n      state.pipedValue = (this && typeof this.stdout === 'string') ? this.stdout : '';\n\n      if (options.unix === false) { // this branch is for exec()\n        retValue = fn.apply(this, args);\n      } else { // and this branch is for everything else\n        if (isObject(args[0]) && args[0].constructor.name === 'Object') {\n          // a no-op, allowing the syntax `touch({'-r': file}, ...)`\n        } else if (args.length === 0 || typeof args[0] !== 'string' || args[0].length <= 1 || args[0][0] !== '-') {\n          args.unshift(''); // only add dummy option if '-option' not already present\n        }\n\n        // flatten out arrays that are arguments, to make the syntax:\n        //    `cp([file1, file2, file3], dest);`\n        // equivalent to:\n        //    `cp(file1, file2, file3, dest);`\n        args = args.reduce(function (accum, cur) {\n          if (Array.isArray(cur)) {\n            return accum.concat(cur);\n          }\n          accum.push(cur);\n          return accum;\n        }, []);\n\n        // Convert ShellStrings (basically just String objects) to regular strings\n        args = args.map(function (arg) {\n          if (isObject(arg) && arg.constructor.name === 'String') {\n            return arg.toString();\n          }\n          return arg;\n        });\n\n        // Expand the '~' if appropriate\n        var homeDir = os.homedir();\n        args = args.map(function (arg) {\n          if (typeof arg === 'string' && arg.slice(0, 2) === '~/' || arg === '~') {\n            return arg.replace(/^~/, homeDir);\n          }\n          return arg;\n        });\n\n        // Perform glob-expansion on all arguments after globStart, but preserve\n        // the arguments before it (like regexes for sed and grep)\n        if (!config.noglob && options.allowGlobbing === true) {\n          args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));\n        }\n\n        try {\n          // parse options if options are provided\n          if (isObject(options.cmdOptions)) {\n            args[0] = parseOptions(args[0], options.cmdOptions);\n          }\n\n          retValue = fn.apply(this, args);\n        } catch (e) {\n          /* istanbul ignore else */\n          if (e.msg === 'earlyExit') {\n            retValue = e.retValue;\n          } else {\n            throw e; // this is probably a bug that should be thrown up the call stack\n          }\n        }\n      }\n    } catch (e) {\n      /* istanbul ignore next */\n      if (!state.error) {\n        // If state.error hasn't been set it's an error thrown by Node, not us - probably a bug...\n        e.name = 'ShellJSInternalError';\n        throw e;\n      }\n      if (config.fatal) throw e;\n    }\n\n    if (options.wrapOutput &&\n        (typeof retValue === 'string' || Array.isArray(retValue))) {\n      retValue = new ShellString(retValue, state.error, state.errorCode);\n    }\n\n    state.currentCmd = 'shell.js';\n    return retValue;\n  };\n} // wrap\nexports.wrap = wrap;\n\n// This returns all the input that is piped into the current command (or the\n// empty string, if this isn't on the right-hand side of a pipe\nfunction _readFromPipe() {\n  return state.pipedValue;\n}\nexports.readFromPipe = _readFromPipe;\n\nvar DEFAULT_WRAP_OPTIONS = {\n  allowGlobbing: true,\n  canReceivePipe: false,\n  cmdOptions: null,\n  globStart: 1,\n  pipeOnly: false,\n  wrapOutput: true,\n  unix: true,\n};\n\n// This is populated during plugin registration\nvar pipeMethods = [];\n\n// Register a new ShellJS command\nfunction _register(name, implementation, wrapOptions) {\n  wrapOptions = wrapOptions || {};\n\n  // Validate options\n  Object.keys(wrapOptions).forEach(function (option) {\n    if (!DEFAULT_WRAP_OPTIONS.hasOwnProperty(option)) {\n      throw new Error(\"Unknown option '\" + option + \"'\");\n    }\n    if (typeof wrapOptions[option] !== typeof DEFAULT_WRAP_OPTIONS[option]) {\n      throw new TypeError(\"Unsupported type '\" + typeof wrapOptions[option] +\n        \"' for option '\" + option + \"'\");\n    }\n  });\n\n  // If an option isn't specified, use the default\n  wrapOptions = Object.assign({}, DEFAULT_WRAP_OPTIONS, wrapOptions);\n\n  if (shell.hasOwnProperty(name)) {\n    throw new Error('Command `' + name + '` already exists');\n  }\n\n  if (wrapOptions.pipeOnly) {\n    wrapOptions.canReceivePipe = true;\n    shellMethods[name] = wrap(name, implementation, wrapOptions);\n  } else {\n    shell[name] = wrap(name, implementation, wrapOptions);\n  }\n\n  if (wrapOptions.canReceivePipe) {\n    pipeMethods.push(name);\n  }\n}\nexports.register = _register;\n","var fs = require('fs');\nvar path = require('path');\nvar common = require('./common');\n\ncommon.register('cp', _cp, {\n  cmdOptions: {\n    'f': '!no_force',\n    'n': 'no_force',\n    'u': 'update',\n    'R': 'recursive',\n    'r': 'recursive',\n    'L': 'followsymlink',\n    'P': 'noFollowsymlink',\n  },\n  wrapOutput: false,\n});\n\n// Buffered file copy, synchronous\n// (Using readFileSync() + writeFileSync() could easily cause a memory overflow\n//  with large files)\nfunction copyFileSync(srcFile, destFile, options) {\n  if (!fs.existsSync(srcFile)) {\n    common.error('copyFileSync: no such file or directory: ' + srcFile);\n  }\n\n  var isWindows = process.platform === 'win32';\n\n  // Check the mtimes of the files if the '-u' flag is provided\n  try {\n    if (options.update && common.statFollowLinks(srcFile).mtime < fs.statSync(destFile).mtime) {\n      return;\n    }\n  } catch (e) {\n    // If we're here, destFile probably doesn't exist, so just do a normal copy\n  }\n\n  if (common.statNoFollowLinks(srcFile).isSymbolicLink() && !options.followsymlink) {\n    try {\n      common.statNoFollowLinks(destFile);\n      common.unlinkSync(destFile); // re-link it\n    } catch (e) {\n      // it doesn't exist, so no work needs to be done\n    }\n\n    var symlinkFull = fs.readlinkSync(srcFile);\n    fs.symlinkSync(symlinkFull, destFile, isWindows ? 'junction' : null);\n  } else {\n    var buf = common.buffer();\n    var bufLength = buf.length;\n    var bytesRead = bufLength;\n    var pos = 0;\n    var fdr = null;\n    var fdw = null;\n\n    try {\n      fdr = fs.openSync(srcFile, 'r');\n    } catch (e) {\n      /* istanbul ignore next */\n      common.error('copyFileSync: could not read src file (' + srcFile + ')');\n    }\n\n    try {\n      fdw = fs.openSync(destFile, 'w');\n    } catch (e) {\n      /* istanbul ignore next */\n      common.error('copyFileSync: could not write to dest file (code=' + e.code + '):' + destFile);\n    }\n\n    while (bytesRead === bufLength) {\n      bytesRead = fs.readSync(fdr, buf, 0, bufLength, pos);\n      fs.writeSync(fdw, buf, 0, bytesRead);\n      pos += bytesRead;\n    }\n\n    fs.closeSync(fdr);\n    fs.closeSync(fdw);\n\n    fs.chmodSync(destFile, common.statFollowLinks(srcFile).mode);\n  }\n}\n\n// Recursively copies 'sourceDir' into 'destDir'\n// Adapted from https://github.com/ryanmcgrath/wrench-js\n//\n// Copyright (c) 2010 Ryan McGrath\n// Copyright (c) 2012 Artur Adib\n//\n// Licensed under the MIT License\n// http://www.opensource.org/licenses/mit-license.php\nfunction cpdirSyncRecursive(sourceDir, destDir, currentDepth, opts) {\n  if (!opts) opts = {};\n\n  // Ensure there is not a run away recursive copy\n  if (currentDepth >= common.config.maxdepth) return;\n  currentDepth++;\n\n  var isWindows = process.platform === 'win32';\n\n  // Create the directory where all our junk is moving to; read the mode of the\n  // source directory and mirror it\n  try {\n    fs.mkdirSync(destDir);\n  } catch (e) {\n    // if the directory already exists, that's okay\n    if (e.code !== 'EEXIST') throw e;\n  }\n\n  var files = fs.readdirSync(sourceDir);\n\n  for (var i = 0; i < files.length; i++) {\n    var srcFile = sourceDir + '/' + files[i];\n    var destFile = destDir + '/' + files[i];\n    var srcFileStat = common.statNoFollowLinks(srcFile);\n\n    var symlinkFull;\n    if (opts.followsymlink) {\n      if (cpcheckcycle(sourceDir, srcFile)) {\n        // Cycle link found.\n        console.error('Cycle link found.');\n        symlinkFull = fs.readlinkSync(srcFile);\n        fs.symlinkSync(symlinkFull, destFile, isWindows ? 'junction' : null);\n        continue;\n      }\n    }\n    if (srcFileStat.isDirectory()) {\n      /* recursion this thing right on back. */\n      cpdirSyncRecursive(srcFile, destFile, currentDepth, opts);\n    } else if (srcFileStat.isSymbolicLink() && !opts.followsymlink) {\n      symlinkFull = fs.readlinkSync(srcFile);\n      try {\n        common.statNoFollowLinks(destFile);\n        common.unlinkSync(destFile); // re-link it\n      } catch (e) {\n        // it doesn't exist, so no work needs to be done\n      }\n      fs.symlinkSync(symlinkFull, destFile, isWindows ? 'junction' : null);\n    } else if (srcFileStat.isSymbolicLink() && opts.followsymlink) {\n      srcFileStat = common.statFollowLinks(srcFile);\n      if (srcFileStat.isDirectory()) {\n        cpdirSyncRecursive(srcFile, destFile, currentDepth, opts);\n      } else {\n        copyFileSync(srcFile, destFile, opts);\n      }\n    } else {\n      /* At this point, we've hit a file actually worth copying... so copy it on over. */\n      if (fs.existsSync(destFile) && opts.no_force) {\n        common.log('skipping existing file: ' + files[i]);\n      } else {\n        copyFileSync(srcFile, destFile, opts);\n      }\n    }\n  } // for files\n\n  // finally change the mode for the newly created directory (otherwise, we\n  // couldn't add files to a read-only directory).\n  var checkDir = common.statFollowLinks(sourceDir);\n  fs.chmodSync(destDir, checkDir.mode);\n} // cpdirSyncRecursive\n\n// Checks if cureent file was created recently\nfunction checkRecentCreated(sources, index) {\n  var lookedSource = sources[index];\n  return sources.slice(0, index).some(function (src) {\n    return path.basename(src) === path.basename(lookedSource);\n  });\n}\n\nfunction cpcheckcycle(sourceDir, srcFile) {\n  var srcFileStat = common.statNoFollowLinks(srcFile);\n  if (srcFileStat.isSymbolicLink()) {\n    // Do cycle check. For example:\n    //   $ mkdir -p 1/2/3/4\n    //   $ cd  1/2/3/4\n    //   $ ln -s ../../3 link\n    //   $ cd ../../../..\n    //   $ cp -RL 1 copy\n    var cyclecheck = common.statFollowLinks(srcFile);\n    if (cyclecheck.isDirectory()) {\n      var sourcerealpath = fs.realpathSync(sourceDir);\n      var symlinkrealpath = fs.realpathSync(srcFile);\n      var re = new RegExp(symlinkrealpath);\n      if (re.test(sourcerealpath)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\n//@\n//@ ### cp([options,] source [, source ...], dest)\n//@ ### cp([options,] source_array, dest)\n//@\n//@ Available options:\n//@\n//@ + `-f`: force (default behavior)\n//@ + `-n`: no-clobber\n//@ + `-u`: only copy if `source` is newer than `dest`\n//@ + `-r`, `-R`: recursive\n//@ + `-L`: follow symlinks\n//@ + `-P`: don't follow symlinks\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ cp('file1', 'dir1');\n//@ cp('-R', 'path/to/dir/', '~/newCopy/');\n//@ cp('-Rf', '/tmp/*', '/usr/local/*', '/home/tmp');\n//@ cp('-Rf', ['/tmp/*', '/usr/local/*'], '/home/tmp'); // same as above\n//@ ```\n//@\n//@ Copies files.\nfunction _cp(options, sources, dest) {\n  // If we're missing -R, it actually implies -L (unless -P is explicit)\n  if (options.followsymlink) {\n    options.noFollowsymlink = false;\n  }\n  if (!options.recursive && !options.noFollowsymlink) {\n    options.followsymlink = true;\n  }\n\n  // Get sources, dest\n  if (arguments.length < 3) {\n    common.error('missing <source> and/or <dest>');\n  } else {\n    sources = [].slice.call(arguments, 1, arguments.length - 1);\n    dest = arguments[arguments.length - 1];\n  }\n\n  var destExists = fs.existsSync(dest);\n  var destStat = destExists && common.statFollowLinks(dest);\n\n  // Dest is not existing dir, but multiple sources given\n  if ((!destExists || !destStat.isDirectory()) && sources.length > 1) {\n    common.error('dest is not a directory (too many sources)');\n  }\n\n  // Dest is an existing file, but -n is given\n  if (destExists && destStat.isFile() && options.no_force) {\n    return new common.ShellString('', '', 0);\n  }\n\n  sources.forEach(function (src, srcIndex) {\n    if (!fs.existsSync(src)) {\n      if (src === '') src = \"''\"; // if src was empty string, display empty string\n      common.error('no such file or directory: ' + src, { continue: true });\n      return; // skip file\n    }\n    var srcStat = common.statFollowLinks(src);\n    if (!options.noFollowsymlink && srcStat.isDirectory()) {\n      if (!options.recursive) {\n        // Non-Recursive\n        common.error(\"omitting directory '\" + src + \"'\", { continue: true });\n      } else {\n        // Recursive\n        // 'cp /a/source dest' should create 'source' in 'dest'\n        var newDest = (destStat && destStat.isDirectory()) ?\n            path.join(dest, path.basename(src)) :\n            dest;\n\n        try {\n          common.statFollowLinks(path.dirname(dest));\n          cpdirSyncRecursive(src, newDest, 0, { no_force: options.no_force, followsymlink: options.followsymlink });\n        } catch (e) {\n          /* istanbul ignore next */\n          common.error(\"cannot create directory '\" + dest + \"': No such file or directory\");\n        }\n      }\n    } else {\n      // If here, src is a file\n\n      // When copying to '/path/dir':\n      //    thisDest = '/path/dir/file1'\n      var thisDest = dest;\n      if (destStat && destStat.isDirectory()) {\n        thisDest = path.normalize(dest + '/' + path.basename(src));\n      }\n\n      var thisDestExists = fs.existsSync(thisDest);\n      if (thisDestExists && checkRecentCreated(sources, srcIndex)) {\n        // cannot overwrite file created recently in current execution, but we want to continue copying other files\n        if (!options.no_force) {\n          common.error(\"will not overwrite just-created '\" + thisDest + \"' with '\" + src + \"'\", { continue: true });\n        }\n        return;\n      }\n\n      if (thisDestExists && options.no_force) {\n        return; // skip file\n      }\n\n      if (path.relative(src, thisDest) === '') {\n        // a file cannot be copied to itself, but we want to continue copying other files\n        common.error(\"'\" + thisDest + \"' and '\" + src + \"' are the same file\", { continue: true });\n        return;\n      }\n\n      copyFileSync(src, thisDest, options);\n    }\n  }); // forEach(src)\n\n  return new common.ShellString('', common.state.error, common.state.errorCode);\n}\nmodule.exports = _cp;\n","var common = require('./common');\nvar _cd = require('./cd');\nvar path = require('path');\n\ncommon.register('dirs', _dirs, {\n  wrapOutput: false,\n});\ncommon.register('pushd', _pushd, {\n  wrapOutput: false,\n});\ncommon.register('popd', _popd, {\n  wrapOutput: false,\n});\n\n// Pushd/popd/dirs internals\nvar _dirStack = [];\n\nfunction _isStackIndex(index) {\n  return (/^[\\-+]\\d+$/).test(index);\n}\n\nfunction _parseStackIndex(index) {\n  if (_isStackIndex(index)) {\n    if (Math.abs(index) < _dirStack.length + 1) { // +1 for pwd\n      return (/^-/).test(index) ? Number(index) - 1 : Number(index);\n    }\n    common.error(index + ': directory stack index out of range');\n  } else {\n    common.error(index + ': invalid number');\n  }\n}\n\nfunction _actualDirStack() {\n  return [process.cwd()].concat(_dirStack);\n}\n\n//@\n//@ ### pushd([options,] [dir | '-N' | '+N'])\n//@\n//@ Available options:\n//@\n//@ + `-n`: Suppresses the normal change of directory when adding directories to the stack, so that only the stack is manipulated.\n//@ + `-q`: Supresses output to the console.\n//@\n//@ Arguments:\n//@\n//@ + `dir`: Sets the current working directory to the top of the stack, then executes the equivalent of `cd dir`.\n//@ + `+N`: Brings the Nth directory (counting from the left of the list printed by dirs, starting with zero) to the top of the list by rotating the stack.\n//@ + `-N`: Brings the Nth directory (counting from the right of the list printed by dirs, starting with zero) to the top of the list by rotating the stack.\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ // process.cwd() === '/usr'\n//@ pushd('/etc'); // Returns /etc /usr\n//@ pushd('+1');   // Returns /usr /etc\n//@ ```\n//@\n//@ Save the current directory on the top of the directory stack and then `cd` to `dir`. With no arguments, `pushd` exchanges the top two directories. Returns an array of paths in the stack.\nfunction _pushd(options, dir) {\n  if (_isStackIndex(options)) {\n    dir = options;\n    options = '';\n  }\n\n  options = common.parseOptions(options, {\n    'n': 'no-cd',\n    'q': 'quiet',\n  });\n\n  var dirs = _actualDirStack();\n\n  if (dir === '+0') {\n    return dirs; // +0 is a noop\n  } else if (!dir) {\n    if (dirs.length > 1) {\n      dirs = dirs.splice(1, 1).concat(dirs);\n    } else {\n      return common.error('no other directory');\n    }\n  } else if (_isStackIndex(dir)) {\n    var n = _parseStackIndex(dir);\n    dirs = dirs.slice(n).concat(dirs.slice(0, n));\n  } else {\n    if (options['no-cd']) {\n      dirs.splice(1, 0, dir);\n    } else {\n      dirs.unshift(dir);\n    }\n  }\n\n  if (options['no-cd']) {\n    dirs = dirs.slice(1);\n  } else {\n    dir = path.resolve(dirs.shift());\n    _cd('', dir);\n  }\n\n  _dirStack = dirs;\n  return _dirs(options.quiet ? '-q' : '');\n}\nexports.pushd = _pushd;\n\n//@\n//@\n//@ ### popd([options,] ['-N' | '+N'])\n//@\n//@ Available options:\n//@\n//@ + `-n`: Suppress the normal directory change when removing directories from the stack, so that only the stack is manipulated.\n//@ + `-q`: Supresses output to the console.\n//@\n//@ Arguments:\n//@\n//@ + `+N`: Removes the Nth directory (counting from the left of the list printed by dirs), starting with zero.\n//@ + `-N`: Removes the Nth directory (counting from the right of the list printed by dirs), starting with zero.\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ echo(process.cwd()); // '/usr'\n//@ pushd('/etc');       // '/etc /usr'\n//@ echo(process.cwd()); // '/etc'\n//@ popd();              // '/usr'\n//@ echo(process.cwd()); // '/usr'\n//@ ```\n//@\n//@ When no arguments are given, `popd` removes the top directory from the stack and performs a `cd` to the new top directory. The elements are numbered from 0, starting at the first directory listed with dirs (i.e., `popd` is equivalent to `popd +0`). Returns an array of paths in the stack.\nfunction _popd(options, index) {\n  if (_isStackIndex(options)) {\n    index = options;\n    options = '';\n  }\n\n  options = common.parseOptions(options, {\n    'n': 'no-cd',\n    'q': 'quiet',\n  });\n\n  if (!_dirStack.length) {\n    return common.error('directory stack empty');\n  }\n\n  index = _parseStackIndex(index || '+0');\n\n  if (options['no-cd'] || index > 0 || _dirStack.length + index === 0) {\n    index = index > 0 ? index - 1 : index;\n    _dirStack.splice(index, 1);\n  } else {\n    var dir = path.resolve(_dirStack.shift());\n    _cd('', dir);\n  }\n\n  return _dirs(options.quiet ? '-q' : '');\n}\nexports.popd = _popd;\n\n//@\n//@\n//@ ### dirs([options | '+N' | '-N'])\n//@\n//@ Available options:\n//@\n//@ + `-c`: Clears the directory stack by deleting all of the elements.\n//@ + `-q`: Supresses output to the console.\n//@\n//@ Arguments:\n//@\n//@ + `+N`: Displays the Nth directory (counting from the left of the list printed by dirs when invoked without options), starting with zero.\n//@ + `-N`: Displays the Nth directory (counting from the right of the list printed by dirs when invoked without options), starting with zero.\n//@\n//@ Display the list of currently remembered directories. Returns an array of paths in the stack, or a single path if `+N` or `-N` was specified.\n//@\n//@ See also: `pushd`, `popd`\nfunction _dirs(options, index) {\n  if (_isStackIndex(options)) {\n    index = options;\n    options = '';\n  }\n\n  options = common.parseOptions(options, {\n    'c': 'clear',\n    'q': 'quiet',\n  });\n\n  if (options.clear) {\n    _dirStack = [];\n    return _dirStack;\n  }\n\n  var stack = _actualDirStack();\n\n  if (index) {\n    index = _parseStackIndex(index);\n\n    if (index < 0) {\n      index = stack.length + index;\n    }\n\n    if (!options.quiet) {\n      common.log(stack[index]);\n    }\n    return stack[index];\n  }\n\n  if (!options.quiet) {\n    common.log(stack.join(' '));\n  }\n\n  return stack;\n}\nexports.dirs = _dirs;\n","var format = require('util').format;\n\nvar common = require('./common');\n\ncommon.register('echo', _echo, {\n  allowGlobbing: false,\n});\n\n//@\n//@ ### echo([options,] string [, string ...])\n//@\n//@ Available options:\n//@\n//@ + `-e`: interpret backslash escapes (default)\n//@ + `-n`: remove trailing newline from output\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ echo('hello world');\n//@ var str = echo('hello world');\n//@ echo('-n', 'no newline at end');\n//@ ```\n//@\n//@ Prints `string` to stdout, and returns string with additional utility methods\n//@ like `.to()`.\nfunction _echo(opts) {\n  // allow strings starting with '-', see issue #20\n  var messages = [].slice.call(arguments, opts ? 0 : 1);\n  var options = {};\n\n  // If the first argument starts with '-', parse it as options string.\n  // If parseOptions throws, it wasn't an options string.\n  try {\n    options = common.parseOptions(messages[0], {\n      'e': 'escapes',\n      'n': 'no_newline',\n    }, {\n      silent: true,\n    });\n\n    // Allow null to be echoed\n    if (messages[0]) {\n      messages.shift();\n    }\n  } catch (_) {\n    // Clear out error if an error occurred\n    common.state.error = null;\n  }\n\n  var output = format.apply(null, messages);\n\n  // Add newline if -n is not passed.\n  if (!options.no_newline) {\n    output += '\\n';\n  }\n\n  process.stdout.write(output);\n\n  return output;\n}\n\nmodule.exports = _echo;\n","var common = require('./common');\n\n//@\n//@ ### error()\n//@\n//@ Tests if error occurred in the last command. Returns a truthy value if an\n//@ error returned, or a falsy value otherwise.\n//@\n//@ **Note**: do not rely on the\n//@ return value to be an error message. If you need the last error message, use\n//@ the `.stderr` attribute from the last command's return value instead.\nfunction error() {\n  return common.state.error;\n}\nmodule.exports = error;\n","if (require.main !== module) {\n  throw new Error('This file should not be required');\n}\n\nvar childProcess = require('child_process');\nvar fs = require('fs');\n\nvar paramFilePath = process.argv[2];\n\nvar serializedParams = fs.readFileSync(paramFilePath, 'utf8');\nvar params = JSON.parse(serializedParams);\n\nvar cmd = params.command;\nvar execOptions = params.execOptions;\nvar pipe = params.pipe;\nvar stdoutFile = params.stdoutFile;\nvar stderrFile = params.stderrFile;\n\nvar c = childProcess.exec(cmd, execOptions, function (err) {\n  if (!err) {\n    process.exitCode = 0;\n  } else if (err.code === undefined) {\n    process.exitCode = 1;\n  } else {\n    process.exitCode = err.code;\n  }\n});\n\nvar stdoutStream = fs.createWriteStream(stdoutFile);\nvar stderrStream = fs.createWriteStream(stderrFile);\n\nc.stdout.pipe(stdoutStream);\nc.stderr.pipe(stderrStream);\nc.stdout.pipe(process.stdout);\nc.stderr.pipe(process.stderr);\n\nif (pipe) {\n  c.stdin.end(pipe);\n}\n","var common = require('./common');\nvar _tempDir = require('./tempdir').tempDir;\nvar _pwd = require('./pwd');\nvar path = require('path');\nvar fs = require('fs');\nvar child = require('child_process');\n\nvar DEFAULT_MAXBUFFER_SIZE = 20 * 1024 * 1024;\nvar DEFAULT_ERROR_CODE = 1;\n\ncommon.register('exec', _exec, {\n  unix: false,\n  canReceivePipe: true,\n  wrapOutput: false,\n});\n\n// We use this function to run `exec` synchronously while also providing realtime\n// output.\nfunction execSync(cmd, opts, pipe) {\n  if (!common.config.execPath) {\n    common.error('Unable to find a path to the node binary. Please manually set config.execPath');\n  }\n\n  var tempDir = _tempDir();\n  var paramsFile = path.resolve(tempDir + '/' + common.randomFileName());\n  var stderrFile = path.resolve(tempDir + '/' + common.randomFileName());\n  var stdoutFile = path.resolve(tempDir + '/' + common.randomFileName());\n\n  opts = common.extend({\n    silent: common.config.silent,\n    cwd: _pwd().toString(),\n    env: process.env,\n    maxBuffer: DEFAULT_MAXBUFFER_SIZE,\n    encoding: 'utf8',\n  }, opts);\n\n  if (fs.existsSync(paramsFile)) common.unlinkSync(paramsFile);\n  if (fs.existsSync(stderrFile)) common.unlinkSync(stderrFile);\n  if (fs.existsSync(stdoutFile)) common.unlinkSync(stdoutFile);\n\n  opts.cwd = path.resolve(opts.cwd);\n\n  var paramsToSerialize = {\n    command: cmd,\n    execOptions: opts,\n    pipe: pipe,\n    stdoutFile: stdoutFile,\n    stderrFile: stderrFile,\n  };\n\n  fs.writeFileSync(paramsFile, JSON.stringify(paramsToSerialize), 'utf8');\n\n  var execArgs = [\n    path.join(__dirname, 'exec-child.js'),\n    paramsFile,\n  ];\n\n  /* istanbul ignore else */\n  if (opts.silent) {\n    opts.stdio = 'ignore';\n  } else {\n    opts.stdio = [0, 1, 2];\n  }\n\n  var code = 0;\n\n  // Welcome to the future\n  try {\n    // Bad things if we pass in a `shell` option to child_process.execFileSync,\n    // so we need to explicitly remove it here.\n    delete opts.shell;\n\n    child.execFileSync(common.config.execPath, execArgs, opts);\n  } catch (e) {\n    // Commands with non-zero exit code raise an exception.\n    code = e.status || DEFAULT_ERROR_CODE;\n  }\n\n  // fs.readFileSync uses buffer encoding by default, so call\n  // it without the encoding option if the encoding is 'buffer'.\n  // Also, if the exec timeout is too short for node to start up,\n  // the files will not be created, so these calls will throw.\n  var stdout = '';\n  var stderr = '';\n  if (opts.encoding === 'buffer') {\n    stdout = fs.readFileSync(stdoutFile);\n    stderr = fs.readFileSync(stderrFile);\n  } else {\n    stdout = fs.readFileSync(stdoutFile, opts.encoding);\n    stderr = fs.readFileSync(stderrFile, opts.encoding);\n  }\n\n  // No biggie if we can't erase the files now -- they're in a temp dir anyway\n  try { common.unlinkSync(paramsFile); } catch (e) {}\n  try { common.unlinkSync(stderrFile); } catch (e) {}\n  try { common.unlinkSync(stdoutFile); } catch (e) {}\n\n  if (code !== 0) {\n    // Note: `silent` should be unconditionally true to avoid double-printing\n    // the command's stderr, and to avoid printing any stderr when the user has\n    // set `shell.config.silent`.\n    common.error(stderr, code, { continue: true, silent: true });\n  }\n  var obj = common.ShellString(stdout, stderr, code);\n  return obj;\n} // execSync()\n\n// Wrapper around exec() to enable echoing output to console in real time\nfunction execAsync(cmd, opts, pipe, callback) {\n  opts = common.extend({\n    silent: common.config.silent,\n    cwd: _pwd().toString(),\n    env: process.env,\n    maxBuffer: DEFAULT_MAXBUFFER_SIZE,\n    encoding: 'utf8',\n  }, opts);\n\n  var c = child.exec(cmd, opts, function (err, stdout, stderr) {\n    if (callback) {\n      if (!err) {\n        callback(0, stdout, stderr);\n      } else if (err.code === undefined) {\n        // See issue #536\n        /* istanbul ignore next */\n        callback(1, stdout, stderr);\n      } else {\n        callback(err.code, stdout, stderr);\n      }\n    }\n  });\n\n  if (pipe) c.stdin.end(pipe);\n\n  if (!opts.silent) {\n    c.stdout.pipe(process.stdout);\n    c.stderr.pipe(process.stderr);\n  }\n\n  return c;\n}\n\n//@\n//@ ### exec(command [, options] [, callback])\n//@\n//@ Available options:\n//@\n//@ + `async`: Asynchronous execution. If a callback is provided, it will be set to\n//@   `true`, regardless of the passed value (default: `false`).\n//@ + `silent`: Do not echo program output to console (default: `false`).\n//@ + `encoding`: Character encoding to use. Affects the values returned to stdout and stderr, and\n//@   what is written to stdout and stderr when not in silent mode (default: `'utf8'`).\n//@ + and any option available to Node.js's\n//@   [`child_process.exec()`](https://nodejs.org/api/child_process.html#child_process_child_process_exec_command_options_callback)\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ var version = exec('node --version', {silent:true}).stdout;\n//@\n//@ var child = exec('some_long_running_process', {async:true});\n//@ child.stdout.on('data', function(data) {\n//@   /* ... do something with data ... */\n//@ });\n//@\n//@ exec('some_long_running_process', function(code, stdout, stderr) {\n//@   console.log('Exit code:', code);\n//@   console.log('Program output:', stdout);\n//@   console.log('Program stderr:', stderr);\n//@ });\n//@ ```\n//@\n//@ Executes the given `command` _synchronously_, unless otherwise specified.  When in synchronous\n//@ mode, this returns a `ShellString` (compatible with ShellJS v0.6.x, which returns an object\n//@ of the form `{ code:..., stdout:... , stderr:... }`). Otherwise, this returns the child process\n//@ object, and the `callback` receives the arguments `(code, stdout, stderr)`.\n//@\n//@ Not seeing the behavior you want? `exec()` runs everything through `sh`\n//@ by default (or `cmd.exe` on Windows), which differs from `bash`. If you\n//@ need bash-specific behavior, try out the `{shell: 'path/to/bash'}` option.\nfunction _exec(command, options, callback) {\n  options = options || {};\n  if (!command) common.error('must specify command');\n\n  var pipe = common.readFromPipe();\n\n  // Callback is defined instead of options.\n  if (typeof options === 'function') {\n    callback = options;\n    options = { async: true };\n  }\n\n  // Callback is defined with options.\n  if (typeof options === 'object' && typeof callback === 'function') {\n    options.async = true;\n  }\n\n  options = common.extend({\n    silent: common.config.silent,\n    async: false,\n  }, options);\n\n  if (options.async) {\n    return execAsync(command, options, pipe, callback);\n  } else {\n    return execSync(command, options, pipe);\n  }\n}\nmodule.exports = _exec;\n","var path = require('path');\nvar common = require('./common');\nvar _ls = require('./ls');\n\ncommon.register('find', _find, {});\n\n//@\n//@ ### find(path [, path ...])\n//@ ### find(path_array)\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ find('src', 'lib');\n//@ find(['src', 'lib']); // same as above\n//@ find('.').filter(function(file) { return file.match(/\\.js$/); });\n//@ ```\n//@\n//@ Returns array of all files (however deep) in the given paths.\n//@\n//@ The main difference from `ls('-R', path)` is that the resulting file names\n//@ include the base directories (e.g., `lib/resources/file1` instead of just `file1`).\nfunction _find(options, paths) {\n  if (!paths) {\n    common.error('no path specified');\n  } else if (typeof paths === 'string') {\n    paths = [].slice.call(arguments, 1);\n  }\n\n  var list = [];\n\n  function pushFile(file) {\n    if (process.platform === 'win32') {\n      file = file.replace(/\\\\/g, '/');\n    }\n    list.push(file);\n  }\n\n  // why not simply do `ls('-R', paths)`? because the output wouldn't give the base dirs\n  // to get the base dir in the output, we need instead `ls('-R', 'dir/*')` for every directory\n\n  paths.forEach(function (file) {\n    var stat;\n    try {\n      stat = common.statFollowLinks(file);\n    } catch (e) {\n      common.error('no such file or directory: ' + file);\n    }\n\n    pushFile(file);\n\n    if (stat.isDirectory()) {\n      _ls({ recursive: true, all: true }, file).forEach(function (subfile) {\n        pushFile(path.join(file, subfile));\n      });\n    }\n  });\n\n  return list;\n}\nmodule.exports = _find;\n","var common = require('./common');\nvar fs = require('fs');\n\ncommon.register('grep', _grep, {\n  globStart: 2, // don't glob-expand the regex\n  canReceivePipe: true,\n  cmdOptions: {\n    'v': 'inverse',\n    'l': 'nameOnly',\n    'i': 'ignoreCase',\n  },\n});\n\n//@\n//@ ### grep([options,] regex_filter, file [, file ...])\n//@ ### grep([options,] regex_filter, file_array)\n//@\n//@ Available options:\n//@\n//@ + `-v`: Invert `regex_filter` (only print non-matching lines).\n//@ + `-l`: Print only filenames of matching files.\n//@ + `-i`: Ignore case.\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ grep('-v', 'GLOBAL_VARIABLE', '*.js');\n//@ grep('GLOBAL_VARIABLE', '*.js');\n//@ ```\n//@\n//@ Reads input string from given files and returns a string containing all lines of the\n//@ file that match the given `regex_filter`.\nfunction _grep(options, regex, files) {\n  // Check if this is coming from a pipe\n  var pipe = common.readFromPipe();\n\n  if (!files && !pipe) common.error('no paths given', 2);\n\n  files = [].slice.call(arguments, 2);\n\n  if (pipe) {\n    files.unshift('-');\n  }\n\n  var grep = [];\n  if (options.ignoreCase) {\n    regex = new RegExp(regex, 'i');\n  }\n  files.forEach(function (file) {\n    if (!fs.existsSync(file) && file !== '-') {\n      common.error('no such file or directory: ' + file, 2, { continue: true });\n      return;\n    }\n\n    var contents = file === '-' ? pipe : fs.readFileSync(file, 'utf8');\n    if (options.nameOnly) {\n      if (contents.match(regex)) {\n        grep.push(file);\n      }\n    } else {\n      var lines = contents.split('\\n');\n      lines.forEach(function (line) {\n        var matched = line.match(regex);\n        if ((options.inverse && !matched) || (!options.inverse && matched)) {\n          grep.push(line);\n        }\n      });\n    }\n  });\n\n  return grep.join('\\n') + '\\n';\n}\nmodule.exports = _grep;\n","var common = require('./common');\nvar fs = require('fs');\n\ncommon.register('head', _head, {\n  canReceivePipe: true,\n  cmdOptions: {\n    'n': 'numLines',\n  },\n});\n\n// Reads |numLines| lines or the entire file, whichever is less.\nfunction readSomeLines(file, numLines) {\n  var buf = common.buffer();\n  var bufLength = buf.length;\n  var bytesRead = bufLength;\n  var pos = 0;\n\n  var fdr = fs.openSync(file, 'r');\n  var numLinesRead = 0;\n  var ret = '';\n  while (bytesRead === bufLength && numLinesRead < numLines) {\n    bytesRead = fs.readSync(fdr, buf, 0, bufLength, pos);\n    var bufStr = buf.toString('utf8', 0, bytesRead);\n    numLinesRead += bufStr.split('\\n').length - 1;\n    ret += bufStr;\n    pos += bytesRead;\n  }\n\n  fs.closeSync(fdr);\n  return ret;\n}\n\n//@\n//@ ### head([{'-n': \\<num\\>},] file [, file ...])\n//@ ### head([{'-n': \\<num\\>},] file_array)\n//@\n//@ Available options:\n//@\n//@ + `-n <num>`: Show the first `<num>` lines of the files\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ var str = head({'-n': 1}, 'file*.txt');\n//@ var str = head('file1', 'file2');\n//@ var str = head(['file1', 'file2']); // same as above\n//@ ```\n//@\n//@ Read the start of a file.\nfunction _head(options, files) {\n  var head = [];\n  var pipe = common.readFromPipe();\n\n  if (!files && !pipe) common.error('no paths given');\n\n  var idx = 1;\n  if (options.numLines === true) {\n    idx = 2;\n    options.numLines = Number(arguments[1]);\n  } else if (options.numLines === false) {\n    options.numLines = 10;\n  }\n  files = [].slice.call(arguments, idx);\n\n  if (pipe) {\n    files.unshift('-');\n  }\n\n  var shouldAppendNewline = false;\n  files.forEach(function (file) {\n    if (file !== '-') {\n      if (!fs.existsSync(file)) {\n        common.error('no such file or directory: ' + file, { continue: true });\n        return;\n      } else if (common.statFollowLinks(file).isDirectory()) {\n        common.error(\"error reading '\" + file + \"': Is a directory\", {\n          continue: true,\n        });\n        return;\n      }\n    }\n\n    var contents;\n    if (file === '-') {\n      contents = pipe;\n    } else if (options.numLines < 0) {\n      contents = fs.readFileSync(file, 'utf8');\n    } else {\n      contents = readSomeLines(file, options.numLines);\n    }\n\n    var lines = contents.split('\\n');\n    var hasTrailingNewline = (lines[lines.length - 1] === '');\n    if (hasTrailingNewline) {\n      lines.pop();\n    }\n    shouldAppendNewline = (hasTrailingNewline || options.numLines < lines.length);\n\n    head = head.concat(lines.slice(0, options.numLines));\n  });\n\n  if (shouldAppendNewline) {\n    head.push(''); // to add a trailing newline once we join\n  }\n  return head.join('\\n');\n}\nmodule.exports = _head;\n","var fs = require('fs');\nvar path = require('path');\nvar common = require('./common');\n\ncommon.register('ln', _ln, {\n  cmdOptions: {\n    's': 'symlink',\n    'f': 'force',\n  },\n});\n\n//@\n//@ ### ln([options,] source, dest)\n//@\n//@ Available options:\n//@\n//@ + `-s`: symlink\n//@ + `-f`: force\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ ln('file', 'newlink');\n//@ ln('-sf', 'file', 'existing');\n//@ ```\n//@\n//@ Links `source` to `dest`. Use `-f` to force the link, should `dest` already exist.\nfunction _ln(options, source, dest) {\n  if (!source || !dest) {\n    common.error('Missing <source> and/or <dest>');\n  }\n\n  source = String(source);\n  var sourcePath = path.normalize(source).replace(RegExp(path.sep + '$'), '');\n  var isAbsolute = (path.resolve(source) === sourcePath);\n  dest = path.resolve(process.cwd(), String(dest));\n\n  if (fs.existsSync(dest)) {\n    if (!options.force) {\n      common.error('Destination file exists', { continue: true });\n    }\n\n    fs.unlinkSync(dest);\n  }\n\n  if (options.symlink) {\n    var isWindows = process.platform === 'win32';\n    var linkType = isWindows ? 'file' : null;\n    var resolvedSourcePath = isAbsolute ? sourcePath : path.resolve(process.cwd(), path.dirname(dest), source);\n    if (!fs.existsSync(resolvedSourcePath)) {\n      common.error('Source file does not exist', { continue: true });\n    } else if (isWindows && common.statFollowLinks(resolvedSourcePath).isDirectory()) {\n      linkType = 'junction';\n    }\n\n    try {\n      fs.symlinkSync(linkType === 'junction' ? resolvedSourcePath : source, dest, linkType);\n    } catch (err) {\n      common.error(err.message);\n    }\n  } else {\n    if (!fs.existsSync(source)) {\n      common.error('Source file does not exist', { continue: true });\n    }\n    try {\n      fs.linkSync(source, dest);\n    } catch (err) {\n      common.error(err.message);\n    }\n  }\n  return '';\n}\nmodule.exports = _ln;\n","var path = require('path');\nvar fs = require('fs');\nvar common = require('./common');\nvar glob = require('glob');\n\nvar globPatternRecursive = path.sep + '**';\n\ncommon.register('ls', _ls, {\n  cmdOptions: {\n    'R': 'recursive',\n    'A': 'all',\n    'L': 'link',\n    'a': 'all_deprecated',\n    'd': 'directory',\n    'l': 'long',\n  },\n});\n\n//@\n//@ ### ls([options,] [path, ...])\n//@ ### ls([options,] path_array)\n//@\n//@ Available options:\n//@\n//@ + `-R`: recursive\n//@ + `-A`: all files (include files beginning with `.`, except for `.` and `..`)\n//@ + `-L`: follow symlinks\n//@ + `-d`: list directories themselves, not their contents\n//@ + `-l`: list objects representing each file, each with fields containing `ls\n//@         -l` output fields. See\n//@         [`fs.Stats`](https://nodejs.org/api/fs.html#fs_class_fs_stats)\n//@         for more info\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ ls('projs/*.js');\n//@ ls('-R', '/users/me', '/tmp');\n//@ ls('-R', ['/users/me', '/tmp']); // same as above\n//@ ls('-l', 'file.txt'); // { name: 'file.txt', mode: 33188, nlink: 1, ...}\n//@ ```\n//@\n//@ Returns array of files in the given `path`, or files in\n//@ the current directory if no `path` is  provided.\nfunction _ls(options, paths) {\n  if (options.all_deprecated) {\n    // We won't support the -a option as it's hard to image why it's useful\n    // (it includes '.' and '..' in addition to '.*' files)\n    // For backwards compatibility we'll dump a deprecated message and proceed as before\n    common.log('ls: Option -a is deprecated. Use -A instead');\n    options.all = true;\n  }\n\n  if (!paths) {\n    paths = ['.'];\n  } else {\n    paths = [].slice.call(arguments, 1);\n  }\n\n  var list = [];\n\n  function pushFile(abs, relName, stat) {\n    if (process.platform === 'win32') {\n      relName = relName.replace(/\\\\/g, '/');\n    }\n    if (options.long) {\n      stat = stat || (options.link ? common.statFollowLinks(abs) : common.statNoFollowLinks(abs));\n      list.push(addLsAttributes(relName, stat));\n    } else {\n      // list.push(path.relative(rel || '.', file));\n      list.push(relName);\n    }\n  }\n\n  paths.forEach(function (p) {\n    var stat;\n\n    try {\n      stat = options.link ? common.statFollowLinks(p) : common.statNoFollowLinks(p);\n      // follow links to directories by default\n      if (stat.isSymbolicLink()) {\n        /* istanbul ignore next */\n        // workaround for https://github.com/shelljs/shelljs/issues/795\n        // codecov seems to have a bug that miscalculate this block as uncovered.\n        // but according to nyc report this block does get covered.\n        try {\n          var _stat = common.statFollowLinks(p);\n          if (_stat.isDirectory()) {\n            stat = _stat;\n          }\n        } catch (_) {} // bad symlink, treat it like a file\n      }\n    } catch (e) {\n      common.error('no such file or directory: ' + p, 2, { continue: true });\n      return;\n    }\n\n    // If the stat succeeded\n    if (stat.isDirectory() && !options.directory) {\n      if (options.recursive) {\n        // use glob, because it's simple\n        glob.sync(p + globPatternRecursive, { dot: options.all, follow: options.link })\n          .forEach(function (item) {\n            // Glob pattern returns the directory itself and needs to be filtered out.\n            if (path.relative(p, item)) {\n              pushFile(item, path.relative(p, item));\n            }\n          });\n      } else if (options.all) {\n        // use fs.readdirSync, because it's fast\n        fs.readdirSync(p).forEach(function (item) {\n          pushFile(path.join(p, item), item);\n        });\n      } else {\n        // use fs.readdirSync and then filter out secret files\n        fs.readdirSync(p).forEach(function (item) {\n          if (item[0] !== '.') {\n            pushFile(path.join(p, item), item);\n          }\n        });\n      }\n    } else {\n      pushFile(p, p, stat);\n    }\n  });\n\n  // Add methods, to make this more compatible with ShellStrings\n  return list;\n}\n\nfunction addLsAttributes(pathName, stats) {\n  // Note: this object will contain more information than .toString() returns\n  stats.name = pathName;\n  stats.toString = function () {\n    // Return a string resembling unix's `ls -l` format\n    return [this.mode, this.nlink, this.uid, this.gid, this.size, this.mtime, this.name].join(' ');\n  };\n  return stats;\n}\n\nmodule.exports = _ls;\n","var common = require('./common');\nvar fs = require('fs');\nvar path = require('path');\n\ncommon.register('mkdir', _mkdir, {\n  cmdOptions: {\n    'p': 'fullpath',\n  },\n});\n\n// Recursively creates `dir`\nfunction mkdirSyncRecursive(dir) {\n  var baseDir = path.dirname(dir);\n\n  // Prevents some potential problems arising from malformed UNCs or\n  // insufficient permissions.\n  /* istanbul ignore next */\n  if (baseDir === dir) {\n    common.error('dirname() failed: [' + dir + ']');\n  }\n\n  // Base dir exists, no recursion necessary\n  if (fs.existsSync(baseDir)) {\n    fs.mkdirSync(dir, parseInt('0777', 8));\n    return;\n  }\n\n  // Base dir does not exist, go recursive\n  mkdirSyncRecursive(baseDir);\n\n  // Base dir created, can create dir\n  fs.mkdirSync(dir, parseInt('0777', 8));\n}\n\n//@\n//@ ### mkdir([options,] dir [, dir ...])\n//@ ### mkdir([options,] dir_array)\n//@\n//@ Available options:\n//@\n//@ + `-p`: full path (and create intermediate directories, if necessary)\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ mkdir('-p', '/tmp/a/b/c/d', '/tmp/e/f/g');\n//@ mkdir('-p', ['/tmp/a/b/c/d', '/tmp/e/f/g']); // same as above\n//@ ```\n//@\n//@ Creates directories.\nfunction _mkdir(options, dirs) {\n  if (!dirs) common.error('no paths given');\n\n  if (typeof dirs === 'string') {\n    dirs = [].slice.call(arguments, 1);\n  }\n  // if it's array leave it as it is\n\n  dirs.forEach(function (dir) {\n    try {\n      var stat = common.statNoFollowLinks(dir);\n      if (!options.fullpath) {\n        common.error('path already exists: ' + dir, { continue: true });\n      } else if (stat.isFile()) {\n        common.error('cannot create directory ' + dir + ': File exists', { continue: true });\n      }\n      return; // skip dir\n    } catch (e) {\n      // do nothing\n    }\n\n    // Base dir does not exist, and no -p option given\n    var baseDir = path.dirname(dir);\n    if (!fs.existsSync(baseDir) && !options.fullpath) {\n      common.error('no such file or directory: ' + baseDir, { continue: true });\n      return; // skip dir\n    }\n\n    try {\n      if (options.fullpath) {\n        mkdirSyncRecursive(path.resolve(dir));\n      } else {\n        fs.mkdirSync(dir, parseInt('0777', 8));\n      }\n    } catch (e) {\n      var reason;\n      if (e.code === 'EACCES') {\n        reason = 'Permission denied';\n      } else if (e.code === 'ENOTDIR' || e.code === 'ENOENT') {\n        reason = 'Not a directory';\n      } else {\n        /* istanbul ignore next */\n        throw e;\n      }\n      common.error('cannot create directory ' + dir + ': ' + reason, { continue: true });\n    }\n  });\n  return '';\n} // mkdir\nmodule.exports = _mkdir;\n","var fs = require('fs');\nvar path = require('path');\nvar common = require('./common');\nvar cp = require('./cp');\nvar rm = require('./rm');\n\ncommon.register('mv', _mv, {\n  cmdOptions: {\n    'f': '!no_force',\n    'n': 'no_force',\n  },\n});\n\n// Checks if cureent file was created recently\nfunction checkRecentCreated(sources, index) {\n  var lookedSource = sources[index];\n  return sources.slice(0, index).some(function (src) {\n    return path.basename(src) === path.basename(lookedSource);\n  });\n}\n\n//@\n//@ ### mv([options ,] source [, source ...], dest')\n//@ ### mv([options ,] source_array, dest')\n//@\n//@ Available options:\n//@\n//@ + `-f`: force (default behavior)\n//@ + `-n`: no-clobber\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ mv('-n', 'file', 'dir/');\n//@ mv('file1', 'file2', 'dir/');\n//@ mv(['file1', 'file2'], 'dir/'); // same as above\n//@ ```\n//@\n//@ Moves `source` file(s) to `dest`.\nfunction _mv(options, sources, dest) {\n  // Get sources, dest\n  if (arguments.length < 3) {\n    common.error('missing <source> and/or <dest>');\n  } else if (arguments.length > 3) {\n    sources = [].slice.call(arguments, 1, arguments.length - 1);\n    dest = arguments[arguments.length - 1];\n  } else if (typeof sources === 'string') {\n    sources = [sources];\n  } else {\n    // TODO(nate): figure out if we actually need this line\n    common.error('invalid arguments');\n  }\n\n  var exists = fs.existsSync(dest);\n  var stats = exists && common.statFollowLinks(dest);\n\n  // Dest is not existing dir, but multiple sources given\n  if ((!exists || !stats.isDirectory()) && sources.length > 1) {\n    common.error('dest is not a directory (too many sources)');\n  }\n\n  // Dest is an existing file, but no -f given\n  if (exists && stats.isFile() && options.no_force) {\n    common.error('dest file already exists: ' + dest);\n  }\n\n  sources.forEach(function (src, srcIndex) {\n    if (!fs.existsSync(src)) {\n      common.error('no such file or directory: ' + src, { continue: true });\n      return; // skip file\n    }\n\n    // If here, src exists\n\n    // When copying to '/path/dir':\n    //    thisDest = '/path/dir/file1'\n    var thisDest = dest;\n    if (fs.existsSync(dest) && common.statFollowLinks(dest).isDirectory()) {\n      thisDest = path.normalize(dest + '/' + path.basename(src));\n    }\n\n    var thisDestExists = fs.existsSync(thisDest);\n\n    if (thisDestExists && checkRecentCreated(sources, srcIndex)) {\n      // cannot overwrite file created recently in current execution, but we want to continue copying other files\n      if (!options.no_force) {\n        common.error(\"will not overwrite just-created '\" + thisDest + \"' with '\" + src + \"'\", { continue: true });\n      }\n      return;\n    }\n\n    if (fs.existsSync(thisDest) && options.no_force) {\n      common.error('dest file already exists: ' + thisDest, { continue: true });\n      return; // skip file\n    }\n\n    if (path.resolve(src) === path.dirname(path.resolve(thisDest))) {\n      common.error('cannot move to self: ' + src, { continue: true });\n      return; // skip file\n    }\n\n    try {\n      fs.renameSync(src, thisDest);\n    } catch (e) {\n      /* istanbul ignore next */\n      if (e.code === 'EXDEV') {\n        // If we're trying to `mv` to an external partition, we'll actually need\n        // to perform a copy and then clean up the original file. If either the\n        // copy or the rm fails with an exception, we should allow this\n        // exception to pass up to the top level.\n        cp('-r', src, thisDest);\n        rm('-rf', src);\n      }\n    }\n  }); // forEach(src)\n  return '';\n} // mv\nmodule.exports = _mv;\n","// see dirs.js\n","// see dirs.js\n","var path = require('path');\nvar common = require('./common');\n\ncommon.register('pwd', _pwd, {\n  allowGlobbing: false,\n});\n\n//@\n//@ ### pwd()\n//@\n//@ Returns the current directory.\nfunction _pwd() {\n  var pwd = path.resolve(process.cwd());\n  return pwd;\n}\nmodule.exports = _pwd;\n","var common = require('./common');\nvar fs = require('fs');\n\ncommon.register('rm', _rm, {\n  cmdOptions: {\n    'f': 'force',\n    'r': 'recursive',\n    'R': 'recursive',\n  },\n});\n\n// Recursively removes 'dir'\n// Adapted from https://github.com/ryanmcgrath/wrench-js\n//\n// Copyright (c) 2010 Ryan McGrath\n// Copyright (c) 2012 Artur Adib\n//\n// Licensed under the MIT License\n// http://www.opensource.org/licenses/mit-license.php\nfunction rmdirSyncRecursive(dir, force, fromSymlink) {\n  var files;\n\n  files = fs.readdirSync(dir);\n\n  // Loop through and delete everything in the sub-tree after checking it\n  for (var i = 0; i < files.length; i++) {\n    var file = dir + '/' + files[i];\n    var currFile = common.statNoFollowLinks(file);\n\n    if (currFile.isDirectory()) { // Recursive function back to the beginning\n      rmdirSyncRecursive(file, force);\n    } else { // Assume it's a file - perhaps a try/catch belongs here?\n      if (force || isWriteable(file)) {\n        try {\n          common.unlinkSync(file);\n        } catch (e) {\n          /* istanbul ignore next */\n          common.error('could not remove file (code ' + e.code + '): ' + file, {\n            continue: true,\n          });\n        }\n      }\n    }\n  }\n\n  // if was directory was referenced through a symbolic link,\n  // the contents should be removed, but not the directory itself\n  if (fromSymlink) return;\n\n  // Now that we know everything in the sub-tree has been deleted, we can delete the main directory.\n  // Huzzah for the shopkeep.\n\n  var result;\n  try {\n    // Retry on windows, sometimes it takes a little time before all the files in the directory are gone\n    var start = Date.now();\n\n    // TODO: replace this with a finite loop\n    for (;;) {\n      try {\n        result = fs.rmdirSync(dir);\n        if (fs.existsSync(dir)) throw { code: 'EAGAIN' };\n        break;\n      } catch (er) {\n        /* istanbul ignore next */\n        // In addition to error codes, also check if the directory still exists and loop again if true\n        if (process.platform === 'win32' && (er.code === 'ENOTEMPTY' || er.code === 'EBUSY' || er.code === 'EPERM' || er.code === 'EAGAIN')) {\n          if (Date.now() - start > 1000) throw er;\n        } else if (er.code === 'ENOENT') {\n          // Directory did not exist, deletion was successful\n          break;\n        } else {\n          throw er;\n        }\n      }\n    }\n  } catch (e) {\n    common.error('could not remove directory (code ' + e.code + '): ' + dir, { continue: true });\n  }\n\n  return result;\n} // rmdirSyncRecursive\n\n// Hack to determine if file has write permissions for current user\n// Avoids having to check user, group, etc, but it's probably slow\nfunction isWriteable(file) {\n  var writePermission = true;\n  try {\n    var __fd = fs.openSync(file, 'a');\n    fs.closeSync(__fd);\n  } catch (e) {\n    writePermission = false;\n  }\n\n  return writePermission;\n}\n\nfunction handleFile(file, options) {\n  if (options.force || isWriteable(file)) {\n    // -f was passed, or file is writable, so it can be removed\n    common.unlinkSync(file);\n  } else {\n    common.error('permission denied: ' + file, { continue: true });\n  }\n}\n\nfunction handleDirectory(file, options) {\n  if (options.recursive) {\n    // -r was passed, so directory can be removed\n    rmdirSyncRecursive(file, options.force);\n  } else {\n    common.error('path is a directory', { continue: true });\n  }\n}\n\nfunction handleSymbolicLink(file, options) {\n  var stats;\n  try {\n    stats = common.statFollowLinks(file);\n  } catch (e) {\n    // symlink is broken, so remove the symlink itself\n    common.unlinkSync(file);\n    return;\n  }\n\n  if (stats.isFile()) {\n    common.unlinkSync(file);\n  } else if (stats.isDirectory()) {\n    if (file[file.length - 1] === '/') {\n      // trailing separator, so remove the contents, not the link\n      if (options.recursive) {\n        // -r was passed, so directory can be removed\n        var fromSymlink = true;\n        rmdirSyncRecursive(file, options.force, fromSymlink);\n      } else {\n        common.error('path is a directory', { continue: true });\n      }\n    } else {\n      // no trailing separator, so remove the link\n      common.unlinkSync(file);\n    }\n  }\n}\n\nfunction handleFIFO(file) {\n  common.unlinkSync(file);\n}\n\n//@\n//@ ### rm([options,] file [, file ...])\n//@ ### rm([options,] file_array)\n//@\n//@ Available options:\n//@\n//@ + `-f`: force\n//@ + `-r, -R`: recursive\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ rm('-rf', '/tmp/*');\n//@ rm('some_file.txt', 'another_file.txt');\n//@ rm(['some_file.txt', 'another_file.txt']); // same as above\n//@ ```\n//@\n//@ Removes files.\nfunction _rm(options, files) {\n  if (!files) common.error('no paths given');\n\n  // Convert to array\n  files = [].slice.call(arguments, 1);\n\n  files.forEach(function (file) {\n    var lstats;\n    try {\n      var filepath = (file[file.length - 1] === '/')\n        ? file.slice(0, -1) // remove the '/' so lstatSync can detect symlinks\n        : file;\n      lstats = common.statNoFollowLinks(filepath); // test for existence\n    } catch (e) {\n      // Path does not exist, no force flag given\n      if (!options.force) {\n        common.error('no such file or directory: ' + file, { continue: true });\n      }\n      return; // skip file\n    }\n\n    // If here, path exists\n    if (lstats.isFile()) {\n      handleFile(file, options);\n    } else if (lstats.isDirectory()) {\n      handleDirectory(file, options);\n    } else if (lstats.isSymbolicLink()) {\n      handleSymbolicLink(file, options);\n    } else if (lstats.isFIFO()) {\n      handleFIFO(file);\n    }\n  }); // forEach(file)\n  return '';\n} // rm\nmodule.exports = _rm;\n","var common = require('./common');\nvar fs = require('fs');\n\ncommon.register('sed', _sed, {\n  globStart: 3, // don't glob-expand regexes\n  canReceivePipe: true,\n  cmdOptions: {\n    'i': 'inplace',\n  },\n});\n\n//@\n//@ ### sed([options,] search_regex, replacement, file [, file ...])\n//@ ### sed([options,] search_regex, replacement, file_array)\n//@\n//@ Available options:\n//@\n//@ + `-i`: Replace contents of `file` in-place. _Note that no backups will be created!_\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ sed('-i', 'PROGRAM_VERSION', 'v0.1.3', 'source.js');\n//@ sed(/.*DELETE_THIS_LINE.*\\n/, '', 'source.js');\n//@ ```\n//@\n//@ Reads an input string from `file`s, and performs a JavaScript `replace()` on the input\n//@ using the given `search_regex` and `replacement` string or function. Returns the new string after replacement.\n//@\n//@ Note:\n//@\n//@ Like unix `sed`, ShellJS `sed` supports capture groups. Capture groups are specified\n//@ using the `$n` syntax:\n//@\n//@ ```javascript\n//@ sed(/(\\w+)\\s(\\w+)/, '$2, $1', 'file.txt');\n//@ ```\nfunction _sed(options, regex, replacement, files) {\n  // Check if this is coming from a pipe\n  var pipe = common.readFromPipe();\n\n  if (typeof replacement !== 'string' && typeof replacement !== 'function') {\n    if (typeof replacement === 'number') {\n      replacement = replacement.toString(); // fallback\n    } else {\n      common.error('invalid replacement string');\n    }\n  }\n\n  // Convert all search strings to RegExp\n  if (typeof regex === 'string') {\n    regex = RegExp(regex);\n  }\n\n  if (!files && !pipe) {\n    common.error('no files given');\n  }\n\n  files = [].slice.call(arguments, 3);\n\n  if (pipe) {\n    files.unshift('-');\n  }\n\n  var sed = [];\n  files.forEach(function (file) {\n    if (!fs.existsSync(file) && file !== '-') {\n      common.error('no such file or directory: ' + file, 2, { continue: true });\n      return;\n    }\n\n    var contents = file === '-' ? pipe : fs.readFileSync(file, 'utf8');\n    var lines = contents.split('\\n');\n    var result = lines.map(function (line) {\n      return line.replace(regex, replacement);\n    }).join('\\n');\n\n    sed.push(result);\n\n    if (options.inplace) {\n      fs.writeFileSync(file, result, 'utf8');\n    }\n  });\n\n  return sed.join('\\n');\n}\nmodule.exports = _sed;\n","var common = require('./common');\n\ncommon.register('set', _set, {\n  allowGlobbing: false,\n  wrapOutput: false,\n});\n\n//@\n//@ ### set(options)\n//@\n//@ Available options:\n//@\n//@ + `+/-e`: exit upon error (`config.fatal`)\n//@ + `+/-v`: verbose: show all commands (`config.verbose`)\n//@ + `+/-f`: disable filename expansion (globbing)\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ set('-e'); // exit upon first error\n//@ set('+e'); // this undoes a \"set('-e')\"\n//@ ```\n//@\n//@ Sets global configuration variables.\nfunction _set(options) {\n  if (!options) {\n    var args = [].slice.call(arguments, 0);\n    if (args.length < 2) common.error('must provide an argument');\n    options = args[1];\n  }\n  var negate = (options[0] === '+');\n  if (negate) {\n    options = '-' + options.slice(1); // parseOptions needs a '-' prefix\n  }\n  options = common.parseOptions(options, {\n    'e': 'fatal',\n    'v': 'verbose',\n    'f': 'noglob',\n  });\n\n  if (negate) {\n    Object.keys(options).forEach(function (key) {\n      options[key] = !options[key];\n    });\n  }\n\n  Object.keys(options).forEach(function (key) {\n    // Only change the global config if `negate` is false and the option is true\n    // or if `negate` is true and the option is false (aka negate !== option)\n    if (negate !== options[key]) {\n      common.config[key] = options[key];\n    }\n  });\n  return;\n}\nmodule.exports = _set;\n","var common = require('./common');\nvar fs = require('fs');\n\ncommon.register('sort', _sort, {\n  canReceivePipe: true,\n  cmdOptions: {\n    'r': 'reverse',\n    'n': 'numerical',\n  },\n});\n\n// parse out the number prefix of a line\nfunction parseNumber(str) {\n  var match = str.match(/^\\s*(\\d*)\\s*(.*)$/);\n  return { num: Number(match[1]), value: match[2] };\n}\n\n// compare two strings case-insensitively, but examine case for strings that are\n// case-insensitive equivalent\nfunction unixCmp(a, b) {\n  var aLower = a.toLowerCase();\n  var bLower = b.toLowerCase();\n  return (aLower === bLower ?\n      -1 * a.localeCompare(b) : // unix sort treats case opposite how javascript does\n      aLower.localeCompare(bLower));\n}\n\n// compare two strings in the fashion that unix sort's -n option works\nfunction numericalCmp(a, b) {\n  var objA = parseNumber(a);\n  var objB = parseNumber(b);\n  if (objA.hasOwnProperty('num') && objB.hasOwnProperty('num')) {\n    return ((objA.num !== objB.num) ?\n        (objA.num - objB.num) :\n        unixCmp(objA.value, objB.value));\n  } else {\n    return unixCmp(objA.value, objB.value);\n  }\n}\n\n//@\n//@ ### sort([options,] file [, file ...])\n//@ ### sort([options,] file_array)\n//@\n//@ Available options:\n//@\n//@ + `-r`: Reverse the results\n//@ + `-n`: Compare according to numerical value\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ sort('foo.txt', 'bar.txt');\n//@ sort('-r', 'foo.txt');\n//@ ```\n//@\n//@ Return the contents of the `file`s, sorted line-by-line. Sorting multiple\n//@ files mixes their content (just as unix `sort` does).\nfunction _sort(options, files) {\n  // Check if this is coming from a pipe\n  var pipe = common.readFromPipe();\n\n  if (!files && !pipe) common.error('no files given');\n\n  files = [].slice.call(arguments, 1);\n\n  if (pipe) {\n    files.unshift('-');\n  }\n\n  var lines = files.reduce(function (accum, file) {\n    if (file !== '-') {\n      if (!fs.existsSync(file)) {\n        common.error('no such file or directory: ' + file, { continue: true });\n        return accum;\n      } else if (common.statFollowLinks(file).isDirectory()) {\n        common.error('read failed: ' + file + ': Is a directory', {\n          continue: true,\n        });\n        return accum;\n      }\n    }\n\n    var contents = file === '-' ? pipe : fs.readFileSync(file, 'utf8');\n    return accum.concat(contents.trimRight().split('\\n'));\n  }, []);\n\n  var sorted = lines.sort(options.numerical ? numericalCmp : unixCmp);\n\n  if (options.reverse) {\n    sorted = sorted.reverse();\n  }\n\n  return sorted.join('\\n') + '\\n';\n}\n\nmodule.exports = _sort;\n","var common = require('./common');\nvar fs = require('fs');\n\ncommon.register('tail', _tail, {\n  canReceivePipe: true,\n  cmdOptions: {\n    'n': 'numLines',\n  },\n});\n\n//@\n//@ ### tail([{'-n': \\<num\\>},] file [, file ...])\n//@ ### tail([{'-n': \\<num\\>},] file_array)\n//@\n//@ Available options:\n//@\n//@ + `-n <num>`: Show the last `<num>` lines of `file`s\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ var str = tail({'-n': 1}, 'file*.txt');\n//@ var str = tail('file1', 'file2');\n//@ var str = tail(['file1', 'file2']); // same as above\n//@ ```\n//@\n//@ Read the end of a `file`.\nfunction _tail(options, files) {\n  var tail = [];\n  var pipe = common.readFromPipe();\n\n  if (!files && !pipe) common.error('no paths given');\n\n  var idx = 1;\n  if (options.numLines === true) {\n    idx = 2;\n    options.numLines = Number(arguments[1]);\n  } else if (options.numLines === false) {\n    options.numLines = 10;\n  }\n  options.numLines = -1 * Math.abs(options.numLines);\n  files = [].slice.call(arguments, idx);\n\n  if (pipe) {\n    files.unshift('-');\n  }\n\n  var shouldAppendNewline = false;\n  files.forEach(function (file) {\n    if (file !== '-') {\n      if (!fs.existsSync(file)) {\n        common.error('no such file or directory: ' + file, { continue: true });\n        return;\n      } else if (common.statFollowLinks(file).isDirectory()) {\n        common.error(\"error reading '\" + file + \"': Is a directory\", {\n          continue: true,\n        });\n        return;\n      }\n    }\n\n    var contents = file === '-' ? pipe : fs.readFileSync(file, 'utf8');\n\n    var lines = contents.split('\\n');\n    if (lines[lines.length - 1] === '') {\n      lines.pop();\n      shouldAppendNewline = true;\n    } else {\n      shouldAppendNewline = false;\n    }\n\n    tail = tail.concat(lines.slice(options.numLines));\n  });\n\n  if (shouldAppendNewline) {\n    tail.push(''); // to add a trailing newline once we join\n  }\n  return tail.join('\\n');\n}\nmodule.exports = _tail;\n","var common = require('./common');\nvar os = require('os');\nvar fs = require('fs');\n\ncommon.register('tempdir', _tempDir, {\n  allowGlobbing: false,\n  wrapOutput: false,\n});\n\n// Returns false if 'dir' is not a writeable directory, 'dir' otherwise\nfunction writeableDir(dir) {\n  if (!dir || !fs.existsSync(dir)) return false;\n\n  if (!common.statFollowLinks(dir).isDirectory()) return false;\n\n  var testFile = dir + '/' + common.randomFileName();\n  try {\n    fs.writeFileSync(testFile, ' ');\n    common.unlinkSync(testFile);\n    return dir;\n  } catch (e) {\n    /* istanbul ignore next */\n    return false;\n  }\n}\n\n// Variable to cache the tempdir value for successive lookups.\nvar cachedTempDir;\n\n//@\n//@ ### tempdir()\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ var tmp = tempdir(); // \"/tmp\" for most *nix platforms\n//@ ```\n//@\n//@ Searches and returns string containing a writeable, platform-dependent temporary directory.\n//@ Follows Python's [tempfile algorithm](http://docs.python.org/library/tempfile.html#tempfile.tempdir).\nfunction _tempDir() {\n  if (cachedTempDir) return cachedTempDir;\n\n  cachedTempDir = writeableDir(os.tmpdir()) ||\n                  writeableDir(process.env.TMPDIR) ||\n                  writeableDir(process.env.TEMP) ||\n                  writeableDir(process.env.TMP) ||\n                  writeableDir(process.env.Wimp$ScrapDir) || // RiscOS\n                  writeableDir('C:\\\\TEMP') || // Windows\n                  writeableDir('C:\\\\TMP') || // Windows\n                  writeableDir('\\\\TEMP') || // Windows\n                  writeableDir('\\\\TMP') || // Windows\n                  writeableDir('/tmp') ||\n                  writeableDir('/var/tmp') ||\n                  writeableDir('/usr/tmp') ||\n                  writeableDir('.'); // last resort\n\n  return cachedTempDir;\n}\n\n// Indicates if the tempdir value is currently cached. This is exposed for tests\n// only. The return value should only be tested for truthiness.\nfunction isCached() {\n  return cachedTempDir;\n}\n\n// Clears the cached tempDir value, if one is cached. This is exposed for tests\n// only.\nfunction clearCache() {\n  cachedTempDir = undefined;\n}\n\nmodule.exports.tempDir = _tempDir;\nmodule.exports.isCached = isCached;\nmodule.exports.clearCache = clearCache;\n","var common = require('./common');\nvar fs = require('fs');\n\ncommon.register('test', _test, {\n  cmdOptions: {\n    'b': 'block',\n    'c': 'character',\n    'd': 'directory',\n    'e': 'exists',\n    'f': 'file',\n    'L': 'link',\n    'p': 'pipe',\n    'S': 'socket',\n  },\n  wrapOutput: false,\n  allowGlobbing: false,\n});\n\n\n//@\n//@ ### test(expression)\n//@\n//@ Available expression primaries:\n//@\n//@ + `'-b', 'path'`: true if path is a block device\n//@ + `'-c', 'path'`: true if path is a character device\n//@ + `'-d', 'path'`: true if path is a directory\n//@ + `'-e', 'path'`: true if path exists\n//@ + `'-f', 'path'`: true if path is a regular file\n//@ + `'-L', 'path'`: true if path is a symbolic link\n//@ + `'-p', 'path'`: true if path is a pipe (FIFO)\n//@ + `'-S', 'path'`: true if path is a socket\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ if (test('-d', path)) { /* do something with dir */ };\n//@ if (!test('-f', path)) continue; // skip if it's a regular file\n//@ ```\n//@\n//@ Evaluates `expression` using the available primaries and returns corresponding value.\nfunction _test(options, path) {\n  if (!path) common.error('no path given');\n\n  var canInterpret = false;\n  Object.keys(options).forEach(function (key) {\n    if (options[key] === true) {\n      canInterpret = true;\n    }\n  });\n\n  if (!canInterpret) common.error('could not interpret expression');\n\n  if (options.link) {\n    try {\n      return common.statNoFollowLinks(path).isSymbolicLink();\n    } catch (e) {\n      return false;\n    }\n  }\n\n  if (!fs.existsSync(path)) return false;\n\n  if (options.exists) return true;\n\n  var stats = common.statFollowLinks(path);\n\n  if (options.block) return stats.isBlockDevice();\n\n  if (options.character) return stats.isCharacterDevice();\n\n  if (options.directory) return stats.isDirectory();\n\n  if (options.file) return stats.isFile();\n\n  /* istanbul ignore next */\n  if (options.pipe) return stats.isFIFO();\n\n  /* istanbul ignore next */\n  if (options.socket) return stats.isSocket();\n\n  /* istanbul ignore next */\n  return false; // fallback\n} // test\nmodule.exports = _test;\n","var common = require('./common');\nvar fs = require('fs');\nvar path = require('path');\n\ncommon.register('to', _to, {\n  pipeOnly: true,\n  wrapOutput: false,\n});\n\n//@\n//@ ### ShellString.prototype.to(file)\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ cat('input.txt').to('output.txt');\n//@ ```\n//@\n//@ Analogous to the redirection operator `>` in Unix, but works with\n//@ `ShellStrings` (such as those returned by `cat`, `grep`, etc.). _Like Unix\n//@ redirections, `to()` will overwrite any existing file!_\nfunction _to(options, file) {\n  if (!file) common.error('wrong arguments');\n\n  if (!fs.existsSync(path.dirname(file))) {\n    common.error('no such file or directory: ' + path.dirname(file));\n  }\n\n  try {\n    fs.writeFileSync(file, this.stdout || this.toString(), 'utf8');\n    return this;\n  } catch (e) {\n    /* istanbul ignore next */\n    common.error('could not write to file (code ' + e.code + '): ' + file, { continue: true });\n  }\n}\nmodule.exports = _to;\n","var common = require('./common');\nvar fs = require('fs');\nvar path = require('path');\n\ncommon.register('toEnd', _toEnd, {\n  pipeOnly: true,\n  wrapOutput: false,\n});\n\n//@\n//@ ### ShellString.prototype.toEnd(file)\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ cat('input.txt').toEnd('output.txt');\n//@ ```\n//@\n//@ Analogous to the redirect-and-append operator `>>` in Unix, but works with\n//@ `ShellStrings` (such as those returned by `cat`, `grep`, etc.).\nfunction _toEnd(options, file) {\n  if (!file) common.error('wrong arguments');\n\n  if (!fs.existsSync(path.dirname(file))) {\n    common.error('no such file or directory: ' + path.dirname(file));\n  }\n\n  try {\n    fs.appendFileSync(file, this.stdout || this.toString(), 'utf8');\n    return this;\n  } catch (e) {\n    /* istanbul ignore next */\n    common.error('could not append to file (code ' + e.code + '): ' + file, { continue: true });\n  }\n}\nmodule.exports = _toEnd;\n","var common = require('./common');\nvar fs = require('fs');\n\ncommon.register('touch', _touch, {\n  cmdOptions: {\n    'a': 'atime_only',\n    'c': 'no_create',\n    'd': 'date',\n    'm': 'mtime_only',\n    'r': 'reference',\n  },\n});\n\n//@\n//@ ### touch([options,] file [, file ...])\n//@ ### touch([options,] file_array)\n//@\n//@ Available options:\n//@\n//@ + `-a`: Change only the access time\n//@ + `-c`: Do not create any files\n//@ + `-m`: Change only the modification time\n//@ + `-d DATE`: Parse `DATE` and use it instead of current time\n//@ + `-r FILE`: Use `FILE`'s times instead of current time\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ touch('source.js');\n//@ touch('-c', '/path/to/some/dir/source.js');\n//@ touch({ '-r': FILE }, '/path/to/some/dir/source.js');\n//@ ```\n//@\n//@ Update the access and modification times of each `FILE` to the current time.\n//@ A `FILE` argument that does not exist is created empty, unless `-c` is supplied.\n//@ This is a partial implementation of [`touch(1)`](http://linux.die.net/man/1/touch).\nfunction _touch(opts, files) {\n  if (!files) {\n    common.error('no files given');\n  } else if (typeof files === 'string') {\n    files = [].slice.call(arguments, 1);\n  } else {\n    common.error('file arg should be a string file path or an Array of string file paths');\n  }\n\n  files.forEach(function (f) {\n    touchFile(opts, f);\n  });\n  return '';\n}\n\nfunction touchFile(opts, file) {\n  var stat = tryStatFile(file);\n\n  if (stat && stat.isDirectory()) {\n    // don't error just exit\n    return;\n  }\n\n  // if the file doesn't already exist and the user has specified --no-create then\n  // this script is finished\n  if (!stat && opts.no_create) {\n    return;\n  }\n\n  // open the file and then close it. this will create it if it doesn't exist but will\n  // not truncate the file\n  fs.closeSync(fs.openSync(file, 'a'));\n\n  //\n  // Set timestamps\n  //\n\n  // setup some defaults\n  var now = new Date();\n  var mtime = opts.date || now;\n  var atime = opts.date || now;\n\n  // use reference file\n  if (opts.reference) {\n    var refStat = tryStatFile(opts.reference);\n    if (!refStat) {\n      common.error('failed to get attributess of ' + opts.reference);\n    }\n    mtime = refStat.mtime;\n    atime = refStat.atime;\n  } else if (opts.date) {\n    mtime = opts.date;\n    atime = opts.date;\n  }\n\n  if (opts.atime_only && opts.mtime_only) {\n    // keep the new values of mtime and atime like GNU\n  } else if (opts.atime_only) {\n    mtime = stat.mtime;\n  } else if (opts.mtime_only) {\n    atime = stat.atime;\n  }\n\n  fs.utimesSync(file, atime, mtime);\n}\n\nmodule.exports = _touch;\n\nfunction tryStatFile(filePath) {\n  try {\n    return common.statFollowLinks(filePath);\n  } catch (e) {\n    return null;\n  }\n}\n","var common = require('./common');\nvar fs = require('fs');\n\n// add c spaces to the left of str\nfunction lpad(c, str) {\n  var res = '' + str;\n  if (res.length < c) {\n    res = Array((c - res.length) + 1).join(' ') + res;\n  }\n  return res;\n}\n\ncommon.register('uniq', _uniq, {\n  canReceivePipe: true,\n  cmdOptions: {\n    'i': 'ignoreCase',\n    'c': 'count',\n    'd': 'duplicates',\n  },\n});\n\n//@\n//@ ### uniq([options,] [input, [output]])\n//@\n//@ Available options:\n//@\n//@ + `-i`: Ignore case while comparing\n//@ + `-c`: Prefix lines by the number of occurrences\n//@ + `-d`: Only print duplicate lines, one for each group of identical lines\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ uniq('foo.txt');\n//@ uniq('-i', 'foo.txt');\n//@ uniq('-cd', 'foo.txt', 'bar.txt');\n//@ ```\n//@\n//@ Filter adjacent matching lines from `input`.\nfunction _uniq(options, input, output) {\n  // Check if this is coming from a pipe\n  var pipe = common.readFromPipe();\n\n  if (!pipe) {\n    if (!input) common.error('no input given');\n\n    if (!fs.existsSync(input)) {\n      common.error(input + ': No such file or directory');\n    } else if (common.statFollowLinks(input).isDirectory()) {\n      common.error(\"error reading '\" + input + \"'\");\n    }\n  }\n  if (output && fs.existsSync(output) && common.statFollowLinks(output).isDirectory()) {\n    common.error(output + ': Is a directory');\n  }\n\n  var lines = (input ? fs.readFileSync(input, 'utf8') : pipe).\n              trimRight().\n              split('\\n');\n\n  var compare = function (a, b) {\n    return options.ignoreCase ?\n           a.toLocaleLowerCase().localeCompare(b.toLocaleLowerCase()) :\n           a.localeCompare(b);\n  };\n  var uniqed = lines.reduceRight(function (res, e) {\n    // Perform uniq -c on the input\n    if (res.length === 0) {\n      return [{ count: 1, ln: e }];\n    } else if (compare(res[0].ln, e) === 0) {\n      return [{ count: res[0].count + 1, ln: e }].concat(res.slice(1));\n    } else {\n      return [{ count: 1, ln: e }].concat(res);\n    }\n  }, []).filter(function (obj) {\n                 // Do we want only duplicated objects?\n    return options.duplicates ? obj.count > 1 : true;\n  }).map(function (obj) {\n                 // Are we tracking the counts of each line?\n    return (options.count ? (lpad(7, obj.count) + ' ') : '') + obj.ln;\n  }).join('\\n') + '\\n';\n\n  if (output) {\n    (new common.ShellString(uniqed)).to(output);\n    // if uniq writes to output, nothing is passed to the next command in the pipeline (if any)\n    return '';\n  } else {\n    return uniqed;\n  }\n}\n\nmodule.exports = _uniq;\n","var common = require('./common');\nvar fs = require('fs');\nvar path = require('path');\n\ncommon.register('which', _which, {\n  allowGlobbing: false,\n  cmdOptions: {\n    'a': 'all',\n  },\n});\n\n// XP's system default value for `PATHEXT` system variable, just in case it's not\n// set on Windows.\nvar XP_DEFAULT_PATHEXT = '.com;.exe;.bat;.cmd;.vbs;.vbe;.js;.jse;.wsf;.wsh';\n\n// For earlier versions of NodeJS that doesn't have a list of constants (< v6)\nvar FILE_EXECUTABLE_MODE = 1;\n\nfunction isWindowsPlatform() {\n  return process.platform === 'win32';\n}\n\n// Cross-platform method for splitting environment `PATH` variables\nfunction splitPath(p) {\n  return p ? p.split(path.delimiter) : [];\n}\n\n// Tests are running all cases for this func but it stays uncovered by codecov due to unknown reason\n/* istanbul ignore next */\nfunction isExecutable(pathName) {\n  try {\n    // TODO(node-support): replace with fs.constants.X_OK once remove support for node < v6\n    fs.accessSync(pathName, FILE_EXECUTABLE_MODE);\n  } catch (err) {\n    return false;\n  }\n  return true;\n}\n\nfunction checkPath(pathName) {\n  return fs.existsSync(pathName) && !common.statFollowLinks(pathName).isDirectory()\n    && (isWindowsPlatform() || isExecutable(pathName));\n}\n\n//@\n//@ ### which(command)\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ var nodeExec = which('node');\n//@ ```\n//@\n//@ Searches for `command` in the system's `PATH`. On Windows, this uses the\n//@ `PATHEXT` variable to append the extension if it's not already executable.\n//@ Returns string containing the absolute path to `command`.\nfunction _which(options, cmd) {\n  if (!cmd) common.error('must specify command');\n\n  var isWindows = isWindowsPlatform();\n  var pathArray = splitPath(process.env.PATH);\n\n  var queryMatches = [];\n\n  // No relative/absolute paths provided?\n  if (cmd.indexOf('/') === -1) {\n    // Assume that there are no extensions to append to queries (this is the\n    // case for unix)\n    var pathExtArray = [''];\n    if (isWindows) {\n      // In case the PATHEXT variable is somehow not set (e.g.\n      // child_process.spawn with an empty environment), use the XP default.\n      var pathExtEnv = process.env.PATHEXT || XP_DEFAULT_PATHEXT;\n      pathExtArray = splitPath(pathExtEnv.toUpperCase());\n    }\n\n    // Search for command in PATH\n    for (var k = 0; k < pathArray.length; k++) {\n      // already found it\n      if (queryMatches.length > 0 && !options.all) break;\n\n      var attempt = path.resolve(pathArray[k], cmd);\n\n      if (isWindows) {\n        attempt = attempt.toUpperCase();\n      }\n\n      var match = attempt.match(/\\.[^<>:\"/\\|?*.]+$/);\n      if (match && pathExtArray.indexOf(match[0]) >= 0) { // this is Windows-only\n        // The user typed a query with the file extension, like\n        // `which('node.exe')`\n        if (checkPath(attempt)) {\n          queryMatches.push(attempt);\n          break;\n        }\n      } else { // All-platforms\n        // Cycle through the PATHEXT array, and check each extension\n        // Note: the array is always [''] on Unix\n        for (var i = 0; i < pathExtArray.length; i++) {\n          var ext = pathExtArray[i];\n          var newAttempt = attempt + ext;\n          if (checkPath(newAttempt)) {\n            queryMatches.push(newAttempt);\n            break;\n          }\n        }\n      }\n    }\n  } else if (checkPath(cmd)) { // a valid absolute or relative path\n    queryMatches.push(path.resolve(cmd));\n  }\n\n  if (queryMatches.length > 0) {\n    return options.all ? queryMatches : queryMatches[0];\n  }\n  return options.all ? [] : null;\n}\nmodule.exports = _which;\n","/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\n\"use strict\";\n\nfunction DEFNODE(type, props, methods, base) {\n    if (typeof base === \"undefined\") base = AST_Node;\n    props = props ? props.split(/\\s+/) : [];\n    var self_props = props;\n    if (base && base.PROPS) props = props.concat(base.PROPS);\n    var code = [\n        \"return function AST_\", type, \"(props){\",\n        \"if(props){\",\n    ];\n    props.forEach(function(prop) {\n        code.push(\"this.\", prop, \"=props.\", prop, \";\");\n    });\n    var proto = base && new base;\n    if (proto && proto.initialize || methods && methods.initialize) code.push(\"this.initialize();\");\n    code.push(\"}}\");\n    var ctor = new Function(code.join(\"\"))();\n    if (proto) {\n        ctor.prototype = proto;\n        ctor.BASE = base;\n    }\n    if (base) base.SUBCLASSES.push(ctor);\n    ctor.prototype.CTOR = ctor;\n    ctor.PROPS = props || null;\n    ctor.SELF_PROPS = self_props;\n    ctor.SUBCLASSES = [];\n    if (type) {\n        ctor.prototype.TYPE = ctor.TYPE = type;\n    }\n    if (methods) for (var name in methods) if (HOP(methods, name)) {\n        if (/^\\$/.test(name)) {\n            ctor[name.substr(1)] = methods[name];\n        } else {\n            ctor.prototype[name] = methods[name];\n        }\n    }\n    ctor.DEFMETHOD = function(name, method) {\n        this.prototype[name] = method;\n    };\n    if (typeof exports !== \"undefined\") {\n        exports[\"AST_\" + type] = ctor;\n    }\n    return ctor;\n}\n\nvar AST_Token = DEFNODE(\"Token\", \"type value line col pos endline endcol endpos nlb comments_before comments_after file raw\", {\n}, null);\n\nvar AST_Node = DEFNODE(\"Node\", \"start end\", {\n    _clone: function(deep) {\n        if (deep) {\n            var self = this.clone();\n            return self.transform(new TreeTransformer(function(node) {\n                if (node !== self) {\n                    return node.clone(true);\n                }\n            }));\n        }\n        return new this.CTOR(this);\n    },\n    clone: function(deep) {\n        return this._clone(deep);\n    },\n    $documentation: \"Base class of all AST nodes\",\n    $propdoc: {\n        start: \"[AST_Token] The first token of this node\",\n        end: \"[AST_Token] The last token of this node\"\n    },\n    walk: function(visitor) {\n        visitor.visit(this);\n    },\n    _validate: noop,\n    validate: function() {\n        var ctor = this.CTOR;\n        do {\n            ctor.prototype._validate.call(this);\n        } while (ctor = ctor.BASE);\n    },\n    validate_ast: function() {\n        var marker = {};\n        this.walk(new TreeWalker(function(node) {\n            if (node.validate_visited === marker) {\n                throw new Error(string_template(\"cannot reuse {type} from [{file}:{line},{col}]\", {\n                    type: \"AST_\" + node.TYPE,\n                    file: node.start.file,\n                    line: node.start.line,\n                    col: node.start.col,\n                }));\n            }\n            node.validate_visited = marker;\n        }));\n    },\n}, null);\n\n(AST_Node.log_function = function(fn, verbose) {\n    if (!fn) {\n        AST_Node.info = AST_Node.warn = noop;\n        return;\n    }\n    var printed = Object.create(null);\n    AST_Node.info = verbose ? function(text, props) {\n        log(\"INFO: \" + string_template(text, props));\n    } : noop;\n    AST_Node.warn = function(text, props) {\n        log(\"WARN: \" + string_template(text, props));\n    };\n\n    function log(msg) {\n        if (printed[msg]) return;\n        printed[msg] = true;\n        fn(msg);\n    }\n})();\n\nvar restore_transforms = [];\nAST_Node.enable_validation = function() {\n    AST_Node.disable_validation();\n    (function validate_transform(ctor) {\n        var transform = ctor.prototype.transform;\n        ctor.prototype.transform = function(tw, in_list) {\n            var node = transform.call(this, tw, in_list);\n            if (node instanceof AST_Node) {\n                node.validate();\n            } else if (!(node === null || in_list && List.is_op(node))) {\n                throw new Error(\"invalid transformed value: \" + node);\n            }\n            return node;\n        };\n        restore_transforms.push(function() {\n            ctor.prototype.transform = transform;\n        });\n        ctor.SUBCLASSES.forEach(validate_transform);\n    })(this);\n};\n\nAST_Node.disable_validation = function() {\n    var restore;\n    while (restore = restore_transforms.pop()) restore();\n};\n\n/* -----[ statements ]----- */\n\nvar AST_Statement = DEFNODE(\"Statement\", null, {\n    $documentation: \"Base class of all statements\",\n});\n\nvar AST_Debugger = DEFNODE(\"Debugger\", null, {\n    $documentation: \"Represents a debugger statement\",\n}, AST_Statement);\n\nvar AST_Directive = DEFNODE(\"Directive\", \"value quote\", {\n    $documentation: \"Represents a directive, like \\\"use strict\\\";\",\n    $propdoc: {\n        value: \"[string] The value of this directive as a plain string (it's not an AST_String!)\",\n        quote: \"[string] the original quote character\"\n    },\n    _validate: function() {\n        if (typeof this.value != \"string\") throw new Error(\"value must be string\");\n    },\n}, AST_Statement);\n\nvar AST_EmptyStatement = DEFNODE(\"EmptyStatement\", null, {\n    $documentation: \"The empty statement (empty block or simply a semicolon)\"\n}, AST_Statement);\n\nfunction validate_expression(value, prop, multiple, allow_spread, allow_hole) {\n    multiple = multiple ? \"contain\" : \"be\";\n    if (!(value instanceof AST_Node)) throw new Error(prop + \" must \" + multiple + \" AST_Node\");\n    if (value instanceof AST_DefaultValue) throw new Error(prop + \" cannot \" + multiple + \" AST_DefaultValue\");\n    if (value instanceof AST_Destructured) throw new Error(prop + \" cannot \" + multiple + \" AST_Destructured\");\n    if (value instanceof AST_Hole && !allow_hole) throw new Error(prop + \" cannot \" + multiple + \" AST_Hole\");\n    if (value instanceof AST_Spread && !allow_spread) throw new Error(prop + \" cannot \" + multiple + \" AST_Spread\");\n    if (value instanceof AST_Statement && !is_function(value)) {\n        throw new Error(prop + \" cannot \" + multiple + \" AST_Statement\");\n    }\n    if (value instanceof AST_SymbolDeclaration) {\n        throw new Error(prop + \" cannot \" + multiple + \" AST_SymbolDeclaration\");\n    }\n}\n\nfunction must_be_expression(node, prop) {\n    validate_expression(node[prop], prop);\n}\n\nvar AST_SimpleStatement = DEFNODE(\"SimpleStatement\", \"body\", {\n    $documentation: \"A statement consisting of an expression, i.e. a = 1 + 2\",\n    $propdoc: {\n        body: \"[AST_Node] an expression node (should not be instanceof AST_Statement)\"\n    },\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            node.body.walk(visitor);\n        });\n    },\n    _validate: function() {\n        must_be_expression(this, \"body\");\n    },\n}, AST_Statement);\n\nvar AST_BlockScope = DEFNODE(\"BlockScope\", \"enclosed functions make_def parent_scope variables\", {\n    $documentation: \"Base class for all statements introducing a lexical scope\",\n    $propdoc: {\n        enclosed: \"[SymbolDef*/S] a list of all symbol definitions that are accessed from this scope or any subscopes\",\n        functions: \"[Object/S] like `variables`, but only lists function declarations\",\n        parent_scope: \"[AST_Scope?/S] link to the parent scope\",\n        variables: \"[Object/S] a map of name -> SymbolDef for all variables/functions defined in this scope\",\n    },\n    clone: function(deep) {\n        var node = this._clone(deep);\n        if (this.enclosed) node.enclosed = this.enclosed.slice();\n        if (this.functions) node.functions = this.functions.clone();\n        if (this.variables) node.variables = this.variables.clone();\n        return node;\n    },\n    pinned: function() {\n        return this.resolve().pinned();\n    },\n    resolve: function() {\n        return this.parent_scope.resolve();\n    },\n    _validate: function() {\n        if (this.parent_scope == null) return;\n        if (!(this.parent_scope instanceof AST_BlockScope)) throw new Error(\"parent_scope must be AST_BlockScope\");\n        if (!(this.resolve() instanceof AST_Scope)) throw new Error(\"must be contained within AST_Scope\");\n    },\n}, AST_Statement);\n\nfunction walk_body(node, visitor) {\n    node.body.forEach(function(node) {\n        node.walk(visitor);\n    });\n}\n\nvar AST_Block = DEFNODE(\"Block\", \"body\", {\n    $documentation: \"A body of statements (usually braced)\",\n    $propdoc: {\n        body: \"[AST_Statement*] an array of statements\"\n    },\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            walk_body(node, visitor);\n        });\n    },\n    _validate: function() {\n        this.body.forEach(function(node) {\n            if (!(node instanceof AST_Statement)) throw new Error(\"body must be AST_Statement[]\");\n            if (is_function(node)) throw new Error(\"body cannot contain AST_Function\");\n        });\n    },\n}, AST_BlockScope);\n\nvar AST_BlockStatement = DEFNODE(\"BlockStatement\", null, {\n    $documentation: \"A block statement\",\n}, AST_Block);\n\nvar AST_StatementWithBody = DEFNODE(\"StatementWithBody\", \"body\", {\n    $documentation: \"Base class for all statements that contain one nested body: `For`, `ForIn`, `Do`, `While`, `With`\",\n    $propdoc: {\n        body: \"[AST_Statement] the body; this should always be present, even if it's an AST_EmptyStatement\"\n    },\n    _validate: function() {\n        if (!(this.body instanceof AST_Statement)) throw new Error(\"body must be AST_Statement\");\n        if (is_function(this.body)) throw new Error(\"body cannot be AST_Function\");\n    },\n}, AST_BlockScope);\n\nvar AST_LabeledStatement = DEFNODE(\"LabeledStatement\", \"label\", {\n    $documentation: \"Statement with a label\",\n    $propdoc: {\n        label: \"[AST_Label] a label definition\"\n    },\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            node.label.walk(visitor);\n            node.body.walk(visitor);\n        });\n    },\n    clone: function(deep) {\n        var node = this._clone(deep);\n        if (deep) {\n            var label = node.label;\n            var def = this.label;\n            node.walk(new TreeWalker(function(node) {\n                if (node instanceof AST_LoopControl) {\n                    if (!node.label || node.label.thedef !== def) return;\n                    node.label.thedef = label;\n                    label.references.push(node);\n                    return true;\n                }\n                if (node instanceof AST_Scope) return true;\n            }));\n        }\n        return node;\n    },\n    _validate: function() {\n        if (!(this.label instanceof AST_Label)) throw new Error(\"label must be AST_Label\");\n    },\n}, AST_StatementWithBody);\n\nvar AST_IterationStatement = DEFNODE(\"IterationStatement\", null, {\n    $documentation: \"Internal class.  All loops inherit from it.\"\n}, AST_StatementWithBody);\n\nvar AST_DWLoop = DEFNODE(\"DWLoop\", \"condition\", {\n    $documentation: \"Base class for do/while statements\",\n    $propdoc: {\n        condition: \"[AST_Node] the loop condition.  Should not be instanceof AST_Statement\"\n    },\n    _validate: function() {\n        must_be_expression(this, \"condition\");\n    },\n}, AST_IterationStatement);\n\nvar AST_Do = DEFNODE(\"Do\", null, {\n    $documentation: \"A `do` statement\",\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            node.body.walk(visitor);\n            node.condition.walk(visitor);\n        });\n    }\n}, AST_DWLoop);\n\nvar AST_While = DEFNODE(\"While\", null, {\n    $documentation: \"A `while` statement\",\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            node.condition.walk(visitor);\n            node.body.walk(visitor);\n        });\n    }\n}, AST_DWLoop);\n\nvar AST_For = DEFNODE(\"For\", \"init condition step\", {\n    $documentation: \"A `for` statement\",\n    $propdoc: {\n        init: \"[AST_Node?] the `for` initialization code, or null if empty\",\n        condition: \"[AST_Node?] the `for` termination clause, or null if empty\",\n        step: \"[AST_Node?] the `for` update clause, or null if empty\"\n    },\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            if (node.init) node.init.walk(visitor);\n            if (node.condition) node.condition.walk(visitor);\n            if (node.step) node.step.walk(visitor);\n            node.body.walk(visitor);\n        });\n    },\n    _validate: function() {\n        if (this.init != null) {\n            if (!(this.init instanceof AST_Node)) throw new Error(\"init must be AST_Node\");\n            if (this.init instanceof AST_Statement\n                && !(this.init instanceof AST_Definitions || is_function(this.init))) {\n                throw new Error(\"init cannot be AST_Statement\");\n            }\n        }\n        if (this.condition != null) must_be_expression(this, \"condition\");\n        if (this.step != null) must_be_expression(this, \"step\");\n    },\n}, AST_IterationStatement);\n\nvar AST_ForIn = DEFNODE(\"ForIn\", \"init object\", {\n    $documentation: \"A `for ... in` statement\",\n    $propdoc: {\n        init: \"[AST_Node] the `for/in` initialization code\",\n        object: \"[AST_Node] the object that we're looping through\"\n    },\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            node.init.walk(visitor);\n            node.object.walk(visitor);\n            node.body.walk(visitor);\n        });\n    },\n    _validate: function() {\n        if (this.init instanceof AST_Definitions) {\n            if (this.init.definitions.length != 1) throw new Error(\"init must have single declaration\");\n        } else {\n            validate_destructured(this.init, function(node) {\n                if (!(node instanceof AST_PropAccess || node instanceof AST_SymbolRef)) {\n                    throw new Error(\"init must be assignable: \" + node.TYPE);\n                }\n            });\n        }\n        must_be_expression(this, \"object\");\n    },\n}, AST_IterationStatement);\n\nvar AST_With = DEFNODE(\"With\", \"expression\", {\n    $documentation: \"A `with` statement\",\n    $propdoc: {\n        expression: \"[AST_Node] the `with` expression\"\n    },\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            node.expression.walk(visitor);\n            node.body.walk(visitor);\n        });\n    },\n    _validate: function() {\n        must_be_expression(this, \"expression\");\n    },\n}, AST_StatementWithBody);\n\n/* -----[ scope and functions ]----- */\n\nvar AST_Scope = DEFNODE(\"Scope\", \"uses_eval uses_with\", {\n    $documentation: \"Base class for all statements introducing a lexical scope\",\n    $propdoc: {\n        uses_eval: \"[boolean/S] tells whether this scope contains a direct call to the global `eval`\",\n        uses_with: \"[boolean/S] tells whether this scope uses the `with` statement\",\n    },\n    pinned: function() {\n        return this.uses_eval || this.uses_with;\n    },\n    resolve: return_this,\n}, AST_Block);\n\nvar AST_Toplevel = DEFNODE(\"Toplevel\", \"globals\", {\n    $documentation: \"The toplevel scope\",\n    $propdoc: {\n        globals: \"[Object/S] a map of name -> SymbolDef for all undeclared names\",\n    },\n    wrap: function(name) {\n        var body = this.body;\n        return parse([\n            \"(function(exports){'$ORIG';})(typeof \",\n            name,\n            \"=='undefined'?(\",\n            name,\n            \"={}):\",\n            name,\n            \");\"\n        ].join(\"\"), {\n            filename: \"wrap=\" + JSON.stringify(name)\n        }).transform(new TreeTransformer(function(node) {\n            if (node instanceof AST_Directive && node.value == \"$ORIG\") {\n                return List.splice(body);\n            }\n        }));\n    },\n    enclose: function(args_values) {\n        if (typeof args_values != \"string\") args_values = \"\";\n        var index = args_values.indexOf(\":\");\n        if (index < 0) index = args_values.length;\n        var body = this.body;\n        return parse([\n            \"(function(\",\n            args_values.slice(0, index),\n            '){\"$ORIG\"})(',\n            args_values.slice(index + 1),\n            \")\"\n        ].join(\"\"), {\n            filename: \"enclose=\" + JSON.stringify(args_values)\n        }).transform(new TreeTransformer(function(node) {\n            if (node instanceof AST_Directive && node.value == \"$ORIG\") {\n                return List.splice(body);\n            }\n        }));\n    }\n}, AST_Scope);\n\nvar AST_Lambda = DEFNODE(\"Lambda\", \"argnames length_read uses_arguments\", {\n    $documentation: \"Base class for functions\",\n    $propdoc: {\n        argnames: \"[(AST_Destructured|AST_SymbolFunarg)*] array of function arguments and/or destructured literals\",\n        uses_arguments: \"[boolean/S] tells whether this function accesses the arguments array\",\n    },\n    each_argname: function(visit) {\n        var tw = new TreeWalker(function(node) {\n            if (node instanceof AST_DestructuredKeyVal) {\n                node.value.walk(tw);\n                return true;\n            }\n            if (node instanceof AST_SymbolFunarg) visit(node);\n        });\n        this.argnames.forEach(function(argname) {\n            argname.walk(tw);\n        });\n    },\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            if (node.name) node.name.walk(visitor);\n            node.argnames.forEach(function(argname) {\n                argname.walk(visitor);\n            });\n            walk_body(node, visitor);\n        });\n    },\n    _validate: function() {\n        this.argnames.forEach(function(node) {\n            validate_destructured(node, function(node) {\n                if (!(node instanceof AST_SymbolFunarg)) throw new Error(\"argnames must be AST_SymbolFunarg[]\");\n            }, true);\n        });\n    },\n}, AST_Scope);\n\nvar AST_Accessor = DEFNODE(\"Accessor\", null, {\n    $documentation: \"A getter/setter function\",\n    _validate: function() {\n        if (this.name != null) throw new Error(\"name must be null\");\n    },\n}, AST_Lambda);\n\nfunction is_function(node) {\n    return node instanceof AST_Arrow || node instanceof AST_AsyncFunction || node instanceof AST_Function;\n}\n\nvar AST_Arrow = DEFNODE(\"Arrow\", \"inlined value\", {\n    $documentation: \"An arrow function expression\",\n    $propdoc: {\n        value: \"[AST_Node?] simple return expression, or null if using function body.\",\n    },\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            node.argnames.forEach(function(argname) {\n                argname.walk(visitor);\n            });\n            if (node.value) {\n                node.value.walk(visitor);\n            } else {\n                walk_body(node, visitor);\n            }\n        });\n    },\n    _validate: function() {\n        if (this.name != null) throw new Error(\"name must be null\");\n        if (this.uses_arguments) throw new Error(\"uses_arguments must be false\");\n        if (this.value != null) {\n            must_be_expression(this, \"value\");\n            if (this.body.length) throw new Error(\"body must be empty if value exists\");\n        }\n    },\n}, AST_Lambda);\n\nfunction is_async(node) {\n    return node instanceof AST_AsyncDefun || node instanceof AST_AsyncFunction;\n}\n\nvar AST_AsyncFunction = DEFNODE(\"AsyncFunction\", \"inlined name\", {\n    $documentation: \"An asynchronous function expression\",\n    $propdoc: {\n        name: \"[AST_SymbolLambda?] the name of this function\",\n    },\n    _validate: function() {\n        if (this.name != null) {\n            if (!(this.name instanceof AST_SymbolLambda)) throw new Error(\"name must be AST_SymbolLambda\");\n        }\n    },\n}, AST_Lambda);\n\nvar AST_Function = DEFNODE(\"Function\", \"inlined name\", {\n    $documentation: \"A function expression\",\n    $propdoc: {\n        name: \"[AST_SymbolLambda?] the name of this function\",\n    },\n    _validate: function() {\n        if (this.name != null) {\n            if (!(this.name instanceof AST_SymbolLambda)) throw new Error(\"name must be AST_SymbolLambda\");\n        }\n    },\n}, AST_Lambda);\n\nfunction is_defun(node) {\n    return node instanceof AST_AsyncDefun || node instanceof AST_Defun;\n}\n\nvar AST_AsyncDefun = DEFNODE(\"AsyncDefun\", \"inlined name\", {\n    $documentation: \"An asynchronous function definition\",\n    $propdoc: {\n        name: \"[AST_SymbolDefun] the name of this function\",\n    },\n    _validate: function() {\n        if (!(this.name instanceof AST_SymbolDefun)) throw new Error(\"name must be AST_SymbolDefun\");\n    },\n}, AST_Lambda);\n\nvar AST_Defun = DEFNODE(\"Defun\", \"inlined name\", {\n    $documentation: \"A function definition\",\n    $propdoc: {\n        name: \"[AST_SymbolDefun] the name of this function\",\n    },\n    _validate: function() {\n        if (!(this.name instanceof AST_SymbolDefun)) throw new Error(\"name must be AST_SymbolDefun\");\n    },\n}, AST_Lambda);\n\n/* -----[ JUMPS ]----- */\n\nvar AST_Jump = DEFNODE(\"Jump\", null, {\n    $documentation: \"Base class for “jumps” (for now that's `return`, `throw`, `break` and `continue`)\"\n}, AST_Statement);\n\nvar AST_Exit = DEFNODE(\"Exit\", \"value\", {\n    $documentation: \"Base class for “exits” (`return` and `throw`)\",\n    $propdoc: {\n        value: \"[AST_Node?] the value returned or thrown by this statement; could be null for AST_Return\"\n    },\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            if (node.value) node.value.walk(visitor);\n        });\n    }\n}, AST_Jump);\n\nvar AST_Return = DEFNODE(\"Return\", null, {\n    $documentation: \"A `return` statement\",\n    _validate: function() {\n        if (this.value != null) must_be_expression(this, \"value\");\n    },\n}, AST_Exit);\n\nvar AST_Throw = DEFNODE(\"Throw\", null, {\n    $documentation: \"A `throw` statement\",\n    _validate: function() {\n        must_be_expression(this, \"value\");\n    },\n}, AST_Exit);\n\nvar AST_LoopControl = DEFNODE(\"LoopControl\", \"label\", {\n    $documentation: \"Base class for loop control statements (`break` and `continue`)\",\n    $propdoc: {\n        label: \"[AST_LabelRef?] the label, or null if none\",\n    },\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            if (node.label) node.label.walk(visitor);\n        });\n    },\n    _validate: function() {\n        if (this.label != null) {\n            if (!(this.label instanceof AST_LabelRef)) throw new Error(\"label must be AST_LabelRef\");\n        }\n    },\n}, AST_Jump);\n\nvar AST_Break = DEFNODE(\"Break\", null, {\n    $documentation: \"A `break` statement\"\n}, AST_LoopControl);\n\nvar AST_Continue = DEFNODE(\"Continue\", null, {\n    $documentation: \"A `continue` statement\"\n}, AST_LoopControl);\n\n/* -----[ IF ]----- */\n\nvar AST_If = DEFNODE(\"If\", \"condition alternative\", {\n    $documentation: \"A `if` statement\",\n    $propdoc: {\n        condition: \"[AST_Node] the `if` condition\",\n        alternative: \"[AST_Statement?] the `else` part, or null if not present\"\n    },\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            node.condition.walk(visitor);\n            node.body.walk(visitor);\n            if (node.alternative) node.alternative.walk(visitor);\n        });\n    },\n    _validate: function() {\n        must_be_expression(this, \"condition\");\n        if (this.alternative != null) {\n            if (!(this.alternative instanceof AST_Statement)) throw new Error(\"alternative must be AST_Statement\");\n            if (is_function(this.alternative)) throw new error(\"alternative cannot be AST_Function\");\n        }\n    },\n}, AST_StatementWithBody);\n\n/* -----[ SWITCH ]----- */\n\nvar AST_Switch = DEFNODE(\"Switch\", \"expression\", {\n    $documentation: \"A `switch` statement\",\n    $propdoc: {\n        expression: \"[AST_Node] the `switch` “discriminant”\"\n    },\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            node.expression.walk(visitor);\n            walk_body(node, visitor);\n        });\n    },\n    _validate: function() {\n        must_be_expression(this, \"expression\");\n        this.body.forEach(function(node) {\n            if (!(node instanceof AST_SwitchBranch)) throw new Error(\"body must be AST_SwitchBranch[]\");\n        });\n    },\n}, AST_Block);\n\nvar AST_SwitchBranch = DEFNODE(\"SwitchBranch\", null, {\n    $documentation: \"Base class for `switch` branches\",\n}, AST_Block);\n\nvar AST_Default = DEFNODE(\"Default\", null, {\n    $documentation: \"A `default` switch branch\",\n}, AST_SwitchBranch);\n\nvar AST_Case = DEFNODE(\"Case\", \"expression\", {\n    $documentation: \"A `case` switch branch\",\n    $propdoc: {\n        expression: \"[AST_Node] the `case` expression\"\n    },\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            node.expression.walk(visitor);\n            walk_body(node, visitor);\n        });\n    },\n    _validate: function() {\n        must_be_expression(this, \"expression\");\n    },\n}, AST_SwitchBranch);\n\n/* -----[ EXCEPTIONS ]----- */\n\nvar AST_Try = DEFNODE(\"Try\", \"bcatch bfinally\", {\n    $documentation: \"A `try` statement\",\n    $propdoc: {\n        bcatch: \"[AST_Catch?] the catch block, or null if not present\",\n        bfinally: \"[AST_Finally?] the finally block, or null if not present\"\n    },\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            walk_body(node, visitor);\n            if (node.bcatch) node.bcatch.walk(visitor);\n            if (node.bfinally) node.bfinally.walk(visitor);\n        });\n    },\n    _validate: function() {\n        if (this.bcatch != null) {\n            if (!(this.bcatch instanceof AST_Catch)) throw new Error(\"bcatch must be AST_Catch\");\n        }\n        if (this.bfinally != null) {\n            if (!(this.bfinally instanceof AST_Finally)) throw new Error(\"bfinally must be AST_Finally\");\n        }\n    },\n}, AST_Block);\n\nvar AST_Catch = DEFNODE(\"Catch\", \"argname\", {\n    $documentation: \"A `catch` node; only makes sense as part of a `try` statement\",\n    $propdoc: {\n        argname: \"[(AST_Destructured|AST_SymbolCatch)?] symbol for the exception, or null if not present\",\n    },\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            if (node.argname) node.argname.walk(visitor);\n            walk_body(node, visitor);\n        });\n    },\n    _validate: function() {\n        if (this.argname != null) validate_destructured(this.argname, function(node) {\n            if (!(node instanceof AST_SymbolCatch)) throw new Error(\"argname must be AST_SymbolCatch\");\n        });\n    },\n}, AST_Block);\n\nvar AST_Finally = DEFNODE(\"Finally\", null, {\n    $documentation: \"A `finally` node; only makes sense as part of a `try` statement\"\n}, AST_Block);\n\n/* -----[ VAR ]----- */\n\nvar AST_Definitions = DEFNODE(\"Definitions\", \"definitions\", {\n    $documentation: \"Base class for `var` nodes (variable declarations/initializations)\",\n    $propdoc: {\n        definitions: \"[AST_VarDef*] array of variable definitions\"\n    },\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            node.definitions.forEach(function(defn) {\n                defn.walk(visitor);\n            });\n        });\n    },\n    _validate: function() {\n        if (this.definitions.length < 1) throw new Error(\"must have at least one definition\");\n    },\n}, AST_Statement);\n\nvar AST_Const = DEFNODE(\"Const\", null, {\n    $documentation: \"A `const` statement\",\n    _validate: function() {\n        this.definitions.forEach(function(node) {\n            if (!(node instanceof AST_VarDef)) throw new Error(\"definitions must be AST_VarDef[]\");\n            validate_destructured(node.name, function(node) {\n                if (!(node instanceof AST_SymbolConst)) throw new Error(\"name must be AST_SymbolConst\");\n            });\n        });\n    },\n}, AST_Definitions);\n\nvar AST_Let = DEFNODE(\"Let\", null, {\n    $documentation: \"A `let` statement\",\n    _validate: function() {\n        this.definitions.forEach(function(node) {\n            if (!(node instanceof AST_VarDef)) throw new Error(\"definitions must be AST_VarDef[]\");\n            validate_destructured(node.name, function(node) {\n                if (!(node instanceof AST_SymbolLet)) throw new Error(\"name must be AST_SymbolLet\");\n            });\n        });\n    },\n}, AST_Definitions);\n\nvar AST_Var = DEFNODE(\"Var\", null, {\n    $documentation: \"A `var` statement\",\n    _validate: function() {\n        this.definitions.forEach(function(node) {\n            if (!(node instanceof AST_VarDef)) throw new Error(\"definitions must be AST_VarDef[]\");\n            validate_destructured(node.name, function(node) {\n                if (!(node instanceof AST_SymbolVar)) throw new Error(\"name must be AST_SymbolVar\");\n            });\n        });\n    },\n}, AST_Definitions);\n\nvar AST_VarDef = DEFNODE(\"VarDef\", \"name value\", {\n    $documentation: \"A variable declaration; only appears in a AST_Definitions node\",\n    $propdoc: {\n        name: \"[AST_Destructured|AST_SymbolVar] name of the variable\",\n        value: \"[AST_Node?] initializer, or null of there's no initializer\",\n    },\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            node.name.walk(visitor);\n            if (node.value) node.value.walk(visitor);\n        });\n    },\n    _validate: function() {\n        if (this.value != null) must_be_expression(this, \"value\");\n    },\n});\n\n/* -----[ OTHER ]----- */\n\nvar AST_DefaultValue = DEFNODE(\"DefaultValue\", \"name value\", {\n    $documentation: \"A default value declaration\",\n    $propdoc: {\n        name: \"[AST_Destructured|AST_SymbolDeclaration] name of the variable\",\n        value: \"[AST_Node] value to assign if variable is `undefined`\",\n    },\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            node.name.walk(visitor);\n            node.value.walk(visitor);\n        });\n    },\n    _validate: function() {\n        must_be_expression(this, \"value\");\n    },\n});\n\nfunction must_be_expressions(node, prop, allow_spread, allow_hole) {\n    node[prop].forEach(function(node) {\n        validate_expression(node, prop, true, allow_spread, allow_hole);\n    });\n}\n\nvar AST_Call = DEFNODE(\"Call\", \"expression args pure\", {\n    $documentation: \"A function call expression\",\n    $propdoc: {\n        expression: \"[AST_Node] expression to invoke as function\",\n        args: \"[AST_Node*] array of arguments\"\n    },\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            node.expression.walk(visitor);\n            node.args.forEach(function(arg) {\n                arg.walk(visitor);\n            });\n        });\n    },\n    _validate: function() {\n        must_be_expression(this, \"expression\");\n        must_be_expressions(this, \"args\", true);\n    },\n});\n\nvar AST_New = DEFNODE(\"New\", null, {\n    $documentation: \"An object instantiation.  Derives from a function call since it has exactly the same properties\"\n}, AST_Call);\n\nvar AST_Sequence = DEFNODE(\"Sequence\", \"expressions\", {\n    $documentation: \"A sequence expression (comma-separated expressions)\",\n    $propdoc: {\n        expressions: \"[AST_Node*] array of expressions (at least two)\"\n    },\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            node.expressions.forEach(function(expr) {\n                expr.walk(visitor);\n            });\n        });\n    },\n    _validate: function() {\n        if (this.expressions.length < 2) throw new Error(\"expressions must contain multiple elements\");\n        must_be_expressions(this, \"expressions\");\n    },\n});\n\nvar AST_PropAccess = DEFNODE(\"PropAccess\", \"expression property\", {\n    $documentation: \"Base class for property access expressions, i.e. `a.foo` or `a[\\\"foo\\\"]`\",\n    $propdoc: {\n        expression: \"[AST_Node] the “container” expression\",\n        property: \"[AST_Node|string] the property to access.  For AST_Dot this is always a plain string, while for AST_Sub it's an arbitrary AST_Node\"\n    },\n    getProperty: function() {\n        var p = this.property;\n        if (p instanceof AST_Constant) {\n            return p.value;\n        }\n        if (p instanceof AST_UnaryPrefix\n            && p.operator == \"void\"\n            && p.expression instanceof AST_Constant) {\n            return;\n        }\n        return p;\n    },\n    _validate: function() {\n        must_be_expression(this, \"expression\");\n    },\n});\n\nvar AST_Dot = DEFNODE(\"Dot\", null, {\n    $documentation: \"A dotted property access expression\",\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            node.expression.walk(visitor);\n        });\n    },\n    _validate: function() {\n        if (typeof this.property != \"string\") throw new Error(\"property must be string\");\n    },\n}, AST_PropAccess);\n\nvar AST_Sub = DEFNODE(\"Sub\", null, {\n    $documentation: \"Index-style property access, i.e. `a[\\\"foo\\\"]`\",\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            node.expression.walk(visitor);\n            node.property.walk(visitor);\n        });\n    },\n    _validate: function() {\n        must_be_expression(this, \"property\");\n    },\n}, AST_PropAccess);\n\nvar AST_Spread = DEFNODE(\"Spread\", \"expression\", {\n    $documentation: \"Spread expression in array/object literals or function calls\",\n    $propdoc: {\n        expression: \"[AST_Node] expression to be expanded\",\n    },\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            node.expression.walk(visitor);\n        });\n    },\n    _validate: function() {\n        must_be_expression(this, \"expression\");\n    },\n});\n\nvar AST_Unary = DEFNODE(\"Unary\", \"operator expression\", {\n    $documentation: \"Base class for unary expressions\",\n    $propdoc: {\n        operator: \"[string] the operator\",\n        expression: \"[AST_Node] expression that this unary operator applies to\"\n    },\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            node.expression.walk(visitor);\n        });\n    },\n    _validate: function() {\n        if (typeof this.operator != \"string\") throw new Error(\"operator must be string\");\n        must_be_expression(this, \"expression\");\n    },\n});\n\nvar AST_UnaryPrefix = DEFNODE(\"UnaryPrefix\", null, {\n    $documentation: \"Unary prefix expression, i.e. `typeof i` or `++i`\"\n}, AST_Unary);\n\nvar AST_UnaryPostfix = DEFNODE(\"UnaryPostfix\", null, {\n    $documentation: \"Unary postfix expression, i.e. `i++`\"\n}, AST_Unary);\n\nvar AST_Binary = DEFNODE(\"Binary\", \"operator left right\", {\n    $documentation: \"Binary expression, i.e. `a + b`\",\n    $propdoc: {\n        left: \"[AST_Node] left-hand side expression\",\n        operator: \"[string] the operator\",\n        right: \"[AST_Node] right-hand side expression\"\n    },\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            node.left.walk(visitor);\n            node.right.walk(visitor);\n        });\n    },\n    _validate: function() {\n        if (!(this instanceof AST_Assign)) must_be_expression(this, \"left\");\n        if (typeof this.operator != \"string\") throw new Error(\"operator must be string\");\n        must_be_expression(this, \"right\");\n    },\n});\n\nvar AST_Conditional = DEFNODE(\"Conditional\", \"condition consequent alternative\", {\n    $documentation: \"Conditional expression using the ternary operator, i.e. `a ? b : c`\",\n    $propdoc: {\n        condition: \"[AST_Node]\",\n        consequent: \"[AST_Node]\",\n        alternative: \"[AST_Node]\"\n    },\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            node.condition.walk(visitor);\n            node.consequent.walk(visitor);\n            node.alternative.walk(visitor);\n        });\n    },\n    _validate: function() {\n        must_be_expression(this, \"condition\");\n        must_be_expression(this, \"consequent\");\n        must_be_expression(this, \"alternative\");\n    },\n});\n\nvar AST_Assign = DEFNODE(\"Assign\", null, {\n    $documentation: \"An assignment expression — `a = b + 5`\",\n    _validate: function() {\n        if (this.operator.indexOf(\"=\") < 0) throw new Error('operator must contain \"=\"');\n        if (this.left instanceof AST_Destructured) {\n            if (this.operator != \"=\") throw new Error(\"invalid destructuring operator: \" + this.operator);\n            validate_destructured(this.left, function(node) {\n                if (!(node instanceof AST_PropAccess || node instanceof AST_SymbolRef)) {\n                    throw new Error(\"left must be assignable: \" + node.TYPE);\n                }\n            });\n        }\n    },\n}, AST_Binary);\n\nvar AST_Await = DEFNODE(\"Await\", \"expression\", {\n    $documentation: \"An await expression\",\n    $propdoc: {\n        expression: \"[AST_Node] expression with Promise to resolve on\",\n    },\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            node.expression.walk(visitor);\n        });\n    },\n    _validate: function() {\n        must_be_expression(this, \"expression\");\n    },\n});\n\n/* -----[ LITERALS ]----- */\n\nvar AST_Array = DEFNODE(\"Array\", \"elements\", {\n    $documentation: \"An array literal\",\n    $propdoc: {\n        elements: \"[AST_Node*] array of elements\"\n    },\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            node.elements.forEach(function(element) {\n                element.walk(visitor);\n            });\n        });\n    },\n    _validate: function() {\n        must_be_expressions(this, \"elements\", true, true);\n    },\n});\n\nvar AST_Destructured = DEFNODE(\"Destructured\", null, {\n    $documentation: \"Base class for destructured literal\",\n});\n\nfunction validate_destructured(node, check, allow_default) {\n    if (node instanceof AST_DefaultValue && allow_default) return validate_destructured(node.name, check);\n    if (node instanceof AST_DestructuredArray) return node.elements.forEach(function(node) {\n        if (!(node instanceof AST_Hole)) validate_destructured(node, check, true);\n    });\n    if (node instanceof AST_DestructuredObject) return node.properties.forEach(function(prop) {\n        validate_destructured(prop.value, check, true);\n    });\n    check(node);\n}\n\nvar AST_DestructuredArray = DEFNODE(\"DestructuredArray\", \"elements\", {\n    $documentation: \"A destructured array literal\",\n    $propdoc: {\n        elements: \"[AST_Node*] array of elements\",\n    },\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            node.elements.forEach(function(element) {\n                element.walk(visitor);\n            });\n        });\n    },\n}, AST_Destructured);\n\nvar AST_DestructuredKeyVal = DEFNODE(\"DestructuredKeyVal\", \"key value\", {\n    $documentation: \"A key: value destructured property\",\n    $propdoc: {\n        key: \"[string|AST_Node] property name.  For computed property this is an AST_Node.\",\n        value: \"[AST_Node] property value\",\n    },\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            if (node.key instanceof AST_Node) node.key.walk(visitor);\n            node.value.walk(visitor);\n        });\n    },\n    _validate: function() {\n        if (typeof this.key != \"string\") {\n            if (!(this.key instanceof AST_Node)) throw new Error(\"key must be string or AST_Node\");\n            must_be_expression(this, \"key\");\n        }\n        if (!(this.value instanceof AST_Node)) throw new Error(\"value must be AST_Node\");\n    },\n});\n\nvar AST_DestructuredObject = DEFNODE(\"DestructuredObject\", \"properties\", {\n    $documentation: \"A destructured object literal\",\n    $propdoc: {\n        properties: \"[AST_DestructuredKeyVal*] array of properties\",\n    },\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            node.properties.forEach(function(prop) {\n                prop.walk(visitor);\n            });\n        });\n    },\n    _validate: function() {\n        this.properties.forEach(function(node) {\n            if (!(node instanceof AST_DestructuredKeyVal)) throw new Error(\"properties must be AST_DestructuredKeyVal[]\");\n        });\n    },\n}, AST_Destructured);\n\nvar AST_Object = DEFNODE(\"Object\", \"properties\", {\n    $documentation: \"An object literal\",\n    $propdoc: {\n        properties: \"[(AST_ObjectProperty|AST_Spread)*] array of properties\"\n    },\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            node.properties.forEach(function(prop) {\n                prop.walk(visitor);\n            });\n        });\n    },\n    _validate: function() {\n        this.properties.forEach(function(node) {\n            if (!(node instanceof AST_ObjectProperty || node instanceof AST_Spread)) {\n                throw new Error(\"properties must contain AST_ObjectProperty and/or AST_Spread only\");\n            }\n        });\n    },\n});\n\nvar AST_ObjectProperty = DEFNODE(\"ObjectProperty\", \"key value\", {\n    $documentation: \"Base class for literal object properties\",\n    $propdoc: {\n        key: \"[string|AST_Node] property name.  For computed property this is an AST_Node.\",\n        value: \"[AST_Node] property value.  For getters and setters this is an AST_Accessor.\",\n    },\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            if (node.key instanceof AST_Node) node.key.walk(visitor);\n            node.value.walk(visitor);\n        });\n    },\n    _validate: function() {\n        if (typeof this.key != \"string\") {\n            if (!(this.key instanceof AST_Node)) throw new Error(\"key must be string or AST_Node\");\n            must_be_expression(this, \"key\");\n        }\n        if (!(this.value instanceof AST_Node)) throw new Error(\"value must be AST_Node\");\n    },\n});\n\nvar AST_ObjectKeyVal = DEFNODE(\"ObjectKeyVal\", null, {\n    $documentation: \"A key: value object property\",\n    _validate: function() {\n        must_be_expression(this, \"value\");\n    },\n}, AST_ObjectProperty);\n\nvar AST_ObjectSetter = DEFNODE(\"ObjectSetter\", null, {\n    $documentation: \"An object setter property\",\n    _validate: function() {\n        if (!(this.value instanceof AST_Accessor)) throw new Error(\"value must be AST_Accessor\");\n    },\n}, AST_ObjectProperty);\n\nvar AST_ObjectGetter = DEFNODE(\"ObjectGetter\", null, {\n    $documentation: \"An object getter property\",\n    _validate: function() {\n        if (!(this.value instanceof AST_Accessor)) throw new Error(\"value must be AST_Accessor\");\n    },\n}, AST_ObjectProperty);\n\nvar AST_Symbol = DEFNODE(\"Symbol\", \"scope name thedef\", {\n    $documentation: \"Base class for all symbols\",\n    $propdoc: {\n        name: \"[string] name of this symbol\",\n        scope: \"[AST_Scope/S] the current scope (not necessarily the definition scope)\",\n        thedef: \"[SymbolDef/S] the definition of this symbol\"\n    },\n    _validate: function() {\n        if (typeof this.name != \"string\") throw new Error(\"name must be string\");\n    },\n});\n\nvar AST_SymbolDeclaration = DEFNODE(\"SymbolDeclaration\", \"init\", {\n    $documentation: \"A declaration symbol (symbol in var, function name or argument, symbol in catch)\",\n}, AST_Symbol);\n\nvar AST_SymbolConst = DEFNODE(\"SymbolConst\", null, {\n    $documentation: \"Symbol defining a constant\",\n}, AST_SymbolDeclaration);\n\nvar AST_SymbolLet = DEFNODE(\"SymbolLet\", null, {\n    $documentation: \"Symbol defining a lexical-scoped variable\",\n}, AST_SymbolDeclaration);\n\nvar AST_SymbolVar = DEFNODE(\"SymbolVar\", null, {\n    $documentation: \"Symbol defining a variable\",\n}, AST_SymbolDeclaration);\n\nvar AST_SymbolFunarg = DEFNODE(\"SymbolFunarg\", null, {\n    $documentation: \"Symbol naming a function argument\",\n}, AST_SymbolVar);\n\nvar AST_SymbolDefun = DEFNODE(\"SymbolDefun\", null, {\n    $documentation: \"Symbol defining a function\",\n}, AST_SymbolDeclaration);\n\nvar AST_SymbolLambda = DEFNODE(\"SymbolLambda\", null, {\n    $documentation: \"Symbol naming a function expression\",\n}, AST_SymbolDeclaration);\n\nvar AST_SymbolCatch = DEFNODE(\"SymbolCatch\", null, {\n    $documentation: \"Symbol naming the exception in catch\",\n}, AST_SymbolDeclaration);\n\nvar AST_Label = DEFNODE(\"Label\", \"references\", {\n    $documentation: \"Symbol naming a label (declaration)\",\n    $propdoc: {\n        references: \"[AST_LoopControl*] a list of nodes referring to this label\"\n    },\n    initialize: function() {\n        this.references = [];\n        this.thedef = this;\n    }\n}, AST_Symbol);\n\nvar AST_SymbolRef = DEFNODE(\"SymbolRef\", \"fixed in_arg\", {\n    $documentation: \"Reference to some symbol (not definition/declaration)\",\n}, AST_Symbol);\n\nvar AST_LabelRef = DEFNODE(\"LabelRef\", null, {\n    $documentation: \"Reference to a label symbol\",\n}, AST_Symbol);\n\nvar AST_This = DEFNODE(\"This\", null, {\n    $documentation: \"The `this` symbol\",\n    _validate: function() {\n        if (this.name !== \"this\") throw new Error('name must be \"this\"');\n    },\n}, AST_Symbol);\n\nvar AST_Constant = DEFNODE(\"Constant\", null, {\n    $documentation: \"Base class for all constants\",\n});\n\nvar AST_String = DEFNODE(\"String\", \"value quote\", {\n    $documentation: \"A string literal\",\n    $propdoc: {\n        value: \"[string] the contents of this string\",\n        quote: \"[string] the original quote character\"\n    },\n    _validate: function() {\n        if (typeof this.value != \"string\") throw new Error(\"value must be string\");\n    },\n}, AST_Constant);\n\nvar AST_Number = DEFNODE(\"Number\", \"value\", {\n    $documentation: \"A number literal\",\n    $propdoc: {\n        value: \"[number] the numeric value\",\n    },\n    _validate: function() {\n        if (typeof this.value != \"number\") throw new Error(\"value must be number\");\n    },\n}, AST_Constant);\n\nvar AST_RegExp = DEFNODE(\"RegExp\", \"value\", {\n    $documentation: \"A regexp literal\",\n    $propdoc: {\n        value: \"[RegExp] the actual regexp\"\n    },\n    _validate: function() {\n        if (!(this.value instanceof RegExp)) throw new Error(\"value must be RegExp\");\n    },\n}, AST_Constant);\n\nvar AST_Atom = DEFNODE(\"Atom\", null, {\n    $documentation: \"Base class for atoms\",\n}, AST_Constant);\n\nvar AST_Null = DEFNODE(\"Null\", null, {\n    $documentation: \"The `null` atom\",\n    value: null\n}, AST_Atom);\n\nvar AST_NaN = DEFNODE(\"NaN\", null, {\n    $documentation: \"The impossible value\",\n    value: 0/0\n}, AST_Atom);\n\nvar AST_Undefined = DEFNODE(\"Undefined\", null, {\n    $documentation: \"The `undefined` value\",\n    value: function(){}()\n}, AST_Atom);\n\nvar AST_Hole = DEFNODE(\"Hole\", null, {\n    $documentation: \"A hole in an array\",\n    value: function(){}()\n}, AST_Atom);\n\nvar AST_Infinity = DEFNODE(\"Infinity\", null, {\n    $documentation: \"The `Infinity` value\",\n    value: 1/0\n}, AST_Atom);\n\nvar AST_Boolean = DEFNODE(\"Boolean\", null, {\n    $documentation: \"Base class for booleans\",\n}, AST_Atom);\n\nvar AST_False = DEFNODE(\"False\", null, {\n    $documentation: \"The `false` atom\",\n    value: false\n}, AST_Boolean);\n\nvar AST_True = DEFNODE(\"True\", null, {\n    $documentation: \"The `true` atom\",\n    value: true\n}, AST_Boolean);\n\n/* -----[ TreeWalker ]----- */\n\nfunction TreeWalker(callback) {\n    this.callback = callback;\n    this.directives = Object.create(null);\n    this.stack = [];\n}\nTreeWalker.prototype = {\n    visit: function(node, descend) {\n        this.push(node);\n        var done = this.callback(node, descend || noop);\n        if (!done && descend) descend();\n        this.pop();\n    },\n    parent: function(n) {\n        return this.stack[this.stack.length - 2 - (n || 0)];\n    },\n    push: function(node) {\n        if (node instanceof AST_Lambda) {\n            this.directives = Object.create(this.directives);\n        } else if (node instanceof AST_Directive && !this.directives[node.value]) {\n            this.directives[node.value] = node;\n        }\n        this.stack.push(node);\n    },\n    pop: function() {\n        if (this.stack.pop() instanceof AST_Lambda) {\n            this.directives = Object.getPrototypeOf(this.directives);\n        }\n    },\n    self: function() {\n        return this.stack[this.stack.length - 1];\n    },\n    find_parent: function(type) {\n        var stack = this.stack;\n        for (var i = stack.length; --i >= 0;) {\n            var x = stack[i];\n            if (x instanceof type) return x;\n        }\n    },\n    has_directive: function(type) {\n        var dir = this.directives[type];\n        if (dir) return dir;\n        var node = this.stack[this.stack.length - 1];\n        if (node instanceof AST_Scope) {\n            for (var i = 0; i < node.body.length; ++i) {\n                var st = node.body[i];\n                if (!(st instanceof AST_Directive)) break;\n                if (st.value == type) return st;\n            }\n        }\n    },\n    loopcontrol_target: function(node) {\n        var stack = this.stack;\n        if (node.label) for (var i = stack.length; --i >= 0;) {\n            var x = stack[i];\n            if (x instanceof AST_LabeledStatement && x.label.name == node.label.name)\n                return x.body;\n        } else for (var i = stack.length; --i >= 0;) {\n            var x = stack[i];\n            if (x instanceof AST_IterationStatement\n                || node instanceof AST_Break && x instanceof AST_Switch)\n                return x;\n        }\n    },\n    in_boolean_context: function() {\n        var self = this.self();\n        for (var i = 0, p; p = this.parent(i); i++) {\n            if (p instanceof AST_Conditional && p.condition === self\n                || p instanceof AST_DWLoop && p.condition === self\n                || p instanceof AST_For && p.condition === self\n                || p instanceof AST_If && p.condition === self\n                || p instanceof AST_Return && p.in_bool\n                || p instanceof AST_Sequence && p.tail_node() !== self\n                || p instanceof AST_SimpleStatement\n                || p instanceof AST_UnaryPrefix && p.operator == \"!\" && p.expression === self) {\n                return true;\n            }\n            if (p instanceof AST_Binary && (p.operator == \"&&\" || p.operator == \"||\")\n                || p instanceof AST_Conditional\n                || p.tail_node() === self) {\n                self = p;\n            } else if (p instanceof AST_Return) {\n                for (var call, fn = p; call = this.parent(++i); fn = call) {\n                    if (call.TYPE == \"Call\") {\n                        if (!(fn instanceof AST_Lambda) || fn.name) return false;\n                    } else if (fn instanceof AST_Lambda) {\n                        return false;\n                    }\n                }\n            } else {\n                return false;\n            }\n        }\n    }\n};\n","/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\n\"use strict\";\n\nfunction Compressor(options, false_by_default) {\n    if (!(this instanceof Compressor))\n        return new Compressor(options, false_by_default);\n    TreeTransformer.call(this, this.before, this.after);\n    this.options = defaults(options, {\n        arguments       : !false_by_default,\n        arrows          : !false_by_default,\n        assignments     : !false_by_default,\n        booleans        : !false_by_default,\n        collapse_vars   : !false_by_default,\n        comparisons     : !false_by_default,\n        conditionals    : !false_by_default,\n        dead_code       : !false_by_default,\n        default_values  : !false_by_default,\n        directives      : !false_by_default,\n        drop_console    : false,\n        drop_debugger   : !false_by_default,\n        evaluate        : !false_by_default,\n        expression      : false,\n        functions       : !false_by_default,\n        global_defs     : false,\n        hoist_funs      : false,\n        hoist_props     : !false_by_default,\n        hoist_vars      : false,\n        ie8             : false,\n        if_return       : !false_by_default,\n        inline          : !false_by_default,\n        join_vars       : !false_by_default,\n        keep_fargs      : false_by_default,\n        keep_fnames     : false,\n        keep_infinity   : false,\n        loops           : !false_by_default,\n        merge_vars      : !false_by_default,\n        negate_iife     : !false_by_default,\n        objects         : !false_by_default,\n        passes          : 1,\n        properties      : !false_by_default,\n        pure_getters    : !false_by_default && \"strict\",\n        pure_funcs      : null,\n        reduce_funcs    : !false_by_default,\n        reduce_vars     : !false_by_default,\n        sequences       : !false_by_default,\n        side_effects    : !false_by_default,\n        spread          : !false_by_default,\n        strings         : !false_by_default,\n        switches        : !false_by_default,\n        top_retain      : null,\n        toplevel        : !!(options && options[\"top_retain\"]),\n        typeofs         : !false_by_default,\n        unsafe          : false,\n        unsafe_comps    : false,\n        unsafe_Function : false,\n        unsafe_math     : false,\n        unsafe_proto    : false,\n        unsafe_regexp   : false,\n        unsafe_undefined: false,\n        unused          : !false_by_default,\n        varify          : !false_by_default,\n    }, true);\n    var evaluate = this.options[\"evaluate\"];\n    this.eval_threshold = /eager/.test(evaluate) ? 1 / 0 : +evaluate;\n    var global_defs = this.options[\"global_defs\"];\n    if (typeof global_defs == \"object\") for (var key in global_defs) {\n        if (/^@/.test(key) && HOP(global_defs, key)) {\n            global_defs[key.slice(1)] = parse(global_defs[key], {\n                expression: true\n            });\n        }\n    }\n    if (this.options[\"inline\"] === true) this.options[\"inline\"] = 3;\n    this.drop_fargs = this.options[\"keep_fargs\"] ? return_false : function(lambda, parent) {\n        if (lambda.length_read) return false;\n        var name = lambda.name;\n        if (!name) return parent && parent.TYPE == \"Call\" && parent.expression === lambda;\n        if (name.fixed_value() !== lambda) return false;\n        var def = name.definition();\n        if (def.direct_access) return false;\n        var escaped = def.escaped;\n        return escaped && escaped.depth != 1;\n    };\n    var pure_funcs = this.options[\"pure_funcs\"];\n    if (typeof pure_funcs == \"function\") {\n        this.pure_funcs = pure_funcs;\n    } else if (typeof pure_funcs == \"string\") {\n        this.pure_funcs = function(node) {\n            return pure_funcs !== node.expression.print_to_string();\n        };\n    } else if (Array.isArray(pure_funcs)) {\n        this.pure_funcs = function(node) {\n            return !member(node.expression.print_to_string(), pure_funcs);\n        };\n    } else {\n        this.pure_funcs = return_true;\n    }\n    var sequences = this.options[\"sequences\"];\n    this.sequences_limit = sequences == 1 ? 800 : sequences | 0;\n    var top_retain = this.options[\"top_retain\"];\n    if (top_retain instanceof RegExp) {\n        this.top_retain = function(def) {\n            return top_retain.test(def.name);\n        };\n    } else if (typeof top_retain == \"function\") {\n        this.top_retain = top_retain;\n    } else if (top_retain) {\n        if (typeof top_retain == \"string\") {\n            top_retain = top_retain.split(/,/);\n        }\n        this.top_retain = function(def) {\n            return member(def.name, top_retain);\n        };\n    }\n    var toplevel = this.options[\"toplevel\"];\n    this.toplevel = typeof toplevel == \"string\" ? {\n        funcs: /funcs/.test(toplevel),\n        vars: /vars/.test(toplevel)\n    } : {\n        funcs: toplevel,\n        vars: toplevel\n    };\n}\n\nCompressor.prototype = new TreeTransformer;\nmerge(Compressor.prototype, {\n    option: function(key) { return this.options[key] },\n    exposed: function(def) {\n        if (def.undeclared) return true;\n        if (!(def.global || def.scope.resolve() instanceof AST_Toplevel)) return false;\n        var toplevel = this.toplevel;\n        return !all(def.orig, function(sym) {\n            return toplevel[sym instanceof AST_SymbolDefun ? \"funcs\" : \"vars\"];\n        });\n    },\n    compress: function(node) {\n        node = node.resolve_defines(this);\n        if (this.option(\"expression\")) {\n            node.process_expression(true);\n        }\n        var passes = +this.options.passes || 1;\n        var min_count = 1 / 0;\n        var stopping = false;\n        var mangle = { ie8: this.option(\"ie8\") };\n        for (var pass = 0; pass < passes; pass++) {\n            node.figure_out_scope(mangle);\n            if (pass > 0 || this.option(\"reduce_vars\"))\n                node.reset_opt_flags(this);\n            node = node.transform(this);\n            if (passes > 1) {\n                var count = 0;\n                node.walk(new TreeWalker(function() {\n                    count++;\n                }));\n                AST_Node.info(\"pass {pass}: last_count: {min_count}, count: {count}\", {\n                    pass: pass,\n                    min_count: min_count,\n                    count: count,\n                });\n                if (count < min_count) {\n                    min_count = count;\n                    stopping = false;\n                } else if (stopping) {\n                    break;\n                } else {\n                    stopping = true;\n                }\n            }\n        }\n        if (this.option(\"expression\")) {\n            node.process_expression(false);\n        }\n        return node;\n    },\n    before: function(node, descend, in_list) {\n        if (node._squeezed) return node;\n        var is_scope = node instanceof AST_Scope;\n        if (is_scope) {\n            node.hoist_properties(this);\n            node.hoist_declarations(this);\n            node.process_boolean_returns(this);\n        }\n        // Before https://github.com/mishoo/UglifyJS/pull/1602 AST_Node.optimize()\n        // would call AST_Node.transform() if a different instance of AST_Node is\n        // produced after OPT().\n        // This corrupts TreeWalker.stack, which cause AST look-ups to malfunction.\n        // Migrate and defer all children's AST_Node.transform() to below, which\n        // will now happen after this parent AST_Node has been properly substituted\n        // thus gives a consistent AST snapshot.\n        descend(node, this);\n        // Existing code relies on how AST_Node.optimize() worked, and omitting the\n        // following replacement call would result in degraded efficiency of both\n        // output and performance.\n        descend(node, this);\n        var opt = node.optimize(this);\n        if (is_scope && opt === node && !this.has_directive(\"use asm\") && !opt.pinned()) {\n            opt.merge_variables(this);\n            opt.drop_unused(this);\n            descend(opt, this);\n        }\n        if (opt === node) opt._squeezed = true;\n        return opt;\n    }\n});\n\n(function(OPT) {\n    OPT(AST_Node, function(self, compressor) {\n        return self;\n    });\n\n    AST_Node.DEFMETHOD(\"equivalent_to\", function(node) {\n        return this.TYPE == node.TYPE && this.print_to_string() == node.print_to_string();\n    });\n\n    AST_Scope.DEFMETHOD(\"process_expression\", function(insert, transform) {\n        var self = this;\n        var tt = new TreeTransformer(function(node) {\n            if (insert && node instanceof AST_SimpleStatement) {\n                return make_node(AST_Return, node, {\n                    value: node.body\n                });\n            }\n            if (!insert && node instanceof AST_Return) {\n                return transform ? transform(node) : make_node(AST_SimpleStatement, node, {\n                    body: node.value || make_node(AST_UnaryPrefix, node, {\n                        operator: \"void\",\n                        expression: make_node(AST_Number, node, {\n                            value: 0\n                        })\n                    })\n                });\n            }\n            if (node instanceof AST_Lambda && node !== self) {\n                return node;\n            }\n            if (node instanceof AST_Block) {\n                var index = node.body.length - 1;\n                if (index >= 0) {\n                    node.body[index] = node.body[index].transform(tt);\n                }\n            } else if (node instanceof AST_If) {\n                node.body = node.body.transform(tt);\n                if (node.alternative) {\n                    node.alternative = node.alternative.transform(tt);\n                }\n            } else if (node instanceof AST_With) {\n                node.body = node.body.transform(tt);\n            }\n            return node;\n        });\n        self.transform(tt);\n    });\n\n    function read_property(obj, node) {\n        var key = node.getProperty();\n        if (key instanceof AST_Node) return;\n        var value;\n        if (obj instanceof AST_Array) {\n            var elements = obj.elements;\n            if (key == \"length\") return make_node_from_constant(elements.length, obj);\n            if (typeof key == \"number\" && key in elements) value = elements[key];\n        } else if (obj instanceof AST_Lambda) {\n            if (key == \"length\") {\n                obj.length_read = true;\n                return make_node_from_constant(obj.argnames.length, obj);\n            }\n        } else if (obj instanceof AST_Object) {\n            key = \"\" + key;\n            var props = obj.properties;\n            for (var i = props.length; --i >= 0;) {\n                var prop = props[i];\n                if (!(prop instanceof AST_ObjectKeyVal)) return;\n                if (!value && props[i].key === key) value = props[i].value;\n            }\n        }\n        return value instanceof AST_SymbolRef && value.fixed_value() || value;\n    }\n\n    function is_read_only_fn(value, name) {\n        if (value instanceof AST_Boolean) return native_fns.Boolean[name];\n        if (value instanceof AST_Number) return native_fns.Number[name];\n        if (value instanceof AST_String) return native_fns.String[name];\n        if (name == \"valueOf\") return false;\n        if (value instanceof AST_Array) return native_fns.Array[name];\n        if (value instanceof AST_Lambda) return native_fns.Function[name];\n        if (value instanceof AST_Object) return native_fns.Object[name];\n        if (value instanceof AST_RegExp) return native_fns.RegExp[name] && !value.value.global;\n    }\n\n    function is_modified(compressor, tw, node, value, level, immutable, recursive) {\n        var parent = tw.parent(level);\n        if (compressor.option(\"unsafe\") && parent instanceof AST_Dot && is_read_only_fn(value, parent.property)) {\n            return;\n        }\n        var lhs = is_lhs(node, parent);\n        if (lhs) return lhs;\n        if (parent instanceof AST_Array) return is_modified(compressor, tw, parent, parent, level + 1);\n        if (parent instanceof AST_Call) {\n            return !immutable\n                && parent.expression === node\n                && !parent.is_expr_pure(compressor)\n                && (!is_function(value) || !(parent instanceof AST_New) && value.contains_this());\n        }\n        if (parent instanceof AST_ForIn) return parent.init === node;\n        if (parent instanceof AST_ObjectKeyVal) {\n            if (parent.value !== node) return;\n            var obj = tw.parent(level + 1);\n            return is_modified(compressor, tw, obj, obj, level + 2);\n        }\n        if (parent instanceof AST_PropAccess) {\n            if (parent.expression !== node) return;\n            var prop = read_property(value, parent);\n            return (!immutable || recursive) && is_modified(compressor, tw, parent, prop, level + 1);\n        }\n    }\n\n    function is_arguments(def) {\n        return def.name == \"arguments\" && def.scope.uses_arguments;\n    }\n\n    function is_funarg(def) {\n        return def.orig[0] instanceof AST_SymbolFunarg || def.orig[1] instanceof AST_SymbolFunarg;\n    }\n\n    function cross_scope(def, sym) {\n        do {\n            if (def === sym) return false;\n            if (sym instanceof AST_Scope) return true;\n        } while (sym = sym.parent_scope);\n    }\n\n    function can_drop_symbol(ref, keep_lambda) {\n        var def = ref.definition();\n        if (ref.in_arg && is_funarg(def)) return false;\n        return all(def.orig, function(sym) {\n            return !(sym instanceof AST_SymbolConst || sym instanceof AST_SymbolLet\n                || keep_lambda && sym instanceof AST_SymbolLambda);\n        });\n    }\n\n    (function(def) {\n        def(AST_Node, noop);\n\n        function reset_def(tw, compressor, def) {\n            def.assignments = 0;\n            def.bool_fn = 0;\n            def.cross_loop = false;\n            def.direct_access = false;\n            def.escaped = [];\n            def.fixed = !def.const_redefs\n                && !def.scope.pinned()\n                && !compressor.exposed(def)\n                && !(is_function(def.init) && def.init !== def.scope)\n                && def.init;\n            if (is_defun(def.fixed) && !all(def.references, function(ref) {\n                var scope = ref.scope.resolve();\n                do {\n                    if (def.scope === scope) return true;\n                } while (is_function(scope) && (scope = scope.parent_scope.resolve()));\n            })) {\n                tw.defun_ids[def.id] = false;\n            }\n            def.recursive_refs = 0;\n            def.references = [];\n            def.should_replace = undefined;\n            def.single_use = undefined;\n        }\n\n        function reset_variables(tw, compressor, scope) {\n            scope.variables.each(function(def) {\n                reset_def(tw, compressor, def);\n                if (def.fixed === null) {\n                    def.safe_ids = tw.safe_ids;\n                    mark(tw, def);\n                } else if (def.fixed) {\n                    tw.loop_ids[def.id] = tw.in_loop;\n                    mark(tw, def);\n                }\n            });\n            scope.may_call_this = function() {\n                scope.may_call_this = noop;\n                if (!scope.contains_this()) return;\n                scope.functions.each(function(def) {\n                    if (is_defun(def.init) && !(def.id in tw.defun_ids)) {\n                        tw.defun_ids[def.id] = false;\n                    }\n                });\n            };\n            if (scope.uses_arguments) scope.each_argname(function(node) {\n                node.definition().last_ref = false;\n            });\n            if (compressor.option(\"ie8\")) scope.variables.each(function(def) {\n                var d = def.orig[0].definition();\n                if (d !== def) d.fixed = false;\n            });\n        }\n\n        function mark_defun(tw, def) {\n            if (def.id in tw.defun_ids) {\n                var marker = tw.defun_ids[def.id];\n                if (!marker) return;\n                var visited = tw.defun_visited[def.id];\n                if (marker === tw.safe_ids) {\n                    if (!visited) return def.fixed;\n                } else if (visited) {\n                    def.init.enclosed.forEach(function(d) {\n                        if (def.init.variables.get(d.name) === d) return;\n                        if (!safe_to_read(tw, d)) d.fixed = false;\n                    });\n                } else {\n                    tw.defun_ids[def.id] = false;\n                }\n            } else {\n                if (!tw.in_loop) {\n                    tw.defun_ids[def.id] = tw.safe_ids;\n                    return def.fixed;\n                }\n                tw.defun_ids[def.id] = false;\n            }\n        }\n\n        function walk_defuns(tw, scope) {\n            scope.functions.each(function(def) {\n                if (is_defun(def.init) && !tw.defun_visited[def.id]) {\n                    tw.defun_ids[def.id] = tw.safe_ids;\n                    def.init.walk(tw);\n                }\n            });\n        }\n\n        function push(tw) {\n            tw.safe_ids = Object.create(tw.safe_ids);\n        }\n\n        function pop(tw) {\n            tw.safe_ids = Object.getPrototypeOf(tw.safe_ids);\n        }\n\n        function mark(tw, def) {\n            tw.safe_ids[def.id] = {};\n        }\n\n        function push_ref(def, ref) {\n            def.references.push(ref);\n            if (def.last_ref !== false) def.last_ref = ref;\n        }\n\n        function safe_to_read(tw, def) {\n            if (def.single_use == \"m\") return false;\n            var safe = tw.safe_ids[def.id];\n            if (safe) {\n                if (!HOP(tw.safe_ids, def.id)) safe.read = safe.read && safe.read !== tw.safe_ids ? true : tw.safe_ids;\n                if (def.fixed == null) {\n                    if (is_arguments(def)) return false;\n                    if (def.global && def.name == \"arguments\") return false;\n                    tw.loop_ids[def.id] = null;\n                    def.fixed = make_node(AST_Undefined, def.orig[0]);\n                    return true;\n                }\n                return !safe.assign || safe.assign === tw.safe_ids;\n            }\n            return is_defun(def.fixed);\n        }\n\n        function safe_to_assign(tw, def, declare) {\n            if (!(declare || all(def.orig, function(sym) {\n                return !(sym instanceof AST_SymbolConst);\n            }))) return false;\n            if (def.fixed === undefined) return declare || all(def.orig, function(sym) {\n                return !(sym instanceof AST_SymbolLet);\n            });\n            if (def.fixed === null && def.safe_ids) {\n                def.safe_ids[def.id] = false;\n                delete def.safe_ids;\n                return true;\n            }\n            if (def.fixed === false) return false;\n            var safe = tw.safe_ids[def.id];\n            if (!HOP(tw.safe_ids, def.id)) {\n                if (!safe) return false;\n                if (safe.read && def.scope !== tw.find_parent(AST_Scope)) return false;\n                safe.assign = safe.assign && safe.assign !== tw.safe_ids ? true : tw.safe_ids;\n            }\n            if (def.fixed != null && safe.read) {\n                if (safe.read !== tw.safe_ids) return false;\n                if (tw.loop_ids[def.id] !== tw.in_loop) return false;\n            }\n            return safe_to_read(tw, def) && all(def.orig, function(sym) {\n                return !(sym instanceof AST_SymbolLambda);\n            });\n        }\n\n        function make_ref(ref, fixed) {\n            var node = make_node(AST_SymbolRef, ref, ref);\n            node.fixed = fixed || make_node(AST_Undefined, ref);\n            return node;\n        }\n\n        function ref_once(compressor, def) {\n            return compressor.option(\"unused\")\n                && !def.scope.pinned()\n                && def.single_use !== false\n                && def.references.length - def.recursive_refs == 1\n                && !(is_funarg(def) && def.scope.uses_arguments);\n        }\n\n        function is_immutable(value) {\n            if (!value) return false;\n            return value.is_constant()\n                || value instanceof AST_Lambda\n                || value instanceof AST_This;\n        }\n\n        function has_escaped(d, node, parent) {\n            if (parent instanceof AST_Assign) return parent.operator == \"=\" && parent.right === node;\n            if (parent instanceof AST_Call) return parent.expression !== node || parent instanceof AST_New;\n            if (parent instanceof AST_Exit) return parent.value === node && node.scope !== d.scope;\n            if (parent instanceof AST_VarDef) return parent.value === node;\n        }\n\n        function value_in_use(node, parent) {\n            if (parent instanceof AST_Array) return true;\n            if (parent instanceof AST_Binary) return lazy_op[parent.operator];\n            if (parent instanceof AST_Conditional) return parent.condition !== node;\n            if (parent instanceof AST_Sequence) return parent.tail_node() === node;\n        }\n\n        function mark_escaped(tw, d, scope, node, value, level, depth) {\n            var parent = tw.parent(level);\n            if (value && value.is_constant()) return;\n            if (has_escaped(d, node, parent)) {\n                d.escaped.push(parent);\n                if (depth > 1 && !(value && value.is_constant_expression(scope))) depth = 1;\n                if (!d.escaped.depth || d.escaped.depth > depth) d.escaped.depth = depth;\n                return;\n            } else if (value_in_use(node, parent)) {\n                mark_escaped(tw, d, scope, parent, parent, level + 1, depth);\n            } else if (parent instanceof AST_ObjectKeyVal && parent.value === node) {\n                var obj = tw.parent(level + 1);\n                mark_escaped(tw, d, scope, obj, obj, level + 2, depth);\n            } else if (parent instanceof AST_PropAccess && parent.expression === node) {\n                value = read_property(value, parent);\n                mark_escaped(tw, d, scope, parent, value, level + 1, depth + 1);\n                if (value) return;\n            }\n            if (level > 0) return;\n            if (parent instanceof AST_Call && parent.expression === node) return;\n            if (parent instanceof AST_Sequence && parent.tail_node() !== node) return;\n            if (parent instanceof AST_SimpleStatement) return;\n            if (parent instanceof AST_Unary && !unary_side_effects[parent.operator]) return;\n            d.direct_access = true;\n        }\n\n        function mark_assignment_to_arguments(node) {\n            if (!(node instanceof AST_Sub)) return;\n            var expr = node.expression;\n            if (!(expr instanceof AST_SymbolRef)) return;\n            var def = expr.definition();\n            if (!is_arguments(def)) return;\n            var key = node.property;\n            if (key.is_constant()) key = key.value;\n            if (!(key instanceof AST_Node) && !/^[1-9]*[0-9]$/.test(key)) return;\n            def.reassigned = true;\n            (key instanceof AST_Node ? def.scope.argnames : [ def.scope.argnames[key] ]).forEach(function(argname) {\n                if (argname instanceof AST_SymbolFunarg) argname.definition().fixed = false;\n            });\n        }\n\n        function scan_declaration(tw, lhs, fixed, visit) {\n            var scanner = new TreeWalker(function(node) {\n                if (node instanceof AST_DefaultValue) {\n                    reset_flags(node);\n                    push(tw);\n                    node.value.walk(tw);\n                    pop(tw);\n                    var save = fixed;\n                    fixed = function() {\n                        var value = save();\n                        return is_undefined(value) ? make_sequence(node, [ value, node.value ]) : node.name;\n                    };\n                    node.name.walk(scanner);\n                    fixed = save;\n                    return true;\n                }\n                if (node instanceof AST_DestructuredArray) {\n                    reset_flags(node);\n                    var save = fixed;\n                    node.elements.forEach(function(node, index) {\n                        if (node instanceof AST_Hole) return reset_flags(node);\n                        fixed = function() {\n                            return make_node(AST_Sub, node, {\n                                expression: save(),\n                                property: make_node(AST_Number, node, {\n                                    value: index\n                                })\n                            });\n                        };\n                        node.walk(scanner);\n                    });\n                    fixed = save;\n                    return true;\n                }\n                if (node instanceof AST_DestructuredObject) {\n                    reset_flags(node);\n                    var save = fixed;\n                    node.properties.forEach(function(node) {\n                        reset_flags(node);\n                        if (node.key instanceof AST_Node) {\n                            push(tw);\n                            node.key.walk(tw);\n                            pop(tw);\n                        }\n                        fixed = function() {\n                            var key = node.key;\n                            var type = AST_Sub;\n                            if (typeof key == \"string\") {\n                                if (is_identifier_string(key)) {\n                                    type = AST_Dot;\n                                } else {\n                                    key = make_node_from_constant(key, node);\n                                }\n                            }\n                            return make_node(type, node, {\n                                expression: save(),\n                                property: key\n                            });\n                        };\n                        node.value.walk(scanner);\n                    });\n                    fixed = save;\n                    return true;\n                }\n                visit(node, fixed, function() {\n                    var save_len = tw.stack.length;\n                    for (var i = 0, len = scanner.stack.length - 1; i < len; i++) {\n                        tw.stack.push(scanner.stack[i]);\n                    }\n                    node.walk(tw);\n                    tw.stack.length = save_len;\n                });\n                return true;\n            });\n            lhs.walk(scanner);\n        }\n\n        function reduce_defun(tw, descend, compressor) {\n            var id = this.name.definition().id;\n            if (tw.defun_visited[id]) return true;\n            if (tw.defun_ids[id] !== tw.safe_ids) return true;\n            tw.defun_visited[id] = true;\n            this.inlined = false;\n            push(tw);\n            reset_variables(tw, compressor, this);\n            descend();\n            pop(tw);\n            walk_defuns(tw, this);\n            return true;\n        }\n\n        function reduce_iife(tw, descend, compressor) {\n            var fn = this;\n            fn.inlined = false;\n            var iife = tw.parent();\n            var hit = fn instanceof AST_AsyncFunction;\n            var aborts = false;\n            fn.walk(new TreeWalker(function(node) {\n                if (hit) return aborts = true;\n                if (node instanceof AST_Return) return hit = true;\n                if (node instanceof AST_Scope && node !== fn) return true;\n            }));\n            if (aborts) push(tw);\n            reset_variables(tw, compressor, fn);\n            // Virtually turn IIFE parameters into variable definitions:\n            //   (function(a,b) {...})(c,d) => (function() {var a=c,b=d; ...})()\n            // So existing transformation rules can work on them.\n            var safe = !fn.uses_arguments || tw.has_directive(\"use strict\");\n            fn.argnames.forEach(function(arg, i) {\n                var value = iife.args[i];\n                scan_declaration(tw, arg, function() {\n                    var j = fn.argnames.indexOf(arg);\n                    return (j < 0 ? value : iife.args[j]) || make_node(AST_Undefined, iife);\n                }, function(node, fixed) {\n                    var d = node.definition();\n                    if (safe && d.fixed === undefined) {\n                        mark(tw, d);\n                        tw.loop_ids[d.id] = tw.in_loop;\n                        var value = iife.args[i];\n                        d.fixed = fixed;\n                        d.fixed.assigns = [ arg ];\n                    } else {\n                        d.fixed = false;\n                    }\n                });\n            });\n            if (fn instanceof AST_Arrow && fn.value) {\n                fn.value.walk(tw);\n            } else {\n                walk_body(fn, tw);\n            }\n            var safe_ids = tw.safe_ids;\n            pop(tw);\n            walk_defuns(tw, fn);\n            if (!aborts) tw.safe_ids = safe_ids;\n            return true;\n        }\n\n        def(AST_Assign, function(tw, descend, compressor) {\n            var node = this;\n            var left = node.left;\n            if (node.operator == \"=\" && left.equivalent_to(node.right) && !left.has_side_effects(compressor)) {\n                node.right.walk(tw);\n                walk_prop(left);\n                node.__drop = true;\n            } else if (!(left instanceof AST_Destructured || left instanceof AST_SymbolRef)) {\n                mark_assignment_to_arguments(left);\n                return;\n            } else if (node.operator == \"=\") {\n                node.right.walk(tw);\n                scan_declaration(tw, left, function() {\n                    return node.right;\n                }, function(sym, fixed, walk) {\n                    if (!(sym instanceof AST_SymbolRef)) {\n                        mark_assignment_to_arguments(sym);\n                        walk();\n                        return;\n                    }\n                    var d = sym.definition();\n                    d.assignments++;\n                    if (!is_modified(compressor, tw, node, node.right, 0) && safe_to_assign(tw, d)) {\n                        push_ref(d, sym);\n                        mark(tw, d);\n                        if (d.single_use && left instanceof AST_Destructured) d.single_use = false;\n                        tw.loop_ids[d.id] = tw.in_loop;\n                        mark_escaped(tw, d, sym.scope, node, node.right, 0, 1);\n                        sym.fixed = d.fixed = fixed;\n                        sym.fixed.assigns = [ node ];\n                    } else {\n                        walk();\n                        d.fixed = false;\n                    }\n                });\n            } else {\n                var d = left.definition();\n                d.assignments++;\n                var fixed = d.fixed;\n                if (is_modified(compressor, tw, node, node, 0)) {\n                    d.fixed = false;\n                    return;\n                }\n                var safe = safe_to_read(tw, d);\n                node.right.walk(tw);\n                if (safe && safe_to_assign(tw, d)) {\n                    push_ref(d, left);\n                    mark(tw, d);\n                    if (d.single_use) d.single_use = false;\n                    left.fixed = d.fixed = function() {\n                        return make_node(AST_Binary, node, {\n                            operator: node.operator.slice(0, -1),\n                            left: make_ref(left, fixed),\n                            right: node.right\n                        });\n                    };\n                    left.fixed.assigns = !fixed || !fixed.assigns ? [] : fixed.assigns.slice();\n                    left.fixed.assigns.push(node);\n                } else {\n                    left.walk(tw);\n                    d.fixed = false;\n                }\n            }\n            return true;\n\n            function walk_prop(node) {\n                if (node instanceof AST_Dot) {\n                    walk_prop(node.expression);\n                } else if (node instanceof AST_Sub) {\n                    walk_prop(node.expression);\n                    node.property.walk(tw);\n                } else if (node instanceof AST_SymbolRef) {\n                    var d = node.definition();\n                    push_ref(d, node);\n                    node.fixed = d.fixed;\n                } else {\n                    node.walk(tw);\n                }\n            }\n        });\n        def(AST_AsyncDefun, reduce_defun);\n        def(AST_Binary, function(tw) {\n            if (!lazy_op[this.operator]) return;\n            this.left.walk(tw);\n            push(tw);\n            this.right.walk(tw);\n            pop(tw);\n            return true;\n        });\n        def(AST_BlockScope, function(tw, descend, compressor) {\n            this.variables.each(function(def) {\n                reset_def(tw, compressor, def);\n            });\n        });\n        def(AST_Call, function(tw, descend) {\n            tw.find_parent(AST_Scope).may_call_this();\n            var exp = this.expression;\n            if (is_function(exp)) {\n                var iife = !exp.name;\n                this.args.forEach(function(arg) {\n                    arg.walk(tw);\n                    if (arg instanceof AST_Spread) iife = false;\n                });\n                if (iife) exp.reduce_vars = reduce_iife;\n                exp.walk(tw);\n                if (iife) delete exp.reduce_vars;\n                return true;\n            } else if (exp instanceof AST_SymbolRef) {\n                var def = exp.definition();\n                if (this.TYPE == \"Call\" && tw.in_boolean_context()) def.bool_fn++;\n                if (!is_defun(def.fixed)) return;\n                var defun = mark_defun(tw, def);\n                if (!defun) return;\n                descend();\n                defun.walk(tw);\n                return true;\n            } else if (this.TYPE == \"Call\"\n                && exp instanceof AST_Assign\n                && exp.operator == \"=\"\n                && exp.left instanceof AST_SymbolRef\n                && tw.in_boolean_context()) {\n                exp.left.definition().bool_fn++;\n            }\n        });\n        def(AST_Conditional, function(tw) {\n            this.condition.walk(tw);\n            push(tw);\n            this.consequent.walk(tw);\n            pop(tw);\n            push(tw);\n            this.alternative.walk(tw);\n            pop(tw);\n            return true;\n        });\n        def(AST_DefaultValue, function(tw) {\n            this.name.walk(tw);\n            push(tw);\n            this.value.walk(tw);\n            pop(tw);\n            return true;\n        });\n        def(AST_Defun, reduce_defun);\n        def(AST_Do, function(tw) {\n            var saved_loop = tw.in_loop;\n            tw.in_loop = this;\n            push(tw);\n            this.body.walk(tw);\n            if (has_loop_control(this, tw.parent())) {\n                pop(tw);\n                push(tw);\n            }\n            this.condition.walk(tw);\n            pop(tw);\n            tw.in_loop = saved_loop;\n            return true;\n        });\n        def(AST_For, function(tw, descend, compressor) {\n            this.variables.each(function(def) {\n                reset_def(tw, compressor, def);\n            });\n            if (this.init) this.init.walk(tw);\n            var saved_loop = tw.in_loop;\n            tw.in_loop = this;\n            push(tw);\n            if (this.condition) this.condition.walk(tw);\n            this.body.walk(tw);\n            if (this.step) {\n                if (has_loop_control(this, tw.parent())) {\n                    pop(tw);\n                    push(tw);\n                }\n                this.step.walk(tw);\n            }\n            pop(tw);\n            tw.in_loop = saved_loop;\n            return true;\n        });\n        def(AST_ForIn, function(tw, descend, compressor) {\n            this.variables.each(function(def) {\n                reset_def(tw, compressor, def);\n            });\n            this.object.walk(tw);\n            var saved_loop = tw.in_loop;\n            tw.in_loop = this;\n            push(tw);\n            var init = this.init;\n            if (init instanceof AST_Definitions) {\n                init.definitions[0].name.mark_symbol(function(node) {\n                    if (node instanceof AST_SymbolDeclaration) {\n                        var def = node.definition();\n                        def.assignments++;\n                        def.fixed = false;\n                    }\n                }, tw);\n            } else if (init instanceof AST_Destructured || init instanceof AST_SymbolRef) {\n                init.mark_symbol(function(node) {\n                    if (node instanceof AST_SymbolRef) {\n                        var def = node.definition();\n                        push_ref(def, node);\n                        def.assignments++;\n                        if (!node.is_immutable()) def.fixed = false;\n                    }\n                }, tw);\n            } else {\n                init.walk(tw);\n            }\n            this.body.walk(tw);\n            pop(tw);\n            tw.in_loop = saved_loop;\n            return true;\n        });\n        def(AST_If, function(tw) {\n            this.condition.walk(tw);\n            push(tw);\n            this.body.walk(tw);\n            pop(tw);\n            if (this.alternative) {\n                push(tw);\n                this.alternative.walk(tw);\n                pop(tw);\n            }\n            return true;\n        });\n        def(AST_LabeledStatement, function(tw) {\n            push(tw);\n            this.body.walk(tw);\n            pop(tw);\n            return true;\n        });\n        def(AST_Lambda, function(tw, descend, compressor) {\n            var fn = this;\n            fn.inlined = false;\n            push(tw);\n            reset_variables(tw, compressor, fn);\n            descend();\n            pop(tw);\n            if (fn.name) mark_escaped(tw, fn.name.definition(), fn, fn.name, fn, 0, 1);\n            walk_defuns(tw, fn);\n            return true;\n        });\n        def(AST_Switch, function(tw, descend, compressor) {\n            this.variables.each(function(def) {\n                reset_def(tw, compressor, def);\n            });\n            this.expression.walk(tw);\n            var first = true;\n            this.body.forEach(function(branch) {\n                if (branch instanceof AST_Default) return;\n                branch.expression.walk(tw);\n                if (first) {\n                    first = false;\n                    push(tw);\n                }\n            })\n            if (!first) pop(tw);\n            walk_body(this, tw);\n            return true;\n        });\n        def(AST_SwitchBranch, function(tw) {\n            push(tw);\n            walk_body(this, tw);\n            pop(tw);\n            return true;\n        });\n        def(AST_SymbolCatch, function() {\n            this.definition().fixed = false;\n        });\n        def(AST_SymbolRef, function(tw, descend, compressor) {\n            var d = this.definition();\n            push_ref(d, this);\n            if (d.references.length == 1\n                && !d.fixed\n                && d.orig[0] instanceof AST_SymbolDefun) {\n                tw.loop_ids[d.id] = tw.in_loop;\n            }\n            if (d.fixed === false) {\n                var redef = d.redefined();\n                if (redef && cross_scope(d.scope, this.scope)) redef.single_use = false;\n            } else if (d.fixed === undefined || !safe_to_read(tw, d)) {\n                d.fixed = false;\n            } else if (d.fixed) {\n                if (this.in_arg && d.orig[0] instanceof AST_SymbolLambda) this.fixed = d.scope;\n                var value = this.fixed_value();\n                var recursive = recursive_ref(tw, d);\n                if (recursive) {\n                    d.recursive_refs++;\n                } else if (value && ref_once(compressor, d)) {\n                    d.in_loop = tw.loop_ids[d.id] !== tw.in_loop;\n                    d.single_use = value instanceof AST_Lambda\n                            && !value.pinned()\n                            && (!d.in_loop || tw.parent() instanceof AST_Call)\n                        || !d.in_loop\n                            && d.scope === this.scope.resolve()\n                            && value.is_constant_expression();\n                } else {\n                    d.single_use = false;\n                }\n                if (is_modified(compressor, tw, this, value, 0, is_immutable(value), recursive)) {\n                    if (d.single_use) {\n                        d.single_use = \"m\";\n                    } else {\n                        d.fixed = false;\n                    }\n                }\n                if (d.fixed && tw.loop_ids[d.id] !== tw.in_loop) {\n                    d.cross_loop = true;\n                }\n                mark_escaped(tw, d, this.scope, this, value, 0, 1);\n            }\n            if (!this.fixed) this.fixed = d.fixed;\n            var parent;\n            if (is_defun(d.fixed) && !((parent = tw.parent()) instanceof AST_Call && parent.expression === this)) {\n                var defun = mark_defun(tw, d);\n                if (defun) defun.walk(tw);\n            }\n        });\n        def(AST_Toplevel, function(tw, descend, compressor) {\n            this.globals.each(function(def) {\n                reset_def(tw, compressor, def);\n            });\n            push(tw);\n            reset_variables(tw, compressor, this);\n            descend();\n            pop(tw);\n            walk_defuns(tw, this);\n            return true;\n        });\n        def(AST_Try, function(tw, descend, compressor) {\n            this.variables.each(function(def) {\n                reset_def(tw, compressor, def);\n            });\n            push(tw);\n            walk_body(this, tw);\n            pop(tw);\n            if (this.bcatch) {\n                push(tw);\n                this.bcatch.walk(tw);\n                pop(tw);\n            }\n            if (this.bfinally) this.bfinally.walk(tw);\n            return true;\n        });\n        def(AST_Unary, function(tw, descend) {\n            var node = this;\n            if (!UNARY_POSTFIX[node.operator]) return;\n            var exp = node.expression;\n            if (!(exp instanceof AST_SymbolRef)) {\n                mark_assignment_to_arguments(exp);\n                return;\n            }\n            var d = exp.definition();\n            d.assignments++;\n            var fixed = d.fixed;\n            if (safe_to_read(tw, d) && safe_to_assign(tw, d)) {\n                push_ref(d, exp);\n                mark(tw, d);\n                if (d.single_use) d.single_use = false;\n                d.fixed = function() {\n                    return make_node(AST_Binary, node, {\n                        operator: node.operator.slice(0, -1),\n                        left: make_node(AST_UnaryPrefix, node, {\n                            operator: \"+\",\n                            expression: make_ref(exp, fixed)\n                        }),\n                        right: make_node(AST_Number, node, {\n                            value: 1\n                        })\n                    });\n                };\n                d.fixed.assigns = fixed && fixed.assigns ? fixed.assigns.slice() : [];\n                d.fixed.assigns.push(node);\n                if (node instanceof AST_UnaryPrefix) {\n                    exp.fixed = d.fixed;\n                } else {\n                    exp.fixed = function() {\n                        return make_node(AST_UnaryPrefix, node, {\n                            operator: \"+\",\n                            expression: make_ref(exp, fixed)\n                        });\n                    };\n                    exp.fixed.assigns = fixed && fixed.assigns;\n                }\n            } else {\n                exp.walk(tw);\n                d.fixed = false;\n            }\n            return true;\n        });\n        def(AST_VarDef, function(tw) {\n            var node = this;\n            if (!node.value) return;\n            node.value.walk(tw);\n            scan_declaration(tw, node.name, function() {\n                return node.value;\n            }, function(name, fixed) {\n                var d = name.definition();\n                if (safe_to_assign(tw, d, true)) {\n                    mark(tw, d);\n                    tw.loop_ids[d.id] = tw.in_loop;\n                    d.fixed = fixed;\n                    d.fixed.assigns = [ node ];\n                    if (name instanceof AST_SymbolConst && d.redefined()\n                        || !(can_drop_symbol(name) || is_safe_lexical(d))) {\n                        d.single_use = false;\n                    }\n                } else {\n                    d.fixed = false;\n                }\n            });\n            return true;\n        });\n        def(AST_While, function(tw, descend) {\n            var saved_loop = tw.in_loop;\n            tw.in_loop = this;\n            push(tw);\n            descend();\n            pop(tw);\n            tw.in_loop = saved_loop;\n            return true;\n        });\n    })(function(node, func) {\n        node.DEFMETHOD(\"reduce_vars\", func);\n    });\n\n    function reset_flags(node) {\n        node._squeezed = false;\n        node._optimized = false;\n        delete node.fixed;\n        if (node instanceof AST_Scope) delete node._var_names;\n    }\n\n    AST_Toplevel.DEFMETHOD(\"reset_opt_flags\", function(compressor) {\n        var tw = new TreeWalker(compressor.option(\"reduce_vars\") ? function(node, descend) {\n            reset_flags(node);\n            return node.reduce_vars(tw, descend, compressor);\n        } : reset_flags);\n        // Flow control for visiting `AST_Defun`s\n        tw.defun_ids = Object.create(null);\n        tw.defun_visited = Object.create(null);\n        // Record the loop body in which `AST_SymbolDeclaration` is first encountered\n        tw.in_loop = null;\n        tw.loop_ids = Object.create(null);\n        // Stack of look-up tables to keep track of whether a `SymbolDef` has been\n        // properly assigned before use:\n        // - `push()` & `pop()` when visiting conditional branches\n        // - backup & restore via `save_ids` when visiting out-of-order sections\n        tw.safe_ids = Object.create(null);\n        this.walk(tw);\n    });\n\n    AST_Symbol.DEFMETHOD(\"fixed_value\", function() {\n        var fixed = this.definition().fixed;\n        if (!fixed) return fixed;\n        if (this.fixed) fixed = this.fixed;\n        return fixed instanceof AST_Node ? fixed : fixed();\n    });\n\n    AST_SymbolRef.DEFMETHOD(\"is_immutable\", function() {\n        var def = this.definition();\n        if (def.orig.length != 1) return false;\n        var sym = def.orig[0];\n        return sym instanceof AST_SymbolLambda && def.scope.name === sym;\n    });\n\n    AST_Node.DEFMETHOD(\"convert_symbol\", noop);\n    AST_Destructured.DEFMETHOD(\"convert_symbol\", function(type, process) {\n        return this.transform(new TreeTransformer(function(node, descend) {\n            if (node instanceof AST_DefaultValue) {\n                node = node.clone();\n                node.name = node.name.transform(this);\n                return node;\n            }\n            if (node instanceof AST_Destructured) {\n                node = node.clone();\n                descend(node, this);\n                return node;\n            }\n            if (node instanceof AST_DestructuredKeyVal) {\n                node = node.clone();\n                node.value = node.value.transform(this);\n                return node;\n            }\n            return node.convert_symbol(type, process);\n        }));\n    });\n    function convert_symbol(type, process) {\n        var node = make_node(type, this, this);\n        process(node, this);\n        return node;\n    }\n    AST_SymbolDeclaration.DEFMETHOD(\"convert_symbol\", convert_symbol);\n    AST_SymbolRef.DEFMETHOD(\"convert_symbol\", convert_symbol);\n\n    function mark_destructured(process, tw) {\n        var marker = new TreeWalker(function(node) {\n            if (node instanceof AST_DefaultValue) {\n                node.value.walk(tw);\n                node.name.walk(marker);\n                return true;\n            }\n            if (node instanceof AST_DestructuredKeyVal) {\n                if (node.key instanceof AST_Node) node.key.walk(tw);\n                node.value.walk(marker);\n                return true;\n            }\n            return process(node);\n        });\n        this.walk(marker);\n    }\n    AST_DefaultValue.DEFMETHOD(\"mark_symbol\", mark_destructured);\n    AST_Destructured.DEFMETHOD(\"mark_symbol\", mark_destructured);\n    function mark_symbol(process) {\n        return process(this);\n    }\n    AST_SymbolDeclaration.DEFMETHOD(\"mark_symbol\", mark_symbol);\n    AST_SymbolRef.DEFMETHOD(\"mark_symbol\", mark_symbol);\n\n    AST_Node.DEFMETHOD(\"match_symbol\", function(predicate) {\n        return predicate(this);\n    });\n    AST_Destructured.DEFMETHOD(\"match_symbol\", function(predicate, ignore_side_effects) {\n        var found = false;\n        var tw = new TreeWalker(function(node) {\n            if (found) return true;\n            if (node instanceof AST_DefaultValue) {\n                if (!ignore_side_effects) return found = true;\n                node.name.walk(tw);\n                return true;\n            }\n            if (node instanceof AST_DestructuredKeyVal) {\n                if (!ignore_side_effects && node.key instanceof AST_Node) return found = true;\n                node.value.walk(tw);\n                return true;\n            }\n            if (predicate(node)) return found = true;\n        });\n        this.walk(tw);\n        return found;\n    });\n\n    function find_scope(compressor) {\n        var level = 0, node;\n        while (node = compressor.parent(level++)) {\n            if (node.variables) return node;\n        }\n    }\n\n    function is_lhs_read_only(lhs, compressor) {\n        if (lhs instanceof AST_This) return true;\n        if (lhs instanceof AST_SymbolRef) {\n            var def = lhs.definition();\n            return def.lambda || compressor.exposed(def) && identifier_atom[def.name];\n        }\n        if (lhs instanceof AST_PropAccess) {\n            lhs = lhs.expression;\n            if (lhs instanceof AST_SymbolRef) {\n                if (lhs.is_immutable()) return false;\n                lhs = lhs.fixed_value();\n            }\n            if (!lhs) return true;\n            if (lhs.is_constant()) return true;\n            return is_lhs_read_only(lhs, compressor);\n        }\n        return false;\n    }\n\n    function make_node(ctor, orig, props) {\n        if (!props) props = {};\n        if (orig) {\n            if (!props.start) props.start = orig.start;\n            if (!props.end) props.end = orig.end;\n        }\n        return new ctor(props);\n    }\n\n    function make_sequence(orig, expressions) {\n        if (expressions.length == 1) return expressions[0];\n        return make_node(AST_Sequence, orig, {\n            expressions: expressions.reduce(merge_sequence, [])\n        });\n    }\n\n    function make_node_from_constant(val, orig) {\n        switch (typeof val) {\n          case \"string\":\n            return make_node(AST_String, orig, {\n                value: val\n            });\n          case \"number\":\n            if (isNaN(val)) return make_node(AST_NaN, orig);\n            if (isFinite(val)) {\n                return 1 / val < 0 ? make_node(AST_UnaryPrefix, orig, {\n                    operator: \"-\",\n                    expression: make_node(AST_Number, orig, { value: -val })\n                }) : make_node(AST_Number, orig, { value: val });\n            }\n            return val < 0 ? make_node(AST_UnaryPrefix, orig, {\n                operator: \"-\",\n                expression: make_node(AST_Infinity, orig)\n            }) : make_node(AST_Infinity, orig);\n          case \"boolean\":\n            return make_node(val ? AST_True : AST_False, orig);\n          case \"undefined\":\n            return make_node(AST_Undefined, orig);\n          default:\n            if (val === null) {\n                return make_node(AST_Null, orig, { value: null });\n            }\n            if (val instanceof RegExp) {\n                return make_node(AST_RegExp, orig, { value: val });\n            }\n            throw new Error(string_template(\"Can't handle constant of type: {type}\", {\n                type: typeof val\n            }));\n        }\n    }\n\n    function needs_unbinding(compressor, val) {\n        return val instanceof AST_PropAccess\n            || is_undeclared_ref(val) && val.name == \"eval\";\n    }\n\n    // we shouldn't compress (1,func)(something) to\n    // func(something) because that changes the meaning of\n    // the func (becomes lexical instead of global).\n    function maintain_this_binding(compressor, parent, orig, val) {\n        var wrap = false;\n        if (parent.TYPE == \"Call\") {\n            wrap = parent.expression === orig && needs_unbinding(compressor, val);\n        } else if (parent instanceof AST_UnaryPrefix) {\n            wrap = parent.operator == \"delete\"\n                || parent.operator == \"typeof\" && is_undeclared_ref(val);\n        }\n        return wrap ? make_sequence(orig, [ make_node(AST_Number, orig, { value: 0 }), val ]) : val;\n    }\n\n    function merge_sequence(array, node) {\n        if (node instanceof AST_Sequence) {\n            array.push.apply(array, node.expressions);\n        } else {\n            array.push(node);\n        }\n        return array;\n    }\n\n    function as_statement_array(thing) {\n        if (thing === null) return [];\n        if (thing instanceof AST_BlockStatement) return all(thing.body, function(stat) {\n            return !(stat instanceof AST_Const || stat instanceof AST_Let);\n        }) ? thing.body : [ thing ];\n        if (thing instanceof AST_EmptyStatement) return [];\n        if (thing instanceof AST_Statement) return [ thing ];\n        throw new Error(\"Can't convert thing to statement array\");\n    }\n\n    function is_empty(thing) {\n        if (thing === null) return true;\n        if (thing instanceof AST_EmptyStatement) return true;\n        if (thing instanceof AST_BlockStatement) return thing.body.length == 0;\n        return false;\n    }\n\n    function has_declarations_only(block) {\n        return all(block.body, function(stat) {\n            return is_empty(stat)\n                || stat instanceof AST_Defun\n                || stat instanceof AST_Var && all(stat.definitions, function(var_def) {\n                    return !var_def.value;\n                });\n        });\n    }\n\n    function loop_body(x) {\n        if (x instanceof AST_IterationStatement) {\n            return x.body instanceof AST_BlockStatement ? x.body : x;\n        }\n        return x;\n    }\n\n    function root_expr(prop) {\n        while (prop instanceof AST_PropAccess) prop = prop.expression;\n        return prop;\n    }\n\n    function is_iife_call(node) {\n        if (node.TYPE != \"Call\") return false;\n        var exp = node.expression;\n        return exp instanceof AST_AsyncFunction || exp instanceof AST_Function || is_iife_call(exp);\n    }\n\n    function is_undeclared_ref(node) {\n        return node instanceof AST_SymbolRef && node.definition().undeclared;\n    }\n\n    function get_rvalue(expr) {\n        return expr[expr instanceof AST_Assign ? \"right\" : \"value\"];\n    }\n\n    var global_names = makePredicate(\"Array Boolean clearInterval clearTimeout console Date decodeURI decodeURIComponent encodeURI encodeURIComponent Error escape eval EvalError Function isFinite isNaN JSON Math Number parseFloat parseInt RangeError ReferenceError RegExp Object setInterval setTimeout String SyntaxError TypeError unescape URIError\");\n    AST_SymbolRef.DEFMETHOD(\"is_declared\", function(compressor) {\n        return this.defined\n            || !this.definition().undeclared\n            || compressor.option(\"unsafe\") && global_names[this.name];\n    });\n\n    var identifier_atom = makePredicate(\"Infinity NaN undefined\");\n    function is_identifier_atom(node) {\n        return node instanceof AST_Infinity\n            || node instanceof AST_NaN\n            || node instanceof AST_Undefined;\n    }\n\n    function declarations_only(node) {\n        return all(node.definitions, function(var_def) {\n            return !var_def.value;\n        });\n    }\n\n    function is_declaration(stat) {\n        return stat instanceof AST_Defun || stat instanceof AST_Var && declarations_only(stat);\n    }\n\n    function tighten_body(statements, compressor) {\n        var in_loop, in_try, scope;\n        find_loop_scope_try();\n        var CHANGED, max_iter = 10;\n        do {\n            CHANGED = false;\n            eliminate_spurious_blocks(statements);\n            if (compressor.option(\"dead_code\")) {\n                eliminate_dead_code(statements, compressor);\n            }\n            if (compressor.option(\"if_return\")) {\n                handle_if_return(statements, compressor);\n            }\n            if (compressor.sequences_limit > 0) {\n                sequencesize(statements, compressor);\n                sequencesize_2(statements, compressor);\n            }\n            if (compressor.option(\"join_vars\")) {\n                join_consecutive_vars(statements);\n            }\n            if (compressor.option(\"collapse_vars\")) {\n                collapse(statements, compressor);\n            }\n        } while (CHANGED && max_iter-- > 0);\n        return statements;\n\n        function find_loop_scope_try() {\n            var node = compressor.self(), level = 0;\n            do {\n                if (node instanceof AST_Catch) {\n                    if (!compressor.parent(level).bfinally) level++;\n                } else if (node instanceof AST_Finally) {\n                    level++;\n                } else if (node instanceof AST_IterationStatement) {\n                    in_loop = true;\n                } else if (node instanceof AST_Scope) {\n                    scope = node;\n                    break;\n                } else if (node instanceof AST_Try) {\n                    if (!in_try) in_try = node;\n                }\n            } while (node = compressor.parent(level++));\n        }\n\n        // Search from right to left for assignment-like expressions:\n        // - `var a = x;`\n        // - `a = x;`\n        // - `++a`\n        // For each candidate, scan from left to right for first usage, then try\n        // to fold assignment into the site for compression.\n        // Will not attempt to collapse assignments into or past code blocks\n        // which are not sequentially executed, e.g. loops and conditionals.\n        function collapse(statements, compressor) {\n            if (scope.pinned()) return statements;\n            var args;\n            var assignments = Object.create(null);\n            var candidates = [];\n            var declare_only = Object.create(null);\n            var force_single;\n            var stat_index = statements.length;\n            var scanner = new TreeTransformer(function(node, descend) {\n                if (abort) return node;\n                // Skip nodes before `candidate` as quickly as possible\n                if (!hit) {\n                    if (node !== hit_stack[hit_index]) return node;\n                    hit_index++;\n                    if (hit_index < hit_stack.length) return handle_custom_scan_order(node, scanner);\n                    hit = true;\n                    stop_after = (value_def ? find_stop_value : find_stop)(node, 0);\n                    if (stop_after === node) abort = true;\n                    return node;\n                }\n                // Stop immediately if these node types are encountered\n                var parent = scanner.parent();\n                if (should_stop(node, parent)) {\n                    abort = true;\n                    return node;\n                }\n                // Stop only if candidate is found within conditional branches\n                if (!stop_if_hit && in_conditional(node, parent)) {\n                    stop_if_hit = parent;\n                }\n                // Skip transient nodes caused by single-use variable replacement\n                if (node.single_use && parent instanceof AST_VarDef && parent.value === node) return node;\n                // Replace variable with assignment when found\n                var hit_rhs;\n                if (!(node instanceof AST_SymbolDeclaration)\n                    && (scan_lhs && lhs.equivalent_to(node)\n                        || scan_rhs && (hit_rhs = scan_rhs(node, this)))) {\n                    if (!can_replace || stop_if_hit && (hit_rhs || !lhs_local || !replace_all)) {\n                        if (!hit_rhs && !value_def) abort = true;\n                        return node;\n                    }\n                    if (is_lhs(node, parent)) {\n                        if (value_def && !hit_rhs) {\n                            assign_used = true;\n                            replaced++;\n                        }\n                        return node;\n                    } else if (value_def) {\n                        if (!hit_rhs) replaced++;\n                        return node;\n                    } else {\n                        replaced++;\n                    }\n                    CHANGED = abort = true;\n                    AST_Node.info(\"Collapsing {node} [{file}:{line},{col}]\", {\n                        node: node,\n                        file: node.start.file,\n                        line: node.start.line,\n                        col: node.start.col,\n                    });\n                    if (candidate instanceof AST_UnaryPostfix) {\n                        if (lhs instanceof AST_SymbolRef) lhs.definition().fixed = false;\n                        return make_node(AST_UnaryPrefix, candidate, candidate);\n                    }\n                    if (candidate instanceof AST_VarDef) {\n                        var def = candidate.name.definition();\n                        if (def.references.length - def.replaced == 1 && !compressor.exposed(def)) {\n                            def.replaced++;\n                            return maintain_this_binding(compressor, parent, node, candidate.value);\n                        }\n                        return make_node(AST_Assign, candidate, {\n                            operator: \"=\",\n                            left: make_node(AST_SymbolRef, candidate.name, candidate.name),\n                            right: candidate.value\n                        });\n                    }\n                    candidate.write_only = false;\n                    return candidate;\n                }\n                // These node types have child nodes that execute sequentially,\n                // but are otherwise not safe to scan into or beyond them.\n                if (is_last_node(node, parent) || may_throw(node)) {\n                    stop_after = node;\n                    if (node instanceof AST_Scope) abort = true;\n                }\n                // Scan but don't replace inside getter/setter\n                if (node instanceof AST_Accessor) {\n                    var replace = can_replace;\n                    can_replace = false;\n                    descend(node, scanner);\n                    can_replace = replace;\n                    return signal_abort(node);\n                }\n                // Scan but don't replace inside destructuring expression\n                if (node instanceof AST_Destructured) {\n                    var replace = can_replace;\n                    can_replace = false;\n                    descend(node, scanner);\n                    can_replace = replace;\n                    return signal_abort(node);\n                }\n                // Scan but don't replace inside default value\n                if (node instanceof AST_DefaultValue) {\n                    node.name = node.name.transform(scanner);\n                    var replace = can_replace;\n                    can_replace = false;\n                    node.value = node.value.transform(scanner);\n                    can_replace = replace;\n                    return signal_abort(node);\n                }\n                return handle_custom_scan_order(node, scanner);\n            }, signal_abort);\n            var multi_replacer = new TreeTransformer(function(node) {\n                if (abort) return node;\n                // Skip nodes before `candidate` as quickly as possible\n                if (!hit) {\n                    if (node !== hit_stack[hit_index]) return node;\n                    hit_index++;\n                    switch (hit_stack.length - hit_index) {\n                      case 0:\n                        hit = true;\n                        if (assign_used) return node;\n                        if (node instanceof AST_VarDef) return node;\n                        def.replaced++;\n                        var parent = multi_replacer.parent();\n                        if (parent instanceof AST_Sequence && parent.tail_node() !== node) {\n                            value_def.replaced++;\n                            return List.skip;\n                        }\n                        return rvalue;\n                      case 1:\n                        if (!assign_used && node.body === candidate) {\n                            hit = true;\n                            def.replaced++;\n                            value_def.replaced++;\n                            return null;\n                        }\n                      default:\n                        return;\n                    }\n                }\n                // Replace variable when found\n                if (node instanceof AST_SymbolRef\n                    && node.name == def.name) {\n                    if (!--replaced) abort = true;\n                    if (is_lhs(node, multi_replacer.parent())) return node;\n                    def.replaced++;\n                    var ref = rvalue.clone();\n                    value_def.references.push(ref);\n                    return ref;\n                }\n                // Skip (non-executed) functions and (leading) default case in switch statements\n                if (node instanceof AST_Default || node instanceof AST_Scope) return node;\n            }, patch_sequence);\n            while (--stat_index >= 0) {\n                // Treat parameters as collapsible in IIFE, i.e.\n                //   function(a, b){ ... }(x());\n                // would be translated into equivalent assignments:\n                //   var a = x(), b = undefined;\n                if (stat_index == 0 && compressor.option(\"unused\")) extract_args();\n                // Find collapsible assignments\n                var hit_stack = [];\n                extract_candidates(statements[stat_index]);\n                while (candidates.length > 0) {\n                    hit_stack = candidates.pop();\n                    var hit_index = 0;\n                    var candidate = hit_stack[hit_stack.length - 1];\n                    var value_def = null;\n                    var stop_after = null;\n                    var stop_if_hit = null;\n                    var lhs = get_lhs(candidate);\n                    var side_effects = lhs && lhs.has_side_effects(compressor);\n                    var scan_lhs = lhs && !side_effects && !is_lhs_read_only(lhs, compressor);\n                    var scan_rhs = foldable(candidate);\n                    if (!scan_lhs && !scan_rhs) continue;\n                    var funarg = candidate.name instanceof AST_SymbolFunarg;\n                    var may_throw = return_false;\n                    if (candidate.may_throw(compressor)) {\n                        if (funarg && scope instanceof AST_AsyncFunction) continue;\n                        may_throw = in_try ? function(node) {\n                            return node.has_side_effects(compressor);\n                        } : side_effects_external;\n                    }\n                    var read_toplevel = false;\n                    var modify_toplevel = false;\n                    // Locate symbols which may execute code outside of scanning range\n                    var lvalues = get_lvalues(candidate);\n                    var lhs_local = is_lhs_local(lhs);\n                    var rvalue = get_rvalue(candidate);\n                    if (!side_effects) side_effects = value_has_side_effects();\n                    var replace_all = replace_all_symbols(candidate);\n                    var hit = funarg;\n                    var abort = false;\n                    var replaced = 0;\n                    var assign_used = false;\n                    var can_replace = !args || !hit;\n                    if (!can_replace) {\n                        for (var j = candidate.arg_index + 1; !abort && j < args.length; j++) {\n                            if (args[j]) args[j].transform(scanner);\n                        }\n                        can_replace = true;\n                    }\n                    for (var i = stat_index; !abort && i < statements.length; i++) {\n                        statements[i].transform(scanner);\n                    }\n                    if (value_def) {\n                        var def = lhs.definition();\n                        var referenced = def.references.length - def.replaced;\n                        if (candidate instanceof AST_Assign) referenced--;\n                        if (replaced && referenced == replaced) {\n                            abort = false;\n                        } else {\n                            candidates.push(hit_stack);\n                            force_single = true;\n                            continue;\n                        }\n                        if (replaced) {\n                            hit_index = 0;\n                            hit = funarg;\n                            for (var i = stat_index; !abort && i < statements.length; i++) {\n                                if (!statements[i].transform(multi_replacer)) statements.splice(i--, 1);\n                            }\n                            if (candidate instanceof AST_VarDef) {\n                                replaced = !compressor.exposed(def) && def.references.length == def.replaced;\n                            }\n                            value_def.single_use = false;\n                        }\n                    }\n                    if (replaced && !remove_candidate(candidate)) statements.splice(stat_index, 1);\n                }\n            }\n\n            function signal_abort(node) {\n                if (abort) return node;\n                if (stop_after === node) abort = true;\n                if (stop_if_hit === node) stop_if_hit = null;\n                return node;\n            }\n\n            function handle_custom_scan_order(node, tt) {\n                if (!(node instanceof AST_BlockScope)) return;\n                // Skip (non-executed) functions\n                if (node instanceof AST_Scope) return node;\n                // Stop upon collision with block-scoped variables\n                if (!(node.variables && node.variables.all(function(def) {\n                    return !lvalues.has(def.name);\n                }))) {\n                    abort = true;\n                    return node;\n                }\n                // Scan object only in a for-in statement\n                if (node instanceof AST_ForIn) {\n                    node.object = node.object.transform(tt);\n                    abort = true;\n                    return node;\n                }\n                // Scan first case expression only in a switch statement\n                if (node instanceof AST_Switch) {\n                    node.expression = node.expression.transform(tt);\n                    for (var i = 0; !abort && i < node.body.length; i++) {\n                        var branch = node.body[i];\n                        if (branch instanceof AST_Case) {\n                            if (!hit) {\n                                if (branch !== hit_stack[hit_index]) continue;\n                                hit_index++;\n                            }\n                            branch.expression = branch.expression.transform(tt);\n                            if (!replace_all) break;\n                            scan_rhs = false;\n                        }\n                    }\n                    abort = true;\n                    return node;\n                }\n            }\n\n            function is_direct_assignment(node, parent) {\n                if (parent instanceof AST_Assign) return parent.operator == \"=\" && parent.left === node;\n                if (parent instanceof AST_DefaultValue) return parent.name === node;\n                if (parent instanceof AST_DestructuredArray) return true;\n                if (parent instanceof AST_DestructuredKeyVal) return parent.value === node;\n            }\n\n            function should_stop(node, parent) {\n                if (node === rvalue) return true;\n                if (parent instanceof AST_For) return node !== parent.init;\n                if (node instanceof AST_Assign) {\n                    return node.operator != \"=\" && lhs.equivalent_to(node.left);\n                }\n                if (node instanceof AST_Call) {\n                    if (!(lhs instanceof AST_PropAccess)) return false;\n                    if (!lhs.equivalent_to(node.expression)) return false;\n                    return !(rvalue instanceof AST_Function && !rvalue.contains_this());\n                }\n                if (node instanceof AST_Debugger) return true;\n                if (node instanceof AST_Defun) return funarg && lhs.name === node.name.name;\n                if (node instanceof AST_Destructured) return (in_try || !lhs_local) && parent instanceof AST_Assign;\n                if (node instanceof AST_DestructuredKeyVal) return node.key instanceof AST_Node;\n                if (node instanceof AST_DWLoop) return true;\n                if (node instanceof AST_LoopControl) return true;\n                if (node instanceof AST_SymbolRef) {\n                    if (node.is_declared(compressor)) {\n                        if (node.fixed_value()) return false;\n                        if (can_drop_symbol(node)) {\n                            return !(parent instanceof AST_PropAccess && parent.expression === node)\n                                && is_arguments(node.definition());\n                        }\n                    } else if (is_direct_assignment(node, parent)) {\n                        return false;\n                    }\n                    if (!replace_all) return true;\n                    scan_rhs = false;\n                    return false;\n                }\n                if (node instanceof AST_Try) return true;\n                if (node instanceof AST_With) return true;\n                return false;\n            }\n\n            function in_conditional(node, parent) {\n                if (parent instanceof AST_Binary) return lazy_op[parent.operator] && parent.left !== node;\n                if (parent instanceof AST_Case) return parent.expression !== node;\n                if (parent instanceof AST_Conditional) return parent.condition !== node;\n                return parent instanceof AST_If && parent.condition !== node;\n            }\n\n            function is_last_node(node, parent) {\n                if (node instanceof AST_Await) return true;\n                if (node.TYPE == \"Binary\") return node.operator == \"in\" && !is_object(node.right);\n                if (node instanceof AST_Call) {\n                    var def, fn = node.expression;\n                    if (fn instanceof AST_SymbolRef) {\n                        def = fn.definition();\n                        fn = fn.fixed_value();\n                    }\n                    if (!(fn instanceof AST_Lambda)) return true;\n                    if (def && recursive_ref(compressor, def)) return true;\n                    if (fn.collapse_scanning) return false;\n                    fn.collapse_scanning = true;\n                    var replace = can_replace;\n                    can_replace = false;\n                    var after = stop_after;\n                    var if_hit = stop_if_hit;\n                    if (!all(fn.argnames, function(argname) {\n                        if (argname instanceof AST_DefaultValue) {\n                            argname.value.transform(scanner);\n                            if (abort) return false;\n                            argname = argname.name;\n                        }\n                        return !(argname instanceof AST_Destructured);\n                    })) {\n                        abort = true;\n                    } else if (fn instanceof AST_Arrow && fn.value) {\n                        fn.value.transform(scanner);\n                    } else for (var i = 0; !abort && i < fn.body.length; i++) {\n                        var stat = fn.body[i];\n                        if (stat instanceof AST_Return) {\n                            if (stat.value) stat.value.transform(scanner);\n                            break;\n                        }\n                        stat.transform(scanner);\n                    }\n                    stop_if_hit = if_hit;\n                    stop_after = after;\n                    can_replace = replace;\n                    delete fn.collapse_scanning;\n                    if (!abort) return false;\n                    abort = false;\n                    return true;\n                }\n                if (node instanceof AST_Exit) {\n                    if (in_try) {\n                        if (in_try.bfinally) return true;\n                        if (in_try.bcatch && node instanceof AST_Throw) return true;\n                    }\n                    return side_effects || lhs instanceof AST_PropAccess || may_modify(lhs);\n                }\n                if (node instanceof AST_Function) {\n                    return compressor.option(\"ie8\") && node.name && lvalues.has(node.name.name);\n                }\n                if (node instanceof AST_PropAccess) {\n                    var exp = node.expression;\n                    return side_effects || !value_def && exp.may_throw_on_access(compressor)\n                        || exp instanceof AST_SymbolRef && is_arguments(exp.definition());\n                }\n                if (node instanceof AST_Spread) return true;\n                if (node instanceof AST_SymbolRef) {\n                    if (symbol_in_lvalues(node, parent)) return !is_direct_assignment(node, parent);\n                    if (side_effects && may_modify(node)) return true;\n                    var def = node.definition();\n                    return (in_try || def.scope.resolve() !== scope) && !can_drop_symbol(node);\n                }\n                if (node instanceof AST_This) return symbol_in_lvalues(node, parent);\n                if (node instanceof AST_VarDef) {\n                    if ((in_try || !lhs_local) && node.name instanceof AST_Destructured) return true;\n                    return (node.value || parent instanceof AST_Let) && node.name.match_symbol(function(node) {\n                        return node instanceof AST_SymbolDeclaration\n                            && (lvalues.has(node.name) || side_effects && may_modify(node));\n                    }, true);\n                }\n                var sym = is_lhs(node.left, node);\n                if (!sym) return false;\n                if (sym instanceof AST_PropAccess) return true;\n                if ((in_try || !lhs_local) && sym instanceof AST_Destructured) return true;\n                return sym.match_symbol(function(node) {\n                    return node instanceof AST_SymbolRef\n                        && (lvalues.has(node.name) || read_toplevel && compressor.exposed(node.definition()));\n                }, true);\n            }\n\n            function extract_args() {\n                var iife, fn = compressor.self();\n                if (is_function(fn)\n                    && !fn.name\n                    && !fn.uses_arguments\n                    && !fn.pinned()\n                    && (iife = compressor.parent()) instanceof AST_Call\n                    && iife.expression === fn\n                    && all(iife.args, function(arg) {\n                        return !(arg instanceof AST_Spread);\n                    })) {\n                    var fn_strict = compressor.has_directive(\"use strict\");\n                    if (fn_strict && !member(fn_strict, fn.body)) fn_strict = false;\n                    var has_await = fn instanceof AST_AsyncFunction ? function(node) {\n                        return node instanceof AST_Symbol && node.name == \"await\";\n                    } : function(node) {\n                        return node instanceof AST_Await && !tw.find_parent(AST_Scope);\n                    };\n                    var tw = new TreeWalker(function(node) {\n                        if (!arg) return true;\n                        if (has_await(node)) {\n                            arg = null;\n                            return true;\n                        }\n                        if (node instanceof AST_SymbolRef && fn.variables.has(node.name)) {\n                            var s = node.definition().scope;\n                            if (s !== scope) while (s = s.parent_scope) {\n                                if (s === scope) return true;\n                            }\n                            arg = null;\n                        }\n                        if (node instanceof AST_This && (fn_strict || !tw.find_parent(AST_Scope))) {\n                            arg = null;\n                            return true;\n                        }\n                    });\n                    args = iife.args.slice();\n                    var names = Object.create(null);\n                    for (var i = fn.argnames.length; --i >= 0;) {\n                        var sym = fn.argnames[i];\n                        var arg = iife.args[i];\n                        var value;\n                        if (sym instanceof AST_DefaultValue) {\n                            value = sym.value;\n                            sym = sym.name;\n                            args[iife.args.length + i] = value;\n                        }\n                        if (sym instanceof AST_Destructured) {\n                            if (!sym.match_symbol(return_false)) continue;\n                            candidates.length = 0;\n                            break;\n                        }\n                        if (sym.name in names) continue;\n                        names[sym.name] = true;\n                        if (value) arg = !arg || is_undefined(arg) ? value : null;\n                        if (!arg && !value) {\n                            arg = make_node(AST_Undefined, sym).transform(compressor);\n                        } else if (arg instanceof AST_Lambda && arg.pinned()) {\n                            arg = null;\n                        } else if (arg) {\n                            arg.walk(tw);\n                        }\n                        if (!arg) continue;\n                        var candidate = make_node(AST_VarDef, sym, {\n                            name: sym,\n                            value: arg\n                        });\n                        candidate.name_index = i;\n                        candidate.arg_index = value ? iife.args.length + i : i;\n                        candidates.unshift([ candidate ]);\n                    }\n                }\n            }\n\n            function extract_candidates(expr) {\n                hit_stack.push(expr);\n                if (expr instanceof AST_Array) {\n                    expr.elements.forEach(extract_candidates);\n                } else if (expr instanceof AST_Assign) {\n                    if (!(expr.left instanceof AST_Destructured)) candidates.push(hit_stack.slice());\n                    extract_candidates(expr.left);\n                    extract_candidates(expr.right);\n                    if (expr.left instanceof AST_SymbolRef) {\n                        assignments[expr.left.name] = (assignments[expr.left.name] || 0) + 1;\n                    }\n                } else if (expr instanceof AST_Await) {\n                    extract_candidates(expr.expression);\n                } else if (expr instanceof AST_Binary) {\n                    extract_candidates(expr.left);\n                    extract_candidates(expr.right);\n                } else if (expr instanceof AST_Call) {\n                    extract_candidates(expr.expression);\n                    expr.args.forEach(extract_candidates);\n                } else if (expr instanceof AST_Case) {\n                    extract_candidates(expr.expression);\n                } else if (expr instanceof AST_Conditional) {\n                    extract_candidates(expr.condition);\n                    extract_candidates(expr.consequent);\n                    extract_candidates(expr.alternative);\n                } else if (expr instanceof AST_Definitions) {\n                    expr.definitions.forEach(extract_candidates);\n                } else if (expr instanceof AST_Dot) {\n                    extract_candidates(expr.expression);\n                } else if (expr instanceof AST_DWLoop) {\n                    extract_candidates(expr.condition);\n                    if (!(expr.body instanceof AST_Block)) {\n                        extract_candidates(expr.body);\n                    }\n                } else if (expr instanceof AST_Exit) {\n                    if (expr.value) extract_candidates(expr.value);\n                } else if (expr instanceof AST_For) {\n                    if (expr.init) extract_candidates(expr.init);\n                    if (expr.condition) extract_candidates(expr.condition);\n                    if (expr.step) extract_candidates(expr.step);\n                    if (!(expr.body instanceof AST_Block)) {\n                        extract_candidates(expr.body);\n                    }\n                } else if (expr instanceof AST_ForIn) {\n                    extract_candidates(expr.object);\n                    if (!(expr.body instanceof AST_Block)) {\n                        extract_candidates(expr.body);\n                    }\n                } else if (expr instanceof AST_If) {\n                    extract_candidates(expr.condition);\n                    if (!(expr.body instanceof AST_Block)) {\n                        extract_candidates(expr.body);\n                    }\n                    if (expr.alternative && !(expr.alternative instanceof AST_Block)) {\n                        extract_candidates(expr.alternative);\n                    }\n                } else if (expr instanceof AST_Object) {\n                    expr.properties.forEach(function(prop) {\n                        hit_stack.push(prop);\n                        if (prop.key instanceof AST_Node) extract_candidates(prop.key);\n                        if (prop instanceof AST_ObjectKeyVal) extract_candidates(prop.value);\n                        hit_stack.pop();\n                    });\n                } else if (expr instanceof AST_Sequence) {\n                    expr.expressions.forEach(extract_candidates);\n                } else if (expr instanceof AST_SimpleStatement) {\n                    extract_candidates(expr.body);\n                } else if (expr instanceof AST_Spread) {\n                    extract_candidates(expr.expression);\n                } else if (expr instanceof AST_Sub) {\n                    extract_candidates(expr.expression);\n                    extract_candidates(expr.property);\n                } else if (expr instanceof AST_Switch) {\n                    extract_candidates(expr.expression);\n                    expr.body.forEach(extract_candidates);\n                } else if (expr instanceof AST_Unary) {\n                    if (UNARY_POSTFIX[expr.operator]) {\n                        candidates.push(hit_stack.slice());\n                    } else {\n                        extract_candidates(expr.expression);\n                    }\n                } else if (expr instanceof AST_VarDef) {\n                    if (expr.name instanceof AST_SymbolVar) {\n                        if (expr.value) {\n                            var def = expr.name.definition();\n                            if (def.references.length > def.replaced) {\n                                candidates.push(hit_stack.slice());\n                            }\n                        } else {\n                            declare_only[expr.name.name] = (declare_only[expr.name.name] || 0) + 1;\n                        }\n                    }\n                    if (expr.value) extract_candidates(expr.value);\n                }\n                hit_stack.pop();\n            }\n\n            function find_stop(node, level) {\n                var parent = scanner.parent(level);\n                if (parent instanceof AST_Array) return node;\n                if (parent instanceof AST_Assign) return node;\n                if (parent instanceof AST_Await) return node;\n                if (parent instanceof AST_Binary) return node;\n                if (parent instanceof AST_Call) return node;\n                if (parent instanceof AST_Case) return node;\n                if (parent instanceof AST_Conditional) return node;\n                if (parent instanceof AST_Definitions) return find_stop_unused(parent, level + 1);\n                if (parent instanceof AST_Exit) return node;\n                if (parent instanceof AST_If) return node;\n                if (parent instanceof AST_IterationStatement) return node;\n                if (parent instanceof AST_ObjectProperty) return node;\n                if (parent instanceof AST_PropAccess) return node;\n                if (parent instanceof AST_Sequence) {\n                    return (parent.tail_node() === node ? find_stop : find_stop_unused)(parent, level + 1);\n                }\n                if (parent instanceof AST_SimpleStatement) return find_stop_unused(parent, level + 1);\n                if (parent instanceof AST_Spread) return node;\n                if (parent instanceof AST_Switch) return node;\n                if (parent instanceof AST_Unary) return node;\n                if (parent instanceof AST_VarDef) return node;\n                return null;\n            }\n\n            function find_stop_value(node, level) {\n                var parent = scanner.parent(level);\n                if (parent instanceof AST_Array) return find_stop_value(parent, level + 1);\n                if (parent instanceof AST_Assign) return may_throw(parent) || parent.left.match_symbol(function(ref) {\n                    return ref instanceof AST_SymbolRef && (lhs.name == ref.name || value_def.name == ref.name);\n                }) ? node : find_stop_value(parent, level + 1);\n                if (parent instanceof AST_Binary) {\n                    if (lazy_op[parent.operator] && parent.left !== node) {\n                        do {\n                            node = parent;\n                            parent = scanner.parent(++level);\n                        } while (parent instanceof AST_Binary && parent.operator == node.operator);\n                        return node;\n                    }\n                    return find_stop_value(parent, level + 1);\n                }\n                if (parent instanceof AST_Call) return parent;\n                if (parent instanceof AST_Case) {\n                    if (parent.expression !== node) return node;\n                    return find_stop_value(parent, level + 1);\n                }\n                if (parent instanceof AST_Conditional) {\n                    if (parent.condition !== node) return node;\n                    return find_stop_value(parent, level + 1);\n                }\n                if (parent instanceof AST_Definitions) return find_stop_unused(parent, level + 1);\n                if (parent instanceof AST_Do) return node;\n                if (parent instanceof AST_Exit) return find_stop_unused(parent, level + 1);\n                if (parent instanceof AST_For) {\n                    if (parent.init !== node && parent.condition !== node) return node;\n                    return find_stop_value(parent, level + 1);\n                }\n                if (parent instanceof AST_ForIn) {\n                    if (parent.init !== node) return node;\n                    return find_stop_value(parent, level + 1);\n                }\n                if (parent instanceof AST_If) {\n                    if (parent.condition !== node) return node;\n                    return find_stop_value(parent, level + 1);\n                }\n                if (parent instanceof AST_ObjectProperty) {\n                    var obj = scanner.parent(level + 1);\n                    return all(obj.properties, function(prop) {\n                        return prop instanceof AST_ObjectKeyVal;\n                    }) ? find_stop_value(obj, level + 2) : obj;\n                }\n                if (parent instanceof AST_PropAccess) return find_stop_value(parent, level + 1);\n                if (parent instanceof AST_Sequence) {\n                    return (parent.tail_node() === node ? find_stop_value : find_stop_unused)(parent, level + 1);\n                }\n                if (parent instanceof AST_SimpleStatement) return find_stop_unused(parent, level + 1);\n                if (parent instanceof AST_Spread) return find_stop_value(parent, level + 1);\n                if (parent instanceof AST_Switch) {\n                    if (parent.expression !== node) return node;\n                    return find_stop_value(parent, level + 1);\n                }\n                if (parent instanceof AST_Unary) {\n                    if (parent.operator == \"delete\") return node;\n                    return find_stop_value(parent, level + 1);\n                }\n                if (parent instanceof AST_VarDef) return parent.name.match_symbol(function(sym) {\n                    return sym instanceof AST_SymbolDeclaration && (lhs.name == sym.name || value_def.name == sym.name);\n                }) ? node : find_stop_value(parent, level + 1);\n                if (parent instanceof AST_While) {\n                    if (parent.condition !== node) return node;\n                    return find_stop_value(parent, level + 1);\n                }\n                return null;\n            }\n\n            function find_stop_unused(node, level) {\n                var parent = scanner.parent(level);\n                if (is_last_node(node, parent)) return node;\n                if (in_conditional(node, parent)) return node;\n                if (parent instanceof AST_Array) return find_stop_unused(parent, level + 1);\n                if (parent instanceof AST_Assign) return check_assignment(parent.left);\n                if (parent instanceof AST_Await) return node;\n                if (parent instanceof AST_Binary) return find_stop_unused(parent, level + 1);\n                if (parent instanceof AST_Call) return find_stop_unused(parent, level + 1);\n                if (parent instanceof AST_Case) return find_stop_unused(parent, level + 1);\n                if (parent instanceof AST_Conditional) return find_stop_unused(parent, level + 1);\n                if (parent instanceof AST_Definitions) return find_stop_unused(parent, level + 1);\n                if (parent instanceof AST_Exit) return find_stop_unused(parent, level + 1);\n                if (parent instanceof AST_If) return find_stop_unused(parent, level + 1);\n                if (parent instanceof AST_IterationStatement) return node;\n                if (parent instanceof AST_ObjectProperty) {\n                    var obj = scanner.parent(level + 1);\n                    return all(obj.properties, function(prop) {\n                        return prop instanceof AST_ObjectKeyVal;\n                    }) ? find_stop_unused(obj, level + 2) : obj;\n                }\n                if (parent instanceof AST_PropAccess) {\n                    var exp = parent.expression;\n                    if (exp === node) return find_stop_unused(parent, level + 1);\n                    var sym = root_expr(exp);\n                    if (!(sym instanceof AST_SymbolRef)) return find_stop_unused(parent, level + 1);\n                    var lvalue = lvalues.get(sym.name);\n                    return !lvalue || all(lvalue, function(lhs) {\n                        return !(lhs instanceof AST_PropAccess);\n                    }) ? find_stop_unused(parent, level + 1) : node;\n                }\n                if (parent instanceof AST_Sequence) return find_stop_unused(parent, level + 1);\n                if (parent instanceof AST_SimpleStatement) return find_stop_unused(parent, level + 1);\n                if (parent instanceof AST_Spread) return node;\n                if (parent instanceof AST_Switch) return find_stop_unused(parent, level + 1);\n                if (parent instanceof AST_Unary) return find_stop_unused(parent, level + 1);\n                if (parent instanceof AST_VarDef) return check_assignment(parent.name);\n                return null;\n\n                function check_assignment(lhs) {\n                    if (may_throw(parent)) return node;\n                    if (lhs !== node && lhs instanceof AST_Destructured) {\n                        var replace = can_replace;\n                        can_replace = false;\n                        var after = stop_after;\n                        var if_hit = stop_if_hit;\n                        lhs.transform(scanner);\n                        stop_if_hit = if_hit;\n                        stop_after = after;\n                        can_replace = replace;\n                        if (abort) {\n                            abort = false;\n                            return node;\n                        }\n                    }\n                    return find_stop_unused(parent, level + 1);\n                }\n            }\n\n            function mangleable_var(value) {\n                if (force_single) {\n                    force_single = false;\n                    return;\n                }\n                if (!(value instanceof AST_SymbolRef)) return;\n                var def = value.definition();\n                if (def.undeclared) return;\n                if (is_arguments(def)) return;\n                return value_def = def;\n            }\n\n            function get_lhs(expr) {\n                if (expr instanceof AST_VarDef) {\n                    var def = expr.name.definition();\n                    if (def.const_redefs) return;\n                    if (!member(expr.name, def.orig)) return;\n                    var declared = def.orig.length - def.eliminated - (declare_only[def.name] || 0);\n                    var referenced = def.references.length - def.replaced - (assignments[def.name] || 0);\n                    if (declared > 1 && !(expr.name instanceof AST_SymbolFunarg)) {\n                        mangleable_var(expr.value);\n                        return make_node(AST_SymbolRef, expr.name, expr.name);\n                    }\n                    if (mangleable_var(expr.value) || referenced == 1 && !compressor.exposed(def)) {\n                        return make_node(AST_SymbolRef, expr.name, expr.name);\n                    }\n                } else if (expr instanceof AST_Assign) {\n                    var def, lhs = expr.left;\n                    if (expr.operator == \"=\"\n                        && lhs instanceof AST_SymbolRef\n                        && (def = lhs.definition()).references[0] === lhs\n                        && !compressor.exposed(def)) {\n                        var referenced = def.references.length - def.replaced;\n                        if (referenced > 1) mangleable_var(expr.right);\n                    }\n                    return lhs;\n                } else {\n                    return expr.expression;\n                }\n            }\n\n            function invariant(expr) {\n                if (expr instanceof AST_Array) return false;\n                if (expr instanceof AST_Binary && lazy_op[expr.operator]) {\n                    return invariant(expr.left) && invariant(expr.right);\n                }\n                if (expr instanceof AST_Call) return false;\n                if (expr instanceof AST_Conditional) {\n                    return invariant(expr.consequent) && invariant(expr.alternative);\n                }\n                if (expr instanceof AST_Object) return false;\n                return !expr.has_side_effects(compressor);\n            }\n\n            function foldable(expr) {\n                if (expr instanceof AST_Assign && expr.right.single_use) return;\n                var lhs_ids = Object.create(null);\n                var marker = new TreeWalker(function(node) {\n                    if (node instanceof AST_SymbolRef) lhs_ids[node.definition().id] = true;\n                });\n                while (expr instanceof AST_Assign && expr.operator == \"=\") {\n                    expr.left.walk(marker);\n                    expr = expr.right;\n                }\n                if (expr instanceof AST_SymbolRef) {\n                    var value = expr.evaluate(compressor);\n                    if (value === expr) return rhs_exact_match;\n                    return rhs_fuzzy_match(value, rhs_exact_match);\n                }\n                if (expr instanceof AST_This) return rhs_exact_match;\n                if (expr.is_truthy()) return rhs_fuzzy_match(true, return_false);\n                if (expr.is_constant()) {\n                    return rhs_fuzzy_match(expr.evaluate(compressor), rhs_exact_match);\n                }\n                if (!(lhs instanceof AST_SymbolRef)) return false;\n                if (!invariant(expr)) return false;\n                var circular;\n                expr.walk(new TreeWalker(function(node) {\n                    if (circular) return true;\n                    if (node instanceof AST_SymbolRef && lhs_ids[node.definition().id]) circular = true;\n                }));\n                return !circular && rhs_exact_match;\n\n                function rhs_exact_match(node) {\n                    return expr.equivalent_to(node);\n                }\n            }\n\n            function rhs_fuzzy_match(value, fallback) {\n                return function(node, tw) {\n                    if (tw.in_boolean_context()) {\n                        if (value && node.is_truthy() && !node.has_side_effects(compressor)) {\n                            return true;\n                        }\n                        if (node.is_constant()) {\n                            return !node.evaluate(compressor) == !value;\n                        }\n                    }\n                    return fallback(node);\n                };\n            }\n\n            function may_be_global(node) {\n                if (node instanceof AST_SymbolRef) {\n                    node = node.fixed_value();\n                    if (!node) return true;\n                }\n                if (node instanceof AST_Assign) return node.operator == \"=\" && may_be_global(node.right);\n                return node instanceof AST_PropAccess || node instanceof AST_This;\n            }\n\n            function get_lvalues(expr) {\n                var lvalues = new Dictionary();\n                if (expr instanceof AST_VarDef) lvalues.add(expr.name.name, lhs);\n                var find_arguments = scope.uses_arguments && !compressor.has_directive(\"use strict\");\n                var scan_toplevel = scope instanceof AST_Toplevel;\n                var tw = new TreeWalker(function(node) {\n                    var value;\n                    if (node instanceof AST_SymbolRef) {\n                        value = node.fixed_value() || node;\n                    } else if (node instanceof AST_This) {\n                        value = node;\n                    }\n                    if (value) lvalues.add(node.name, is_modified(compressor, tw, node, value, 0));\n                    if (find_arguments && node instanceof AST_Sub) {\n                        scope.each_argname(function(argname) {\n                            if (!compressor.option(\"reduce_vars\") || argname.definition().assignments) {\n                                lvalues.add(argname.name, true);\n                            }\n                        });\n                        find_arguments = false;\n                    }\n                    if (!scan_toplevel) return;\n                    if (node.TYPE == \"Call\") {\n                        if (modify_toplevel) return;\n                        var exp = node.expression;\n                        if (exp instanceof AST_PropAccess) return;\n                        if (exp instanceof AST_Function && !exp.contains_this()) return;\n                        modify_toplevel = true;\n                    } else if (node instanceof AST_PropAccess && may_be_global(node.expression)) {\n                        if (node === lhs && !(expr instanceof AST_Unary)) {\n                            modify_toplevel = true;\n                        } else {\n                            read_toplevel = true;\n                        }\n                    }\n                });\n                expr.walk(tw);\n                return lvalues;\n            }\n\n            function remove_candidate(expr) {\n                var index = expr.name_index;\n                if (index >= 0) {\n                    var argname = scope.argnames[index];\n                    if (argname instanceof AST_DefaultValue) {\n                        argname.value = make_node(AST_Number, argname, {\n                            value: 0\n                        });\n                        argname.name.definition().fixed = false;\n                    } else {\n                        var args = compressor.parent().args;\n                        if (args[index]) {\n                            args[index] = make_node(AST_Number, args[index], {\n                                value: 0\n                            });\n                            argname.definition().fixed = false;\n                        }\n                    }\n                    return true;\n                }\n                var end = hit_stack.length - 1;\n                if (hit_stack[end - 1].body === hit_stack[end]) end--;\n                var tt = new TreeTransformer(function(node, descend, in_list) {\n                    if (hit) return node;\n                    if (node !== hit_stack[hit_index]) return node;\n                    hit_index++;\n                    if (hit_index <= end) return handle_custom_scan_order(node, tt);\n                    hit = true;\n                    if (node instanceof AST_VarDef) {\n                        node.value = null;\n                        declare_only[node.name.name] = (declare_only[node.name.name] || 0) + 1;\n                        if (value_def) value_def.replaced++;\n                        return node;\n                    }\n                    return in_list ? List.skip : null;\n                }, patch_sequence);\n                abort = false;\n                hit = false;\n                hit_index = 0;\n                return statements[stat_index].transform(tt);\n            }\n\n            function patch_sequence(node) {\n                if (node instanceof AST_Sequence) switch (node.expressions.length) {\n                    case 0: return null;\n                    case 1: return node.expressions[0];\n                }\n            }\n\n            function is_lhs_local(lhs) {\n                var sym = root_expr(lhs);\n                return sym instanceof AST_SymbolRef\n                    && sym.definition().scope === scope\n                    && !(in_loop\n                        && (lvalues.has(sym.name) && lvalues.get(sym.name)[0] !== lhs\n                            || candidate instanceof AST_Unary\n                            || candidate instanceof AST_Assign && candidate.operator != \"=\"));\n            }\n\n            function value_has_side_effects() {\n                if (candidate instanceof AST_Unary) return false;\n                return rvalue.has_side_effects(compressor);\n            }\n\n            function replace_all_symbols(expr) {\n                if (expr instanceof AST_Unary) return false;\n                if (side_effects) return false;\n                if (value_def) return true;\n                if (!(lhs instanceof AST_SymbolRef)) return false;\n                var referenced;\n                if (expr instanceof AST_VarDef) {\n                    referenced = 1;\n                } else if (expr.operator == \"=\") {\n                    referenced = 2;\n                } else {\n                    return false;\n                }\n                var def = lhs.definition();\n                return def.references.length - def.replaced == referenced;\n            }\n\n            function symbol_in_lvalues(sym, parent) {\n                var lvalue = lvalues.get(sym.name);\n                if (!lvalue || all(lvalue, function(lhs) {\n                    return !lhs;\n                })) return;\n                if (lvalue[0] !== lhs) return true;\n                scan_rhs = false;\n            }\n\n            function may_modify(sym) {\n                var def = sym.definition();\n                if (def.orig.length == 1 && def.orig[0] instanceof AST_SymbolDefun) return false;\n                if (def.scope !== scope) return true;\n                if (modify_toplevel && compressor.exposed(def)) return true;\n                return !all(def.references, function(ref) {\n                    return ref.scope.resolve() === scope;\n                });\n            }\n\n            function side_effects_external(node, lhs) {\n                if (node instanceof AST_Assign) return side_effects_external(node.left, true);\n                if (node instanceof AST_Unary) return side_effects_external(node.expression, true);\n                if (node instanceof AST_VarDef) return node.value && side_effects_external(node.value);\n                if (lhs) {\n                    if (node instanceof AST_Dot) return side_effects_external(node.expression, true);\n                    if (node instanceof AST_Sub) return side_effects_external(node.expression, true);\n                    if (node instanceof AST_SymbolRef) return node.definition().scope !== scope;\n                }\n                return false;\n            }\n        }\n\n        function eliminate_spurious_blocks(statements) {\n            var seen_dirs = [];\n            for (var i = 0; i < statements.length;) {\n                var stat = statements[i];\n                if (stat instanceof AST_BlockStatement) {\n                    if (all(stat.body, function(stat) {\n                        return !(stat instanceof AST_Const || stat instanceof AST_Let);\n                    })) {\n                        CHANGED = true;\n                        eliminate_spurious_blocks(stat.body);\n                        [].splice.apply(statements, [i, 1].concat(stat.body));\n                        i += stat.body.length;\n                        continue;\n                    }\n                }\n                if (stat instanceof AST_Directive) {\n                    if (member(stat.value, seen_dirs)) {\n                        CHANGED = true;\n                        statements.splice(i, 1);\n                        continue;\n                    }\n                    seen_dirs.push(stat.value);\n                }\n                if (stat instanceof AST_EmptyStatement) {\n                    CHANGED = true;\n                    statements.splice(i, 1);\n                    continue;\n                }\n                i++;\n            }\n        }\n\n        function handle_if_return(statements, compressor) {\n            var self = compressor.self();\n            var parent = compressor.parent();\n            var in_lambda = last_of(function(node) {\n                return node instanceof AST_Lambda;\n            });\n            var in_iife = in_lambda && parent && parent.TYPE == \"Call\";\n            var multiple_if_returns = has_multiple_if_returns(statements);\n            for (var i = statements.length; --i >= 0;) {\n                var stat = statements[i];\n                var j = next_index(i);\n                var next = statements[j];\n\n                if (in_lambda && !next && stat instanceof AST_Return) {\n                    if (!stat.value) {\n                        CHANGED = true;\n                        statements.splice(i, 1);\n                        continue;\n                    }\n                    if (stat.value instanceof AST_UnaryPrefix && stat.value.operator == \"void\") {\n                        CHANGED = true;\n                        statements[i] = make_node(AST_SimpleStatement, stat, {\n                            body: stat.value.expression\n                        });\n                        continue;\n                    }\n                }\n\n                if (stat instanceof AST_If) {\n                    var ab = aborts(stat.body);\n                    if (can_merge_flow(ab)) {\n                        if (ab.label) remove(ab.label.thedef.references, ab);\n                        CHANGED = true;\n                        stat = stat.clone();\n                        stat.condition = stat.condition.negate(compressor);\n                        var body = as_statement_array_with_return(stat.body, ab);\n                        stat.body = make_node(AST_BlockStatement, stat, {\n                            body: as_statement_array(stat.alternative).concat(extract_functions())\n                        });\n                        stat.alternative = make_node(AST_BlockStatement, stat, {\n                            body: body\n                        });\n                        statements[i] = stat;\n                        statements[i] = stat.transform(compressor);\n                        continue;\n                    }\n\n                    if (ab && !stat.alternative && stat.body instanceof AST_BlockStatement && next instanceof AST_Jump) {\n                        var negated = stat.condition.negate(compressor);\n                        if (negated.print_to_string().length <= stat.condition.print_to_string().length) {\n                            CHANGED = true;\n                            stat = stat.clone();\n                            stat.condition = negated;\n                            statements[j] = stat.body;\n                            stat.body = next;\n                            statements[i] = stat;\n                            statements[i] = stat.transform(compressor);\n                            continue;\n                        }\n                    }\n\n                    var alt = aborts(stat.alternative);\n                    if (can_merge_flow(alt)) {\n                        if (alt.label) remove(alt.label.thedef.references, alt);\n                        CHANGED = true;\n                        stat = stat.clone();\n                        stat.body = make_node(AST_BlockStatement, stat.body, {\n                            body: as_statement_array(stat.body).concat(extract_functions())\n                        });\n                        var body = as_statement_array_with_return(stat.alternative, alt);\n                        stat.alternative = make_node(AST_BlockStatement, stat.alternative, {\n                            body: body\n                        });\n                        statements[i] = stat;\n                        statements[i] = stat.transform(compressor);\n                        continue;\n                    }\n\n                    if (compressor.option(\"typeofs\")) {\n                        if (ab && !alt) {\n                            mark_locally_defined(stat.condition, null, make_node(AST_BlockStatement, self, {\n                                body: statements.slice(i + 1)\n                            }));\n                        }\n                        if (!ab && alt) {\n                            mark_locally_defined(stat.condition, make_node(AST_BlockStatement, self, {\n                                body: statements.slice(i + 1)\n                            }));\n                        }\n                    }\n                }\n\n                if (stat instanceof AST_If && stat.body instanceof AST_Return) {\n                    var value = stat.body.value;\n                    var in_bool = stat.body.in_bool || next instanceof AST_Return && next.in_bool;\n                    //---\n                    // pretty silly case, but:\n                    // if (foo()) return; return; => foo(); return;\n                    if (!value && !stat.alternative\n                        && (in_lambda && !next || next instanceof AST_Return && !next.value)) {\n                        CHANGED = true;\n                        statements[i] = make_node(AST_SimpleStatement, stat.condition, {\n                            body: stat.condition\n                        });\n                        continue;\n                    }\n                    //---\n                    // if (foo()) return x; return y; => return foo() ? x : y;\n                    if (!stat.alternative && next instanceof AST_Return) {\n                        CHANGED = true;\n                        stat = stat.clone();\n                        stat.alternative = next;\n                        statements.splice(i, 1, stat.transform(compressor));\n                        statements.splice(j, 1);\n                        continue;\n                    }\n                    //---\n                    // if (foo()) return x; [ return ; ] => return foo() ? x : undefined;\n                    if (!stat.alternative && !next && in_lambda && (in_bool || value && multiple_if_returns)) {\n                        CHANGED = true;\n                        stat = stat.clone();\n                        stat.alternative = make_node(AST_Return, stat, {\n                            value: null\n                        });\n                        statements.splice(i, 1, stat.transform(compressor));\n                        continue;\n                    }\n                    //---\n                    // if (a) return b; if (c) return d; e; => return a ? b : c ? d : void e;\n                    //\n                    // if sequences is not enabled, this can lead to an endless loop (issue #866).\n                    // however, with sequences on this helps producing slightly better output for\n                    // the example code.\n                    var prev = statements[prev_index(i)];\n                    if (compressor.option(\"sequences\") && in_lambda && !stat.alternative\n                        && (!prev && in_iife || prev instanceof AST_If && prev.body instanceof AST_Return)\n                        && next_index(j) == statements.length && next instanceof AST_SimpleStatement) {\n                        CHANGED = true;\n                        stat = stat.clone();\n                        stat.alternative = make_node(AST_BlockStatement, next, {\n                            body: [\n                                next,\n                                make_node(AST_Return, next, {\n                                    value: null\n                                })\n                            ]\n                        });\n                        statements.splice(i, 1, stat.transform(compressor));\n                        statements.splice(j, 1);\n                        continue;\n                    }\n                }\n            }\n\n            function has_multiple_if_returns(statements) {\n                var n = 0;\n                for (var i = statements.length; --i >= 0;) {\n                    var stat = statements[i];\n                    if (stat instanceof AST_If && stat.body instanceof AST_Return) {\n                        if (++n > 1) return true;\n                    }\n                }\n                return false;\n            }\n\n            function is_return_void(value) {\n                return !value || value instanceof AST_UnaryPrefix && value.operator == \"void\";\n            }\n\n            function is_last_statement(body, stat) {\n                var index = body.lastIndexOf(stat);\n                if (index < 0) return false;\n                while (++index < body.length) {\n                    if (!is_declaration(body[index])) return false;\n                }\n                return true;\n            }\n\n            function last_of(predicate) {\n                var block = self, stat, level = 0;\n                do {\n                    do {\n                        if (predicate(block)) return true;\n                        block = compressor.parent(level++);\n                    } while (block instanceof AST_If && (stat = block));\n                } while ((block instanceof AST_BlockStatement || block instanceof AST_Scope)\n                    && is_last_statement(block.body, stat));\n            }\n\n            function match_target(target) {\n                return last_of(function(node) {\n                    return node === target;\n                });\n            }\n\n            function can_merge_flow(ab) {\n                if (ab instanceof AST_Return) return in_lambda && is_return_void(ab.value);\n                if (!(ab instanceof AST_LoopControl)) return false;\n                var lct = compressor.loopcontrol_target(ab);\n                if (ab instanceof AST_Continue) return match_target(loop_body(lct));\n                if (lct instanceof AST_IterationStatement) return false;\n                return match_target(lct);\n            }\n\n            function extract_functions() {\n                var tail = statements.slice(i + 1);\n                statements.length = i + 1;\n                return tail.filter(function(stat) {\n                    if (stat instanceof AST_Defun) {\n                        statements.push(stat);\n                        return false;\n                    }\n                    return true;\n                });\n            }\n\n            function as_statement_array_with_return(node, ab) {\n                var body = as_statement_array(node);\n                var block = body, last;\n                while ((last = block[block.length - 1]) !== ab) {\n                    block = last.body;\n                }\n                block.pop();\n                if (ab.value) block.push(make_node(AST_SimpleStatement, ab.value, {\n                    body: ab.value.expression\n                }));\n                return body;\n            }\n\n            function next_index(i) {\n                for (var j = i + 1; j < statements.length; j++) {\n                    if (!is_declaration(statements[j])) break;\n                }\n                return j;\n            }\n\n            function prev_index(i) {\n                for (var j = i; --j >= 0;) {\n                    if (!is_declaration(statements[j])) break;\n                }\n                return j;\n            }\n        }\n\n        function eliminate_dead_code(statements, compressor) {\n            var has_quit;\n            var self = compressor.self();\n            for (var i = 0, n = 0, len = statements.length; i < len; i++) {\n                var stat = statements[i];\n                if (stat instanceof AST_LoopControl) {\n                    var lct = compressor.loopcontrol_target(stat);\n                    if (stat instanceof AST_Break\n                            && !(lct instanceof AST_IterationStatement)\n                            && loop_body(lct) === self\n                        || stat instanceof AST_Continue\n                            && loop_body(lct) === self) {\n                        if (stat.label) remove(stat.label.thedef.references, stat);\n                    } else {\n                        statements[n++] = stat;\n                    }\n                } else {\n                    statements[n++] = stat;\n                }\n                if (aborts(stat)) {\n                    has_quit = statements.slice(i + 1);\n                    break;\n                }\n            }\n            statements.length = n;\n            CHANGED = n != len;\n            if (has_quit) has_quit.forEach(function(stat) {\n                extract_declarations_from_unreachable_code(compressor, stat, statements);\n            });\n        }\n\n        function sequencesize(statements, compressor) {\n            if (statements.length < 2) return;\n            var seq = [], n = 0;\n            function push_seq() {\n                if (!seq.length) return;\n                var body = make_sequence(seq[0], seq);\n                statements[n++] = make_node(AST_SimpleStatement, body, { body: body });\n                seq = [];\n            }\n            for (var i = 0, len = statements.length; i < len; i++) {\n                var stat = statements[i];\n                if (stat instanceof AST_SimpleStatement) {\n                    if (seq.length >= compressor.sequences_limit) push_seq();\n                    var body = stat.body;\n                    if (seq.length > 0) body = body.drop_side_effect_free(compressor);\n                    if (body) merge_sequence(seq, body);\n                } else if (is_declaration(stat)) {\n                    statements[n++] = stat;\n                } else {\n                    push_seq();\n                    statements[n++] = stat;\n                }\n            }\n            push_seq();\n            statements.length = n;\n            if (n != len) CHANGED = true;\n        }\n\n        function to_simple_statement(block, decls) {\n            if (!(block instanceof AST_BlockStatement)) return block;\n            var stat = null;\n            for (var i = 0; i < block.body.length; i++) {\n                var line = block.body[i];\n                if (line instanceof AST_Var && declarations_only(line)) {\n                    decls.push(line);\n                } else if (stat || line instanceof AST_Const || line instanceof AST_Let) {\n                    return false;\n                } else {\n                    stat = line;\n                }\n            }\n            return stat;\n        }\n\n        function sequencesize_2(statements, compressor) {\n            function cons_seq(right) {\n                n--;\n                CHANGED = true;\n                var left = prev.body;\n                return make_sequence(left, [ left, right ]);\n            }\n            var n = 0, prev;\n            for (var i = 0; i < statements.length; i++) {\n                var stat = statements[i];\n                if (prev) {\n                    if (stat instanceof AST_Exit) {\n                        stat.value = cons_seq(stat.value || make_node(AST_Undefined, stat)).transform(compressor);\n                    } else if (stat instanceof AST_For) {\n                        if (!(stat.init instanceof AST_Definitions)) {\n                            var abort = false;\n                            prev.body.walk(new TreeWalker(function(node) {\n                                if (abort || node instanceof AST_Scope) return true;\n                                if (node instanceof AST_Binary && node.operator == \"in\") {\n                                    abort = true;\n                                    return true;\n                                }\n                            }));\n                            if (!abort) {\n                                if (stat.init) stat.init = cons_seq(stat.init);\n                                else {\n                                    stat.init = prev.body;\n                                    n--;\n                                    CHANGED = true;\n                                }\n                            }\n                        }\n                    } else if (stat instanceof AST_ForIn) {\n                        stat.object = cons_seq(stat.object);\n                    } else if (stat instanceof AST_If) {\n                        stat.condition = cons_seq(stat.condition);\n                    } else if (stat instanceof AST_Switch) {\n                        stat.expression = cons_seq(stat.expression);\n                    } else if (stat instanceof AST_With) {\n                        stat.expression = cons_seq(stat.expression);\n                    }\n                }\n                if (compressor.option(\"conditionals\") && stat instanceof AST_If) {\n                    var decls = [];\n                    var body = to_simple_statement(stat.body, decls);\n                    var alt = to_simple_statement(stat.alternative, decls);\n                    if (body !== false && alt !== false && decls.length > 0) {\n                        var len = decls.length;\n                        decls.push(make_node(AST_If, stat, {\n                            condition: stat.condition,\n                            body: body || make_node(AST_EmptyStatement, stat.body),\n                            alternative: alt\n                        }));\n                        decls.unshift(n, 1);\n                        [].splice.apply(statements, decls);\n                        i += len;\n                        n += len + 1;\n                        prev = null;\n                        CHANGED = true;\n                        continue;\n                    }\n                }\n                statements[n++] = stat;\n                prev = stat instanceof AST_SimpleStatement ? stat : null;\n            }\n            statements.length = n;\n        }\n\n        function join_assigns(defn, body, keep) {\n            var exprs;\n            if (body instanceof AST_Assign) {\n                exprs = [ body ];\n            } else if (body instanceof AST_Sequence) {\n                exprs = body.expressions.slice();\n            }\n            if (!exprs) return;\n            var trimmed = false;\n            for (var i = exprs.length - 1; --i >= 0;) {\n                var expr = exprs[i];\n                if (!(expr instanceof AST_Assign)) continue;\n                if (expr.operator != \"=\") continue;\n                if (!(expr.left instanceof AST_SymbolRef)) continue;\n                var tail = exprs.slice(i + 1);\n                if (!trim_assigns(expr.left, expr.right, tail)) continue;\n                trimmed = true;\n                exprs = exprs.slice(0, i + 1).concat(tail);\n            }\n            if (defn instanceof AST_Definitions) {\n                keep = keep || 0;\n                for (var i = defn.definitions.length; --i >= 0;) {\n                    var def = defn.definitions[i];\n                    if (!def.value) continue;\n                    if (trim_assigns(def.name, def.value, exprs)) trimmed = true;\n                    if (merge_conditional_assignments(def, exprs, keep)) trimmed = true;\n                    break;\n                }\n                if (defn instanceof AST_Var && join_var_assign(defn.definitions, exprs, keep)) trimmed = true;\n            }\n            return trimmed && exprs;\n        }\n\n        function merge_conditional_assignments(var_def, exprs, keep) {\n            if (!compressor.option(\"conditionals\")) return;\n            if (var_def.name instanceof AST_Destructured) return;\n            var trimmed = false;\n            var def = var_def.name.definition();\n            while (exprs.length > keep) {\n                var cond = to_conditional_assignment(compressor, def, var_def.value, exprs[0]);\n                if (!cond) break;\n                var_def.value = cond;\n                exprs.shift();\n                trimmed = true;\n            }\n            return trimmed;\n        }\n\n        function join_var_assign(definitions, exprs, keep) {\n            var trimmed = false;\n            while (exprs.length > keep) {\n                var expr = exprs[0];\n                if (!(expr instanceof AST_Assign)) break;\n                if (expr.operator != \"=\") break;\n                var lhs = expr.left;\n                if (!(lhs instanceof AST_SymbolRef)) break;\n                if (is_undeclared_ref(lhs)) break;\n                if (lhs.scope.resolve() !== scope) break;\n                var def = lhs.definition();\n                if (def.scope !== scope) break;\n                if (def.orig.length > def.eliminated + 1) break;\n                if (def.orig[0].TYPE != \"SymbolVar\") break;\n                var name = make_node(AST_SymbolVar, lhs, lhs);\n                definitions.push(make_node(AST_VarDef, expr, {\n                    name: name,\n                    value: expr.right\n                }));\n                def.orig.push(name);\n                def.replaced++;\n                exprs.shift();\n                trimmed = true;\n            }\n            return trimmed;\n        }\n\n        function trim_assigns(name, value, exprs) {\n            if (!(value instanceof AST_Object)) return;\n            var trimmed = false;\n            do {\n                var node = exprs[0];\n                if (!(node instanceof AST_Assign)) break;\n                if (node.operator != \"=\") break;\n                if (!(node.left instanceof AST_PropAccess)) break;\n                var sym = node.left.expression;\n                if (!(sym instanceof AST_SymbolRef)) break;\n                if (name.name != sym.name) break;\n                if (!node.right.is_constant_expression(scope)) break;\n                var prop = node.left.property;\n                if (prop instanceof AST_Node) {\n                    prop = prop.evaluate(compressor);\n                }\n                if (prop instanceof AST_Node) break;\n                prop = \"\" + prop;\n                var diff = prop == \"__proto__\" || compressor.has_directive(\"use strict\") ? function(node) {\n                    return typeof node.key == \"string\" && node.key != prop;\n                } : function(node) {\n                    if (node instanceof AST_ObjectGetter || node instanceof AST_ObjectSetter) {\n                        return typeof node.key == \"string\" && node.key != prop;\n                    }\n                    return true;\n                };\n                if (!all(value.properties, diff)) break;\n                value.properties.push(make_node(AST_ObjectKeyVal, node, {\n                    key: prop,\n                    value: node.right\n                }));\n                exprs.shift();\n                trimmed = true;\n            } while (exprs.length);\n            return trimmed;\n        }\n\n        function join_consecutive_vars(statements) {\n            var defs;\n            for (var i = 0, j = -1; i < statements.length; i++) {\n                var stat = statements[i];\n                var prev = statements[j];\n                if (stat instanceof AST_Definitions) {\n                    if (prev && prev.TYPE == stat.TYPE) {\n                        prev.definitions = prev.definitions.concat(stat.definitions);\n                        CHANGED = true;\n                    } else if (defs && defs.TYPE == stat.TYPE && declarations_only(stat)) {\n                        defs.definitions = defs.definitions.concat(stat.definitions);\n                        CHANGED = true;\n                    } else {\n                        statements[++j] = stat;\n                        if (stat instanceof AST_Var) defs = stat;\n                    }\n                    continue;\n                } else if (stat instanceof AST_Exit) {\n                    stat.value = join_assigns_expr(stat.value);\n                } else if (stat instanceof AST_For) {\n                    var exprs = join_assigns(prev, stat.init);\n                    if (exprs) {\n                        CHANGED = true;\n                        stat.init = exprs.length ? make_sequence(stat.init, exprs) : null;\n                    } else if (prev instanceof AST_Var && (!stat.init || stat.init.TYPE == prev.TYPE)) {\n                        if (stat.init) {\n                            prev.definitions = prev.definitions.concat(stat.init.definitions);\n                        }\n                        defs = stat.init = prev;\n                        statements[j] = merge_defns(stat);\n                        CHANGED = true;\n                        continue;\n                    } else if (defs && stat.init && defs.TYPE == stat.init.TYPE && declarations_only(stat.init)) {\n                        defs.definitions = defs.definitions.concat(stat.init.definitions);\n                        stat.init = null;\n                        CHANGED = true;\n                    } else if (stat.init instanceof AST_Var) {\n                        defs = stat.init;\n                    }\n                } else if (stat instanceof AST_ForIn) {\n                    if (defs && defs.TYPE == stat.init.TYPE) {\n                        var defns = defs.definitions.slice();\n                        stat.init = stat.init.definitions[0].name.convert_symbol(AST_SymbolRef, function(ref, name) {\n                            defns.push(make_node(AST_VarDef, name, {\n                                name: name,\n                                value: null\n                            }));\n                            name.definition().references.push(ref);\n                        });\n                        defs.definitions = defns;\n                        CHANGED = true;\n                    }\n                    stat.object = join_assigns_expr(stat.object);\n                } else if (stat instanceof AST_If) {\n                    stat.condition = join_assigns_expr(stat.condition);\n                } else if (stat instanceof AST_SimpleStatement) {\n                    var exprs = join_assigns(prev, stat.body);\n                    if (exprs) {\n                        CHANGED = true;\n                        if (!exprs.length) continue;\n                        stat.body = make_sequence(stat.body, exprs);\n                    }\n                } else if (stat instanceof AST_Switch) {\n                    stat.expression = join_assigns_expr(stat.expression);\n                } else if (stat instanceof AST_With) {\n                    stat.expression = join_assigns_expr(stat.expression);\n                }\n                statements[++j] = defs ? merge_defns(stat) : stat;\n            }\n            statements.length = j + 1;\n\n            function join_assigns_expr(value) {\n                var exprs = join_assigns(prev, value, 1);\n                if (!exprs) return value;\n                CHANGED = true;\n                var tail = value.tail_node();\n                if (exprs[exprs.length - 1] !== tail) exprs.push(tail.left);\n                return make_sequence(value, exprs);\n            }\n\n            function merge_defns(stat) {\n                return stat.transform(new TreeTransformer(function(node, descend, in_list) {\n                    if (node instanceof AST_Definitions) {\n                        if (defs === node) return node;\n                        if (defs.TYPE != node.TYPE) return node;\n                        var parent = this.parent();\n                        if (parent instanceof AST_ForIn && parent.init === node) return node;\n                        if (!declarations_only(node)) return node;\n                        defs.definitions = defs.definitions.concat(node.definitions);\n                        CHANGED = true;\n                        if (parent instanceof AST_For && parent.init === node) return null;\n                        return in_list ? List.skip : make_node(AST_EmptyStatement, node);\n                    }\n                    if (node instanceof AST_Scope) return node;\n                    if (!(node instanceof AST_Statement)) return node;\n                }));\n            }\n        }\n    }\n\n    function extract_declarations_from_unreachable_code(compressor, stat, target) {\n        if (!(stat instanceof AST_Definitions || is_defun(stat))) {\n            AST_Node.warn(\"Dropping unreachable code [{file}:{line},{col}]\", stat.start);\n        }\n        var block;\n        stat.walk(new TreeWalker(function(node, descend) {\n            if (node instanceof AST_Definitions) {\n                var defns = [];\n                if (node.remove_initializers(compressor, defns)) {\n                    AST_Node.warn(\"Dropping initialization in unreachable code [{file}:{line},{col}]\", node.start);\n                }\n                if (defns.length > 0) {\n                    node.definitions = defns;\n                    push(node);\n                }\n                return true;\n            }\n            if (is_defun(node)) {\n                push(node);\n                return true;\n            }\n            if (node instanceof AST_Scope) return true;\n            if (node instanceof AST_BlockScope) {\n                var save = block;\n                block = [];\n                descend();\n                if (block.required) {\n                    target.push(make_node(AST_BlockStatement, stat, {\n                        body: block\n                    }));\n                } else if (block.length) {\n                    [].push.apply(target, block);\n                }\n                block = save;\n                return true;\n            }\n        }));\n        function push(node) {\n            if (block) {\n                block.push(node);\n                if (node instanceof AST_Const || node instanceof AST_Let) block.required = true;\n            } else {\n                target.push(node);\n            }\n        }\n    }\n\n    function is_undefined(node, compressor) {\n        return node.is_undefined\n            || node instanceof AST_Undefined\n            || node instanceof AST_UnaryPrefix\n                && node.operator == \"void\"\n                && !(compressor && node.expression.has_side_effects(compressor));\n    }\n\n    // is_truthy()\n    // return true if `!!node === true`\n    (function(def) {\n        def(AST_Node, return_false);\n        def(AST_Array, return_true);\n        def(AST_Assign, function() {\n            return this.operator == \"=\" && this.right.is_truthy();\n        });\n        def(AST_Lambda, return_true);\n        def(AST_Object, return_true);\n        def(AST_RegExp, return_true);\n        def(AST_Sequence, function() {\n            return this.tail_node().is_truthy();\n        });\n        def(AST_SymbolRef, function() {\n            var fixed = this.fixed_value();\n            if (!fixed) return false;\n            this.is_truthy = return_false;\n            var result = fixed.is_truthy();\n            delete this.is_truthy;\n            return result;\n        });\n    })(function(node, func) {\n        node.DEFMETHOD(\"is_truthy\", func);\n    });\n\n    // is_negative_zero()\n    // return true if the node may represent -0\n    (function(def) {\n        def(AST_Node, return_true);\n        def(AST_Array, return_false);\n        function binary(op, left, right) {\n            switch (op) {\n              case \"-\":\n                return left.is_negative_zero()\n                    && (!(right instanceof AST_Constant) || right.value == 0);\n              case \"&&\":\n              case \"||\":\n                return left.is_negative_zero() || right.is_negative_zero();\n              case \"*\":\n              case \"/\":\n              case \"%\":\n                return true;\n              default:\n                return false;\n            }\n        }\n        def(AST_Assign, function() {\n            var op = this.operator;\n            if (op == \"=\") return this.right.is_negative_zero();\n            return binary(op.slice(0, -1), this.left, this.right);\n        });\n        def(AST_Binary, function() {\n            return binary(this.operator, this.left, this.right);\n        });\n        def(AST_Constant, function() {\n            return this.value == 0 && 1 / this.value < 0;\n        });\n        def(AST_Lambda, return_false);\n        def(AST_Object, return_false);\n        def(AST_RegExp, return_false);\n        def(AST_Sequence, function() {\n            return this.tail_node().is_negative_zero();\n        });\n        def(AST_SymbolRef, function() {\n            var fixed = this.fixed_value();\n            if (!fixed) return true;\n            this.is_negative_zero = return_true;\n            var result = fixed.is_negative_zero();\n            delete this.is_negative_zero;\n            return result;\n        });\n        def(AST_UnaryPrefix, function() {\n            return this.operator == \"+\" && this.expression.is_negative_zero()\n                || this.operator == \"-\";\n        });\n    })(function(node, func) {\n        node.DEFMETHOD(\"is_negative_zero\", func);\n    });\n\n    // may_throw_on_access()\n    // returns true if this node may be null, undefined or contain `AST_Accessor`\n    (function(def) {\n        AST_Node.DEFMETHOD(\"may_throw_on_access\", function(compressor) {\n            return !compressor.option(\"pure_getters\") || this._dot_throw(compressor);\n        });\n        function is_strict(compressor) {\n            return /strict/.test(compressor.option(\"pure_getters\"));\n        }\n        def(AST_Node, is_strict);\n        def(AST_Array, return_false);\n        def(AST_Assign, function(compressor) {\n            if (this.operator != \"=\") return false;\n            var rhs = this.right;\n            if (!rhs._dot_throw(compressor)) return false;\n            var sym = this.left;\n            if (!(sym instanceof AST_SymbolRef)) return true;\n            if (rhs instanceof AST_Binary && rhs.operator == \"||\" && sym.name == rhs.left.name) {\n                return rhs.right._dot_throw(compressor);\n            }\n            return true;\n        });\n        def(AST_Binary, function(compressor) {\n            switch (this.operator) {\n              case \"&&\":\n                return this.left._dot_throw(compressor) || this.right._dot_throw(compressor);\n              case \"||\":\n                return this.right._dot_throw(compressor);\n              default:\n                return false;\n            }\n        });\n        def(AST_Conditional, function(compressor) {\n            return this.consequent._dot_throw(compressor) || this.alternative._dot_throw(compressor);\n        });\n        def(AST_Constant, return_false);\n        def(AST_Dot, function(compressor) {\n            if (!is_strict(compressor)) return false;\n            var exp = this.expression;\n            if (exp instanceof AST_SymbolRef) exp = exp.fixed_value();\n            return !(exp instanceof AST_Lambda && this.property == \"prototype\");\n        });\n        def(AST_Lambda, return_false);\n        def(AST_Null, return_true);\n        def(AST_Object, function(compressor) {\n            return is_strict(compressor) && !all(this.properties, function(prop) {\n                return prop instanceof AST_ObjectKeyVal;\n            });\n        });\n        def(AST_Sequence, function(compressor) {\n            return this.tail_node()._dot_throw(compressor);\n        });\n        def(AST_SymbolRef, function(compressor) {\n            if (this.is_undefined) return true;\n            if (!is_strict(compressor)) return false;\n            if (is_undeclared_ref(this) && this.is_declared(compressor)) return false;\n            if (this.is_immutable()) return false;\n            var def = this.definition();\n            if (is_arguments(def) && all(def.scope.argnames, function(argname) {\n                return argname instanceof AST_SymbolFunarg;\n            })) return def.scope.uses_arguments > 2;\n            var fixed = this.fixed_value();\n            if (!fixed) return true;\n            this._dot_throw = return_true;\n            if (fixed._dot_throw(compressor)) {\n                delete this._dot_throw;\n                return true;\n            }\n            this._dot_throw = return_false;\n            return false;\n        });\n        def(AST_This, function(compressor) {\n            return is_strict(compressor) && !this.scope.new;\n        });\n        def(AST_UnaryPrefix, function() {\n            return this.operator == \"void\";\n        });\n        def(AST_UnaryPostfix, return_false);\n        def(AST_Undefined, return_true);\n    })(function(node, func) {\n        node.DEFMETHOD(\"_dot_throw\", func);\n    });\n\n    (function(def) {\n        def(AST_Node, return_false);\n        def(AST_Array, return_true);\n        def(AST_Assign, function(compressor) {\n            return this.operator != \"=\" || this.right.is_defined(compressor);\n        });\n        def(AST_Binary, function(compressor) {\n            switch (this.operator) {\n              case \"&&\":\n                return this.left.is_defined(compressor) && this.right.is_defined(compressor);\n              case \"||\":\n                return this.left.is_truthy() || this.right.is_defined(compressor);\n              default:\n                return true;\n            }\n        });\n        def(AST_Conditional, function(compressor) {\n            return this.consequent.is_defined(compressor) && this.alternative.is_defined(compressor);\n        });\n        def(AST_Constant, return_true);\n        def(AST_Hole, return_false);\n        def(AST_Lambda, return_true);\n        def(AST_Object, return_true);\n        def(AST_Sequence, function(compressor) {\n            return this.tail_node().is_defined(compressor);\n        });\n        def(AST_SymbolRef, function(compressor) {\n            if (this.is_undefined) return false;\n            if (is_undeclared_ref(this) && this.is_declared(compressor)) return true;\n            if (this.is_immutable()) return true;\n            var fixed = this.fixed_value();\n            if (!fixed) return false;\n            this.is_defined = return_false;\n            var result = fixed.is_defined(compressor);\n            delete this.is_defined;\n            return result;\n        });\n        def(AST_UnaryPrefix, function() {\n            return this.operator != \"void\";\n        });\n        def(AST_UnaryPostfix, return_true);\n        def(AST_Undefined, return_false);\n    })(function(node, func) {\n        node.DEFMETHOD(\"is_defined\", func);\n    });\n\n    /* -----[ boolean/negation helpers ]----- */\n\n    // methods to determine whether an expression has a boolean result type\n    (function(def) {\n        def(AST_Node, return_false);\n        def(AST_Assign, function(compressor) {\n            return this.operator == \"=\" && this.right.is_boolean(compressor);\n        });\n        var binary = makePredicate(\"in instanceof == != === !== < <= >= >\");\n        def(AST_Binary, function(compressor) {\n            return binary[this.operator] || lazy_op[this.operator]\n                && this.left.is_boolean(compressor)\n                && this.right.is_boolean(compressor);\n        });\n        def(AST_Boolean, return_true);\n        var fn = makePredicate(\"every hasOwnProperty isPrototypeOf propertyIsEnumerable some\");\n        def(AST_Call, function(compressor) {\n            if (!compressor.option(\"unsafe\")) return false;\n            var exp = this.expression;\n            return exp instanceof AST_Dot && (fn[exp.property]\n                || exp.property == \"test\" && exp.expression instanceof AST_RegExp);\n        });\n        def(AST_Conditional, function(compressor) {\n            return this.consequent.is_boolean(compressor) && this.alternative.is_boolean(compressor);\n        });\n        def(AST_New, return_false);\n        def(AST_Sequence, function(compressor) {\n            return this.tail_node().is_boolean(compressor);\n        });\n        def(AST_SymbolRef, function(compressor) {\n            var fixed = this.fixed_value();\n            if (!fixed) return false;\n            this.is_boolean = return_false;\n            var result = fixed.is_boolean(compressor);\n            delete this.is_boolean;\n            return result;\n        });\n        var unary = makePredicate(\"! delete\");\n        def(AST_UnaryPrefix, function() {\n            return unary[this.operator];\n        });\n    })(function(node, func) {\n        node.DEFMETHOD(\"is_boolean\", func);\n    });\n\n    // methods to determine if an expression has a numeric result type\n    (function(def) {\n        def(AST_Node, return_false);\n        var binary = makePredicate(\"- * / % & | ^ << >> >>>\");\n        def(AST_Assign, function(compressor) {\n            return binary[this.operator.slice(0, -1)]\n                || this.operator == \"=\" && this.right.is_number(compressor);\n        });\n        def(AST_Binary, function(compressor) {\n            if (binary[this.operator]) return true;\n            if (this.operator != \"+\") return false;\n            return (this.left.is_boolean(compressor) || this.left.is_number(compressor))\n                && (this.right.is_boolean(compressor) || this.right.is_number(compressor));\n        });\n        var fn = makePredicate([\n            \"charCodeAt\",\n            \"getDate\",\n            \"getDay\",\n            \"getFullYear\",\n            \"getHours\",\n            \"getMilliseconds\",\n            \"getMinutes\",\n            \"getMonth\",\n            \"getSeconds\",\n            \"getTime\",\n            \"getTimezoneOffset\",\n            \"getUTCDate\",\n            \"getUTCDay\",\n            \"getUTCFullYear\",\n            \"getUTCHours\",\n            \"getUTCMilliseconds\",\n            \"getUTCMinutes\",\n            \"getUTCMonth\",\n            \"getUTCSeconds\",\n            \"getYear\",\n            \"indexOf\",\n            \"lastIndexOf\",\n            \"localeCompare\",\n            \"push\",\n            \"search\",\n            \"setDate\",\n            \"setFullYear\",\n            \"setHours\",\n            \"setMilliseconds\",\n            \"setMinutes\",\n            \"setMonth\",\n            \"setSeconds\",\n            \"setTime\",\n            \"setUTCDate\",\n            \"setUTCFullYear\",\n            \"setUTCHours\",\n            \"setUTCMilliseconds\",\n            \"setUTCMinutes\",\n            \"setUTCMonth\",\n            \"setUTCSeconds\",\n            \"setYear\",\n            \"toExponential\",\n            \"toFixed\",\n            \"toPrecision\",\n        ]);\n        def(AST_Call, function(compressor) {\n            if (!compressor.option(\"unsafe\")) return false;\n            var exp = this.expression;\n            return exp instanceof AST_Dot && (fn[exp.property]\n                || is_undeclared_ref(exp.expression) && exp.expression.name == \"Math\");\n        });\n        def(AST_Conditional, function(compressor) {\n            return this.consequent.is_number(compressor) && this.alternative.is_number(compressor);\n        });\n        def(AST_New, return_false);\n        def(AST_Number, return_true);\n        def(AST_Sequence, function(compressor) {\n            return this.tail_node().is_number(compressor);\n        });\n        def(AST_SymbolRef, function(compressor) {\n            var fixed = this.fixed_value();\n            if (!fixed) return false;\n            this.is_number = return_false;\n            var result = fixed.is_number(compressor);\n            delete this.is_number;\n            return result;\n        });\n        var unary = makePredicate(\"+ - ~ ++ --\");\n        def(AST_Unary, function() {\n            return unary[this.operator];\n        });\n    })(function(node, func) {\n        node.DEFMETHOD(\"is_number\", func);\n    });\n\n    // methods to determine if an expression has a string result type\n    (function(def) {\n        def(AST_Node, return_false);\n        def(AST_Assign, function(compressor) {\n            switch (this.operator) {\n              case \"+=\":\n                if (this.left.is_string(compressor)) return true;\n              case \"=\":\n                return this.right.is_string(compressor);\n            }\n        });\n        def(AST_Binary, function(compressor) {\n            return this.operator == \"+\" &&\n                (this.left.is_string(compressor) || this.right.is_string(compressor));\n        });\n        var fn = makePredicate([\n            \"charAt\",\n            \"substr\",\n            \"substring\",\n            \"toLowerCase\",\n            \"toString\",\n            \"toUpperCase\",\n            \"trim\",\n        ]);\n        def(AST_Call, function(compressor) {\n            if (!compressor.option(\"unsafe\")) return false;\n            var exp = this.expression;\n            return exp instanceof AST_Dot && fn[exp.property];\n        });\n        def(AST_Conditional, function(compressor) {\n            return this.consequent.is_string(compressor) && this.alternative.is_string(compressor);\n        });\n        def(AST_Sequence, function(compressor) {\n            return this.tail_node().is_string(compressor);\n        });\n        def(AST_String, return_true);\n        def(AST_SymbolRef, function(compressor) {\n            var fixed = this.fixed_value();\n            if (!fixed) return false;\n            this.is_string = return_false;\n            var result = fixed.is_string(compressor);\n            delete this.is_string;\n            return result;\n        });\n        def(AST_UnaryPrefix, function() {\n            return this.operator == \"typeof\";\n        });\n    })(function(node, func) {\n        node.DEFMETHOD(\"is_string\", func);\n    });\n\n    var lazy_op = makePredicate(\"&& ||\");\n\n    function is_lhs(node, parent) {\n        if (parent instanceof AST_Assign) return parent.left === node && node;\n        if (parent instanceof AST_DefaultValue) return parent.name === node && node;\n        if (parent instanceof AST_Destructured) return node;\n        if (parent instanceof AST_DestructuredKeyVal) return node;\n        if (parent instanceof AST_Unary) return unary_side_effects[parent.operator] && parent.expression;\n    }\n\n    (function(def) {\n        function to_node(value, orig) {\n            if (value instanceof AST_Node) return value.clone(true);\n            if (Array.isArray(value)) return make_node(AST_Array, orig, {\n                elements: value.map(function(value) {\n                    return to_node(value, orig);\n                })\n            });\n            if (value && typeof value == \"object\") {\n                var props = [];\n                for (var key in value) if (HOP(value, key)) {\n                    props.push(make_node(AST_ObjectKeyVal, orig, {\n                        key: key,\n                        value: to_node(value[key], orig)\n                    }));\n                }\n                return make_node(AST_Object, orig, {\n                    properties: props\n                });\n            }\n            return make_node_from_constant(value, orig);\n        }\n\n        function warn(node) {\n            AST_Node.warn(\"global_defs {node} redefined [{file}:{line},{col}]\", {\n                node: node,\n                file: node.start.file,\n                line: node.start.line,\n                col: node.start.col,\n            });\n        }\n\n        AST_Toplevel.DEFMETHOD(\"resolve_defines\", function(compressor) {\n            if (!compressor.option(\"global_defs\")) return this;\n            this.figure_out_scope({ ie8: compressor.option(\"ie8\") });\n            return this.transform(new TreeTransformer(function(node) {\n                var def = node._find_defs(compressor, \"\");\n                if (!def) return;\n                var level = 0, child = node, parent;\n                while (parent = this.parent(level++)) {\n                    if (!(parent instanceof AST_PropAccess)) break;\n                    if (parent.expression !== child) break;\n                    child = parent;\n                }\n                if (is_lhs(child, parent)) {\n                    warn(node);\n                    return;\n                }\n                return def;\n            }));\n        });\n        def(AST_Node, noop);\n        def(AST_Dot, function(compressor, suffix) {\n            return this.expression._find_defs(compressor, \".\" + this.property + suffix);\n        });\n        def(AST_SymbolDeclaration, function(compressor) {\n            if (!this.definition().global) return;\n            if (HOP(compressor.option(\"global_defs\"), this.name)) warn(this);\n        });\n        def(AST_SymbolRef, function(compressor, suffix) {\n            if (!this.definition().global) return;\n            var defines = compressor.option(\"global_defs\");\n            var name = this.name + suffix;\n            if (HOP(defines, name)) return to_node(defines[name], this);\n        });\n    })(function(node, func) {\n        node.DEFMETHOD(\"_find_defs\", func);\n    });\n\n    function best_of_expression(ast1, ast2, threshold) {\n        var delta = ast2.print_to_string().length - ast1.print_to_string().length;\n        return delta < (threshold || 0) ? ast2 : ast1;\n    }\n\n    function best_of_statement(ast1, ast2, threshold) {\n        return best_of_expression(make_node(AST_SimpleStatement, ast1, {\n            body: ast1\n        }), make_node(AST_SimpleStatement, ast2, {\n            body: ast2\n        }), threshold).body;\n    }\n\n    function best_of(compressor, ast1, ast2, threshold) {\n        return (first_in_statement(compressor) ? best_of_statement : best_of_expression)(ast1, ast2, threshold);\n    }\n\n    function convert_to_predicate(obj) {\n        var map = Object.create(null);\n        Object.keys(obj).forEach(function(key) {\n            map[key] = makePredicate(obj[key]);\n        });\n        return map;\n    }\n\n    function skip_directives(body) {\n        for (var i = 0; i < body.length; i++) {\n            var stat = body[i];\n            if (!(stat instanceof AST_Directive)) return stat;\n        }\n    }\n    AST_Arrow.DEFMETHOD(\"first_statement\", function() {\n        if (this.value) return make_node(AST_Return, this.value, {\n            value: this.value\n        });\n        return skip_directives(this.body);\n    });\n    AST_Lambda.DEFMETHOD(\"first_statement\", function() {\n        return skip_directives(this.body);\n    });\n\n    function try_evaluate(compressor, node) {\n        var ev = node.evaluate(compressor);\n        if (ev === node) return node;\n        ev = make_node_from_constant(ev, node).optimize(compressor);\n        return best_of(compressor, node, ev, compressor.eval_threshold);\n    }\n\n    var object_fns = [\n        \"constructor\",\n        \"toString\",\n        \"valueOf\",\n    ];\n    var native_fns = convert_to_predicate({\n        Array: [\n            \"indexOf\",\n            \"join\",\n            \"lastIndexOf\",\n            \"slice\",\n        ].concat(object_fns),\n        Boolean: object_fns,\n        Function: object_fns,\n        Number: [\n            \"toExponential\",\n            \"toFixed\",\n            \"toPrecision\",\n        ].concat(object_fns),\n        Object: object_fns,\n        RegExp: [\n            \"exec\",\n            \"test\",\n        ].concat(object_fns),\n        String: [\n            \"charAt\",\n            \"charCodeAt\",\n            \"concat\",\n            \"indexOf\",\n            \"italics\",\n            \"lastIndexOf\",\n            \"match\",\n            \"replace\",\n            \"search\",\n            \"slice\",\n            \"split\",\n            \"substr\",\n            \"substring\",\n            \"toLowerCase\",\n            \"toUpperCase\",\n            \"trim\",\n        ].concat(object_fns),\n    });\n    var static_fns = convert_to_predicate({\n        Array: [\n            \"isArray\",\n        ],\n        Math: [\n            \"abs\",\n            \"acos\",\n            \"asin\",\n            \"atan\",\n            \"ceil\",\n            \"cos\",\n            \"exp\",\n            \"floor\",\n            \"log\",\n            \"round\",\n            \"sin\",\n            \"sqrt\",\n            \"tan\",\n            \"atan2\",\n            \"pow\",\n            \"max\",\n            \"min\",\n        ],\n        Number: [\n            \"isFinite\",\n            \"isNaN\",\n        ],\n        Object: [\n            \"create\",\n            \"getOwnPropertyDescriptor\",\n            \"getOwnPropertyNames\",\n            \"getPrototypeOf\",\n            \"isExtensible\",\n            \"isFrozen\",\n            \"isSealed\",\n            \"keys\",\n        ],\n        String: [\n            \"fromCharCode\",\n        ],\n    });\n\n    // Accomodate when compress option evaluate=false\n    // as well as the common constant expressions !0 and -1\n    (function(def) {\n        def(AST_Node, return_false);\n        def(AST_Constant, return_true);\n        def(AST_RegExp, return_false);\n        var unaryPrefix = makePredicate(\"! ~ - + void\");\n        def(AST_UnaryPrefix, function() {\n            return unaryPrefix[this.operator] && this.expression instanceof AST_Constant;\n        });\n    })(function(node, func) {\n        node.DEFMETHOD(\"is_constant\", func);\n    });\n\n    // methods to evaluate a constant expression\n    (function(def) {\n        // If the node has been successfully reduced to a constant,\n        // then its value is returned; otherwise the element itself\n        // is returned.\n        //\n        // They can be distinguished as constant value is never a\n        // descendant of AST_Node.\n        //\n        // When `ignore_side_effects` is `true`, inspect the constant value\n        // produced without worrying about any side effects caused by said\n        // expression.\n        AST_Node.DEFMETHOD(\"evaluate\", function(compressor, ignore_side_effects) {\n            if (!compressor.option(\"evaluate\")) return this;\n            var cached = [];\n            var val = this._eval(compressor, ignore_side_effects, cached, 1);\n            cached.forEach(function(node) {\n                delete node._eval;\n            });\n            if (ignore_side_effects) return val;\n            if (!val || val instanceof RegExp) return val;\n            if (typeof val == \"function\" || typeof val == \"object\") return this;\n            return val;\n        });\n        var scan_modified = new TreeWalker(function(node) {\n            if (node instanceof AST_Assign) modified(node.left);\n            if (node instanceof AST_Unary && UNARY_POSTFIX[node.operator]) modified(node.expression);\n        });\n        function modified(node) {\n            if (node instanceof AST_PropAccess) {\n                modified(node.expression);\n            } else if (node instanceof AST_SymbolRef) {\n                node.definition().references.forEach(function(ref) {\n                    delete ref._eval;\n                });\n            }\n        }\n        def(AST_Statement, function() {\n            throw new Error(string_template(\"Cannot evaluate a statement [{file}:{line},{col}]\", this.start));\n        });\n        def(AST_Accessor, return_this);\n        def(AST_Node, return_this);\n        def(AST_Constant, function() {\n            return this.value;\n        });\n        def(AST_Assign, function(compressor, ignore_side_effects, cached, depth) {\n            var lhs = this.left;\n            if (!ignore_side_effects) {\n                if (!(lhs instanceof AST_SymbolRef)) return this;\n                if (!HOP(lhs, \"_eval\")) {\n                    if (!lhs.fixed) return this;\n                    var def = lhs.definition();\n                    if (!def.fixed) return this;\n                    if (def.undeclared) return this;\n                    if (def.last_ref !== lhs) return this;\n                    if (def.single_use == \"m\") return this;\n                }\n            }\n            var op = this.operator;\n            var node;\n            if (!HOP(lhs, \"_eval\") && lhs instanceof AST_SymbolRef && lhs.fixed && lhs.definition().fixed) {\n                node = lhs;\n            } else if (op == \"=\") {\n                lhs.walk(scan_modified);\n                node = this.right;\n            } else {\n                node = make_node(AST_Binary, this, {\n                    operator: op.slice(0, -1),\n                    left: lhs,\n                    right: this.right,\n                });\n            }\n            var value = node._eval(compressor, ignore_side_effects, cached, depth);\n            if (typeof value == \"object\") return this;\n            modified(lhs);\n            return value;\n        });\n        def(AST_Sequence, function(compressor, ignore_side_effects, cached, depth) {\n            if (!ignore_side_effects) return this;\n            var exprs = this.expressions;\n            for (var i = 0, last = exprs.length - 1; i < last; i++) {\n                exprs[i].walk(scan_modified);\n            }\n            var tail = exprs[last];\n            var value = tail._eval(compressor, ignore_side_effects, cached, depth);\n            return value === tail ? this : value;\n        });\n        def(AST_Lambda, function(compressor) {\n            if (compressor.option(\"unsafe\")) {\n                var fn = function() {};\n                fn.node = this;\n                fn.toString = function() {\n                    return \"function(){}\";\n                };\n                return fn;\n            }\n            return this;\n        });\n        def(AST_Array, function(compressor, ignore_side_effects, cached, depth) {\n            if (compressor.option(\"unsafe\")) {\n                var elements = [];\n                for (var i = 0; i < this.elements.length; i++) {\n                    var element = this.elements[i];\n                    if (element instanceof AST_Hole) return this;\n                    var value = element._eval(compressor, ignore_side_effects, cached, depth);\n                    if (element === value) return this;\n                    elements.push(value);\n                }\n                return elements;\n            }\n            return this;\n        });\n        def(AST_Object, function(compressor, ignore_side_effects, cached, depth) {\n            if (compressor.option(\"unsafe\")) {\n                var val = {};\n                for (var i = 0; i < this.properties.length; i++) {\n                    var prop = this.properties[i];\n                    if (!(prop instanceof AST_ObjectKeyVal)) return this;\n                    var key = prop.key;\n                    if (key instanceof AST_Node) {\n                        key = key._eval(compressor, ignore_side_effects, cached, depth);\n                        if (key === prop.key) return this;\n                    }\n                    if (prop.value instanceof AST_Function && typeof Object.prototype[key] == \"function\") return this;\n                    val[key] = prop.value._eval(compressor, ignore_side_effects, cached, depth);\n                    if (val[key] === prop.value) return this;\n                }\n                return val;\n            }\n            return this;\n        });\n        var non_converting_unary = makePredicate(\"! typeof void\");\n        def(AST_UnaryPrefix, function(compressor, ignore_side_effects, cached, depth) {\n            var e = this.expression;\n            var op = this.operator;\n            // Function would be evaluated to an array and so typeof would\n            // incorrectly return \"object\". Hence making is a special case.\n            if (compressor.option(\"typeofs\")\n                && op == \"typeof\"\n                && (e instanceof AST_Lambda\n                    || e instanceof AST_SymbolRef\n                        && e.fixed_value() instanceof AST_Lambda)) {\n                return typeof function(){};\n            }\n            var def = e instanceof AST_SymbolRef && e.definition();\n            if (!non_converting_unary[op] && !(def && def.fixed)) depth++;\n            var v = e._eval(compressor, ignore_side_effects, cached, depth);\n            if (v === e) {\n                if (ignore_side_effects && op == \"void\") return;\n                return this;\n            }\n            switch (op) {\n              case \"!\": return !v;\n              case \"typeof\":\n                // typeof <RegExp> returns \"object\" or \"function\" on different platforms\n                // so cannot evaluate reliably\n                if (v instanceof RegExp) return this;\n                return typeof v;\n              case \"void\": return;\n              case \"~\": return ~v;\n              case \"-\": return -v;\n              case \"+\": return +v;\n              case \"++\":\n              case \"--\":\n                if (!def) return this;\n                if (!ignore_side_effects) {\n                    if (def.undeclared) return this;\n                    if (def.last_ref !== e) return this;\n                }\n                if (HOP(e, \"_eval\")) v = +(op[0] + 1) + +v;\n                modified(e);\n                return v;\n            }\n            return this;\n        });\n        def(AST_UnaryPostfix, function(compressor, ignore_side_effects, cached, depth) {\n            var e = this.expression;\n            if (!(e instanceof AST_SymbolRef)) {\n                if (!ignore_side_effects) return this;\n            } else if (!HOP(e, \"_eval\")) {\n                if (!e.fixed) return this;\n                if (!ignore_side_effects) {\n                    var def = e.definition();\n                    if (!def.fixed) return this;\n                    if (def.undeclared) return this;\n                    if (def.last_ref !== e) return this;\n                }\n            }\n            if (!(e instanceof AST_SymbolRef && e.definition().fixed)) depth++;\n            var v = e._eval(compressor, ignore_side_effects, cached, depth);\n            if (v === e) return this;\n            modified(e);\n            return +v;\n        });\n        var non_converting_binary = makePredicate(\"&& || === !==\");\n        def(AST_Binary, function(compressor, ignore_side_effects, cached, depth) {\n            if (!non_converting_binary[this.operator]) depth++;\n            var left = this.left._eval(compressor, ignore_side_effects, cached, depth);\n            if (left === this.left) return this;\n            if (this.operator == (left ? \"||\" : \"&&\")) return left;\n            var rhs_ignore_side_effects = ignore_side_effects && !(left && typeof left == \"object\");\n            var right = this.right._eval(compressor, rhs_ignore_side_effects, cached, depth);\n            if (right === this.right) return this;\n            var result;\n            switch (this.operator) {\n              case \"&&\" : result = left &&  right; break;\n              case \"||\" : result = left ||  right; break;\n              case \"|\"  : result = left |   right; break;\n              case \"&\"  : result = left &   right; break;\n              case \"^\"  : result = left ^   right; break;\n              case \"+\"  : result = left +   right; break;\n              case \"-\"  : result = left -   right; break;\n              case \"*\"  : result = left *   right; break;\n              case \"/\"  : result = left /   right; break;\n              case \"%\"  : result = left %   right; break;\n              case \"<<\" : result = left <<  right; break;\n              case \">>\" : result = left >>  right; break;\n              case \">>>\": result = left >>> right; break;\n              case \"==\" : result = left ==  right; break;\n              case \"===\": result = left === right; break;\n              case \"!=\" : result = left !=  right; break;\n              case \"!==\": result = left !== right; break;\n              case \"<\"  : result = left <   right; break;\n              case \"<=\" : result = left <=  right; break;\n              case \">\"  : result = left >   right; break;\n              case \">=\" : result = left >=  right; break;\n              case \"in\":\n                if (right && typeof right == \"object\" && HOP(right, left)) {\n                    result = true;\n                    break;\n                }\n              default:\n                return this;\n            }\n            if (isNaN(result)) return compressor.find_parent(AST_With) ? this : result;\n            if (compressor.option(\"unsafe_math\")\n                && !ignore_side_effects\n                && result\n                && typeof result == \"number\"\n                && (this.operator == \"+\" || this.operator == \"-\")) {\n                var digits = Math.max(0, decimals(left), decimals(right));\n                // 53-bit significand => 15.95 decimal places\n                if (digits < 16) return +result.toFixed(digits);\n            }\n            return result;\n\n            function decimals(operand) {\n                var match = /(\\.[0-9]*)?(e.+)?$/.exec(+operand);\n                return (match[1] || \".\").length - 1 - (match[2] || \"\").slice(1);\n            }\n        });\n        def(AST_Conditional, function(compressor, ignore_side_effects, cached, depth) {\n            var condition = this.condition._eval(compressor, ignore_side_effects, cached, depth);\n            if (condition === this.condition) return this;\n            var node = condition ? this.consequent : this.alternative;\n            var value = node._eval(compressor, ignore_side_effects, cached, depth);\n            return value === node ? this : value;\n        });\n        function verify_escaped(ref, depth) {\n            var escaped = ref.definition().escaped;\n            switch (escaped.length) {\n              case 0:\n                return true;\n              case 1:\n                var found = false;\n                escaped[0].walk(new TreeWalker(function(node) {\n                    if (found) return true;\n                    if (node === ref) return found = true;\n                    if (node instanceof AST_Scope) return true;\n                }));\n                return found;\n              default:\n                return depth <= escaped.depth;\n            }\n        }\n        def(AST_SymbolRef, function(compressor, ignore_side_effects, cached, depth) {\n            var fixed = this.fixed_value();\n            if (!fixed) return this;\n            var value;\n            if (HOP(fixed, \"_eval\")) {\n                value = fixed._eval();\n            } else {\n                this._eval = return_this;\n                value = fixed._eval(compressor, ignore_side_effects, cached, depth);\n                delete this._eval;\n                if (value === fixed) return this;\n                fixed._eval = function() {\n                    return value;\n                };\n                cached.push(fixed);\n            }\n            return value && typeof value == \"object\" && !verify_escaped(this, depth) ? this : value;\n        });\n        var global_objs = {\n            Array: Array,\n            Math: Math,\n            Number: Number,\n            Object: Object,\n            String: String,\n        };\n        var static_values = convert_to_predicate({\n            Math: [\n                \"E\",\n                \"LN10\",\n                \"LN2\",\n                \"LOG2E\",\n                \"LOG10E\",\n                \"PI\",\n                \"SQRT1_2\",\n                \"SQRT2\",\n            ],\n            Number: [\n                \"MAX_VALUE\",\n                \"MIN_VALUE\",\n                \"NaN\",\n                \"NEGATIVE_INFINITY\",\n                \"POSITIVE_INFINITY\",\n            ],\n        });\n        var regexp_props = makePredicate(\"global ignoreCase multiline source\");\n        def(AST_PropAccess, function(compressor, ignore_side_effects, cached, depth) {\n            if (compressor.option(\"unsafe\")) {\n                var val;\n                var exp = this.expression;\n                if (!is_undeclared_ref(exp)) {\n                    val = exp._eval(compressor, ignore_side_effects, cached, depth + 1);\n                    if (val == null || val === exp) return this;\n                }\n                var key = this.property;\n                if (key instanceof AST_Node) {\n                    key = key._eval(compressor, ignore_side_effects, cached, depth);\n                    if (key === this.property) return this;\n                }\n                if (val === undefined) {\n                    var static_value = static_values[exp.name];\n                    if (!static_value || !static_value[key]) return this;\n                    val = global_objs[exp.name];\n                } else if (val instanceof RegExp) {\n                    if (!regexp_props[key]) return this;\n                } else if (typeof val == \"object\") {\n                    if (!HOP(val, key)) return this;\n                } else if (typeof val == \"function\") switch (key) {\n                  case \"name\":\n                    return val.node.name ? val.node.name.name : \"\";\n                  case \"length\":\n                    return val.node.argnames.length;\n                  default:\n                    return this;\n                }\n                return val[key];\n            }\n            return this;\n        });\n        def(AST_Call, function(compressor, ignore_side_effects, cached, depth) {\n            var exp = this.expression;\n            var fn = exp instanceof AST_SymbolRef ? exp.fixed_value() : exp;\n            if (fn instanceof AST_Defun || fn instanceof AST_Function) {\n                if (fn.evaluating) return this;\n                if (fn.name && fn.name.definition().recursive_refs > 0) return this;\n                if (this.is_expr_pure(compressor)) return this;\n                var args = eval_args(this.args);\n                if (!all(fn.argnames, function(sym, index) {\n                    if (sym instanceof AST_DefaultValue) {\n                        if (!args) return false;\n                        if (args[index] !== undefined) return false;\n                        var value = sym.value._eval(compressor, ignore_side_effects, cached, depth);\n                        if (value === sym.value) return false;\n                        args[index] = value;\n                        sym = sym.name;\n                    }\n                    return !(sym instanceof AST_Destructured);\n                })) return this;\n                if (!args && !ignore_side_effects) return this;\n                var stat = fn.first_statement();\n                if (!(stat instanceof AST_Return)) {\n                    if (ignore_side_effects) {\n                        var found = false;\n                        fn.walk(new TreeWalker(function(node) {\n                            if (found) return true;\n                            if (node instanceof AST_Return) {\n                                if (node.value && node.value._eval(compressor, true, cached, depth) !== undefined) {\n                                    found = true;\n                                }\n                                return true;\n                            }\n                            if (node instanceof AST_Scope && node !== fn) return true;\n                        }));\n                        if (!found) return;\n                    }\n                    return this;\n                }\n                var val = stat.value;\n                if (!val) return;\n                var cached_args = [];\n                if (!args || all(fn.argnames, function(sym, i) {\n                    if (sym instanceof AST_DefaultValue) sym = sym.name;\n                    var def = sym.definition();\n                    if (def.orig[def.orig.length - 1] !== sym) return false;\n                    var value = args[i];\n                    def.references.forEach(function(node) {\n                        node._eval = function() {\n                            return value;\n                        };\n                        cached_args.push(node);\n                    });\n                    return true;\n                }) || ignore_side_effects) {\n                    fn.evaluating = true;\n                    val = val._eval(compressor, ignore_side_effects, cached, depth);\n                    delete fn.evaluating;\n                }\n                cached_args.forEach(function(node) {\n                    delete node._eval;\n                });\n                return val === stat.value ? this : val;\n            } else if (compressor.option(\"unsafe\") && exp instanceof AST_PropAccess) {\n                var key = exp.property;\n                if (key instanceof AST_Node) {\n                    key = key._eval(compressor, ignore_side_effects, cached, depth);\n                    if (key === exp.property) return this;\n                }\n                var val;\n                var e = exp.expression;\n                if (is_undeclared_ref(e)) {\n                    var static_fn = static_fns[e.name];\n                    if (!static_fn || !static_fn[key]) return this;\n                    val = global_objs[e.name];\n                } else {\n                    val = e._eval(compressor, ignore_side_effects, cached, depth + 1);\n                    if (val == null || val === e) return this;\n                    var native_fn = native_fns[val.constructor.name];\n                    if (!native_fn || !native_fn[key]) return this;\n                    if (val instanceof RegExp && val.global && !(e instanceof AST_RegExp)) return this;\n                }\n                var args = eval_args(this.args);\n                if (!args) return this;\n                if (key == \"replace\" && typeof args[1] == \"function\") return this;\n                try {\n                    return val[key].apply(val, args);\n                } catch (ex) {\n                    AST_Node.warn(\"Error evaluating {code} [{file}:{line},{col}]\", {\n                        code: this,\n                        file: this.start.file,\n                        line: this.start.line,\n                        col: this.start.col,\n                    });\n                } finally {\n                    if (val instanceof RegExp) val.lastIndex = 0;\n                }\n            }\n            return this;\n\n            function eval_args(args) {\n                var values = [];\n                for (var i = 0; i < args.length; i++) {\n                    var arg = args[i];\n                    var value = arg._eval(compressor, ignore_side_effects, cached, depth);\n                    if (arg === value) return;\n                    values.push(value);\n                }\n                return values;\n            }\n        });\n        def(AST_New, return_this);\n    })(function(node, func) {\n        node.DEFMETHOD(\"_eval\", func);\n    });\n\n    // method to negate an expression\n    (function(def) {\n        function basic_negation(exp) {\n            return make_node(AST_UnaryPrefix, exp, {\n                operator: \"!\",\n                expression: exp\n            });\n        }\n        function best(orig, alt, first_in_statement) {\n            var negated = basic_negation(orig);\n            if (first_in_statement) {\n                var stat = make_node(AST_SimpleStatement, alt, {\n                    body: alt\n                });\n                return best_of_expression(negated, stat) === stat ? alt : negated;\n            }\n            return best_of_expression(negated, alt);\n        }\n        def(AST_Node, function() {\n            return basic_negation(this);\n        });\n        def(AST_Statement, function() {\n            throw new Error(\"Cannot negate a statement\");\n        });\n        def(AST_Arrow, function() {\n            return basic_negation(this);\n        });\n        def(AST_AsyncFunction, function() {\n            return basic_negation(this);\n        });\n        def(AST_Function, function() {\n            return basic_negation(this);\n        });\n        def(AST_UnaryPrefix, function() {\n            if (this.operator == \"!\")\n                return this.expression;\n            return basic_negation(this);\n        });\n        def(AST_Sequence, function(compressor) {\n            var expressions = this.expressions.slice();\n            expressions.push(expressions.pop().negate(compressor));\n            return make_sequence(this, expressions);\n        });\n        def(AST_Conditional, function(compressor, first_in_statement) {\n            var self = this.clone();\n            self.consequent = self.consequent.negate(compressor);\n            self.alternative = self.alternative.negate(compressor);\n            return best(this, self, first_in_statement);\n        });\n        def(AST_Binary, function(compressor, first_in_statement) {\n            var self = this.clone(), op = this.operator;\n            if (compressor.option(\"unsafe_comps\")) {\n                switch (op) {\n                  case \"<=\" : self.operator = \">\"  ; return self;\n                  case \"<\"  : self.operator = \">=\" ; return self;\n                  case \">=\" : self.operator = \"<\"  ; return self;\n                  case \">\"  : self.operator = \"<=\" ; return self;\n                }\n            }\n            switch (op) {\n              case \"==\" : self.operator = \"!=\"; return self;\n              case \"!=\" : self.operator = \"==\"; return self;\n              case \"===\": self.operator = \"!==\"; return self;\n              case \"!==\": self.operator = \"===\"; return self;\n              case \"&&\":\n                self.operator = \"||\";\n                self.left = self.left.negate(compressor, first_in_statement);\n                self.right = self.right.negate(compressor);\n                return best(this, self, first_in_statement);\n              case \"||\":\n                self.operator = \"&&\";\n                self.left = self.left.negate(compressor, first_in_statement);\n                self.right = self.right.negate(compressor);\n                return best(this, self, first_in_statement);\n            }\n            return basic_negation(this);\n        });\n    })(function(node, func) {\n        node.DEFMETHOD(\"negate\", function(compressor, first_in_statement) {\n            return func.call(this, compressor, first_in_statement);\n        });\n    });\n\n    var global_pure_fns = makePredicate(\"Boolean decodeURI decodeURIComponent Date encodeURI encodeURIComponent Error escape EvalError isFinite isNaN Number Object parseFloat parseInt RangeError ReferenceError String SyntaxError TypeError unescape URIError\");\n    AST_Call.DEFMETHOD(\"is_expr_pure\", function(compressor) {\n        if (compressor.option(\"unsafe\")) {\n            var expr = this.expression;\n            if (is_undeclared_ref(expr) && global_pure_fns[expr.name]) return true;\n            if (expr instanceof AST_Dot && is_undeclared_ref(expr.expression)) {\n                var static_fn = static_fns[expr.expression.name];\n                return static_fn && (static_fn[expr.property]\n                    || expr.expression.name == \"Math\" && expr.property == \"random\");\n            }\n        }\n        return this.pure || !compressor.pure_funcs(this);\n    });\n    AST_Node.DEFMETHOD(\"is_call_pure\", return_false);\n    AST_Call.DEFMETHOD(\"is_call_pure\", function(compressor) {\n        if (!compressor.option(\"unsafe\")) return false;\n        var dot = this.expression;\n        if (!(dot instanceof AST_Dot)) return false;\n        var exp = dot.expression;\n        var map;\n        var prop = dot.property;\n        if (exp instanceof AST_Array) {\n            map = native_fns.Array;\n        } else if (exp.is_boolean(compressor)) {\n            map = native_fns.Boolean;\n        } else if (exp.is_number(compressor)) {\n            map = native_fns.Number;\n        } else if (exp instanceof AST_RegExp) {\n            map = native_fns.RegExp;\n        } else if (exp.is_string(compressor)) {\n            map = native_fns.String;\n            if (prop == \"replace\") {\n                var arg = this.args[1];\n                if (arg && !arg.is_string(compressor)) return false;\n            }\n        } else if (!dot.may_throw_on_access(compressor)) {\n            map = native_fns.Object;\n        }\n        return map && map[prop];\n    });\n\n    function spread_side_effects(exp) {\n        while ((exp = exp.tail_node()) instanceof AST_SymbolRef) {\n            exp = exp.fixed_value();\n            if (!exp) return true;\n        }\n        return !(exp instanceof AST_Array\n            || exp.TYPE == \"Binary\" && !lazy_op[exp.operator]\n            || exp instanceof AST_Constant\n            || exp instanceof AST_Lambda\n            || exp instanceof AST_Object && all(exp.properties, function(prop) {\n                return !(prop instanceof AST_ObjectGetter || prop instanceof AST_Spread);\n            })\n            || exp instanceof AST_This\n            || exp instanceof AST_Unary);\n    }\n\n    // determine if expression has side effects\n    (function(def) {\n        function any(list, compressor, spread) {\n            return !all(list, spread ? function(node) {\n                return node instanceof AST_Spread ? !spread(node, compressor) : !node.has_side_effects(compressor);\n            } : function(node) {\n                return !node.has_side_effects(compressor);\n            });\n        }\n        function array_spread(node, compressor) {\n            return !node.expression.is_string(compressor) || node.expression.has_side_effects(compressor);\n        }\n        def(AST_Node, return_true);\n        def(AST_Array, function(compressor) {\n            return any(this.elements, compressor, array_spread);\n        });\n        def(AST_Assign, function(compressor) {\n            var lhs = this.left;\n            if (!(lhs instanceof AST_PropAccess)) return true;\n            var node = lhs.expression;\n            return !(node instanceof AST_This)\n                || !node.scope.new\n                || lhs instanceof AST_Sub && lhs.property.has_side_effects(compressor)\n                || this.right.has_side_effects(compressor);\n        });\n        def(AST_Binary, function(compressor) {\n            return this.left.has_side_effects(compressor)\n                || this.right.has_side_effects(compressor)\n                || this.operator == \"in\" && !is_object(this.right);\n        });\n        def(AST_Block, function(compressor) {\n            return any(this.body, compressor);\n        });\n        def(AST_Call, function(compressor) {\n            if (!this.is_expr_pure(compressor)\n                && (!this.is_call_pure(compressor) || this.expression.has_side_effects(compressor))) {\n                return true;\n            }\n            return any(this.args, compressor, array_spread);\n        });\n        def(AST_Case, function(compressor) {\n            return this.expression.has_side_effects(compressor)\n                || any(this.body, compressor);\n        });\n        def(AST_Conditional, function(compressor) {\n            return this.condition.has_side_effects(compressor)\n                || this.consequent.has_side_effects(compressor)\n                || this.alternative.has_side_effects(compressor);\n        });\n        def(AST_Constant, return_false);\n        def(AST_Definitions, function(compressor) {\n            return any(this.definitions, compressor);\n        });\n        def(AST_DestructuredArray, function(compressor) {\n            return any(this.elements, compressor);\n        });\n        def(AST_DestructuredKeyVal, function(compressor) {\n            return this.key instanceof AST_Node && this.key.has_side_effects(compressor)\n                || this.value.has_side_effects(compressor);\n        });\n        def(AST_DestructuredObject, function(compressor) {\n            return any(this.properties, compressor);\n        });\n        def(AST_Dot, function(compressor) {\n            return this.expression.may_throw_on_access(compressor)\n                || this.expression.has_side_effects(compressor);\n        });\n        def(AST_EmptyStatement, return_false);\n        def(AST_If, function(compressor) {\n            return this.condition.has_side_effects(compressor)\n                || this.body && this.body.has_side_effects(compressor)\n                || this.alternative && this.alternative.has_side_effects(compressor);\n        });\n        def(AST_LabeledStatement, function(compressor) {\n            return this.body.has_side_effects(compressor);\n        });\n        def(AST_Lambda, return_false);\n        def(AST_Object, function(compressor) {\n            return any(this.properties, compressor, function(node, compressor) {\n                var exp = node.expression;\n                return spread_side_effects(exp) || exp.has_side_effects(compressor);\n            });\n        });\n        def(AST_ObjectProperty, function(compressor) {\n            return this.key instanceof AST_Node && this.key.has_side_effects(compressor)\n                || this.value.has_side_effects(compressor);\n        });\n        def(AST_Sequence, function(compressor) {\n            return any(this.expressions, compressor);\n        });\n        def(AST_SimpleStatement, function(compressor) {\n            return this.body.has_side_effects(compressor);\n        });\n        def(AST_Sub, function(compressor) {\n            return this.expression.may_throw_on_access(compressor)\n                || this.expression.has_side_effects(compressor)\n                || this.property.has_side_effects(compressor);\n        });\n        def(AST_Switch, function(compressor) {\n            return this.expression.has_side_effects(compressor)\n                || any(this.body, compressor);\n        });\n        def(AST_SymbolDeclaration, return_false);\n        def(AST_SymbolRef, function(compressor) {\n            return !this.is_declared(compressor) || !can_drop_symbol(this);\n        });\n        def(AST_This, return_false);\n        def(AST_Try, function(compressor) {\n            return any(this.body, compressor)\n                || this.bcatch && this.bcatch.has_side_effects(compressor)\n                || this.bfinally && this.bfinally.has_side_effects(compressor);\n        });\n        def(AST_Unary, function(compressor) {\n            return unary_side_effects[this.operator]\n                || this.expression.has_side_effects(compressor);\n        });\n        def(AST_VarDef, function(compressor) {\n            return this.value;\n        });\n    })(function(node, func) {\n        node.DEFMETHOD(\"has_side_effects\", func);\n    });\n\n    // determine if expression may throw\n    (function(def) {\n        def(AST_Node, return_true);\n\n        def(AST_Constant, return_false);\n        def(AST_EmptyStatement, return_false);\n        def(AST_Lambda, return_false);\n        def(AST_SymbolDeclaration, return_false);\n        def(AST_This, return_false);\n\n        function any(list, compressor) {\n            for (var i = list.length; --i >= 0;)\n                if (list[i].may_throw(compressor))\n                    return true;\n            return false;\n        }\n\n        def(AST_Array, function(compressor) {\n            return any(this.elements, compressor);\n        });\n        def(AST_Assign, function(compressor) {\n            if (this.right.may_throw(compressor)) return true;\n            if (!compressor.has_directive(\"use strict\")\n                && this.operator == \"=\"\n                && this.left instanceof AST_SymbolRef) {\n                return false;\n            }\n            return this.left.may_throw(compressor);\n        });\n        def(AST_Binary, function(compressor) {\n            return this.left.may_throw(compressor)\n                || this.right.may_throw(compressor)\n                || this.operator == \"in\" && !is_object(this.right);\n        });\n        def(AST_Block, function(compressor) {\n            return any(this.body, compressor);\n        });\n        def(AST_Call, function(compressor) {\n            if (any(this.args, compressor)) return true;\n            if (this.is_expr_pure(compressor)) return false;\n            if (this.expression.may_throw(compressor)) return true;\n            return !(this.expression instanceof AST_Lambda)\n                || any(this.expression.body, compressor);\n        });\n        def(AST_Case, function(compressor) {\n            return this.expression.may_throw(compressor)\n                || any(this.body, compressor);\n        });\n        def(AST_Conditional, function(compressor) {\n            return this.condition.may_throw(compressor)\n                || this.consequent.may_throw(compressor)\n                || this.alternative.may_throw(compressor);\n        });\n        def(AST_Definitions, function(compressor) {\n            return any(this.definitions, compressor);\n        });\n        def(AST_Dot, function(compressor) {\n            return this.expression.may_throw_on_access(compressor)\n                || this.expression.may_throw(compressor);\n        });\n        def(AST_If, function(compressor) {\n            return this.condition.may_throw(compressor)\n                || this.body && this.body.may_throw(compressor)\n                || this.alternative && this.alternative.may_throw(compressor);\n        });\n        def(AST_LabeledStatement, function(compressor) {\n            return this.body.may_throw(compressor);\n        });\n        def(AST_Object, function(compressor) {\n            return any(this.properties, compressor);\n        });\n        def(AST_ObjectProperty, function(compressor) {\n            return this.key instanceof AST_Node && this.key.may_throw(compressor)\n                || this.value.may_throw(compressor);\n        });\n        def(AST_Return, function(compressor) {\n            return this.value && this.value.may_throw(compressor);\n        });\n        def(AST_Sequence, function(compressor) {\n            return any(this.expressions, compressor);\n        });\n        def(AST_SimpleStatement, function(compressor) {\n            return this.body.may_throw(compressor);\n        });\n        def(AST_Sub, function(compressor) {\n            return this.expression.may_throw_on_access(compressor)\n                || this.expression.may_throw(compressor)\n                || this.property.may_throw(compressor);\n        });\n        def(AST_Switch, function(compressor) {\n            return this.expression.may_throw(compressor)\n                || any(this.body, compressor);\n        });\n        def(AST_SymbolRef, function(compressor) {\n            return !this.is_declared(compressor);\n        });\n        def(AST_Try, function(compressor) {\n            return (this.bcatch ? this.bcatch.may_throw(compressor) : any(this.body, compressor))\n                || this.bfinally && this.bfinally.may_throw(compressor);\n        });\n        def(AST_Unary, function(compressor) {\n            if (this.operator == \"typeof\" && this.expression instanceof AST_SymbolRef)\n                return false;\n            return this.expression.may_throw(compressor);\n        });\n        def(AST_VarDef, function(compressor) {\n            if (!this.value) return false;\n            return this.value.may_throw(compressor);\n        });\n    })(function(node, func) {\n        node.DEFMETHOD(\"may_throw\", func);\n    });\n\n    // determine if expression is constant\n    (function(def) {\n        function all(list) {\n            for (var i = list.length; --i >= 0;)\n                if (!list[i].is_constant_expression())\n                    return false;\n            return true;\n        }\n        def(AST_Node, return_false);\n        def(AST_Array, function() {\n            return all(this.elements);\n        });\n        def(AST_Binary, function() {\n            return this.left.is_constant_expression()\n                && this.right.is_constant_expression()\n                && (this.operator != \"in\" || is_object(this.right));\n        });\n        def(AST_Constant, return_true);\n        def(AST_Lambda, function(scope) {\n            var self = this;\n            var result = true;\n            var scopes = [];\n            self.walk(new TreeWalker(function(node, descend) {\n                if (!result) return true;\n                if (node instanceof AST_BlockScope) {\n                    if (node === self) return;\n                    scopes.push(node);\n                    descend();\n                    scopes.pop();\n                    return true;\n                }\n                if (node instanceof AST_SymbolRef) {\n                    if (self.inlined || node.redef) {\n                        result = false;\n                        return true;\n                    }\n                    if (self.variables.has(node.name)) return true;\n                    var def = node.definition();\n                    if (member(def.scope, scopes)) return true;\n                    if (scope && !def.redefined()) {\n                        var scope_def = scope.find_variable(node.name);\n                        if (def.undeclared ? !scope_def : scope_def === def) {\n                            result = \"f\";\n                            return true;\n                        }\n                    }\n                    result = false;\n                    return true;\n                }\n                if (node instanceof AST_This) {\n                    if (scopes.length == 0 && self instanceof AST_Arrow) result = false;\n                    return true;\n                }\n            }));\n            return result;\n        });\n        def(AST_Object, function() {\n            return all(this.properties);\n        });\n        def(AST_ObjectProperty, function() {\n            return typeof this.key == \"string\" && this.value.is_constant_expression();\n        });\n        def(AST_Unary, function() {\n            return this.expression.is_constant_expression();\n        });\n    })(function(node, func) {\n        node.DEFMETHOD(\"is_constant_expression\", func);\n    });\n\n    // tell me if a statement aborts\n    function aborts(thing) {\n        return thing && thing.aborts();\n    }\n    (function(def) {\n        def(AST_Statement, return_null);\n        def(AST_Jump, return_this);\n        function block_aborts() {\n            var n = this.body.length;\n            return n > 0 && aborts(this.body[n - 1]);\n        }\n        def(AST_BlockStatement, block_aborts);\n        def(AST_SwitchBranch, block_aborts);\n        def(AST_If, function() {\n            return this.alternative && aborts(this.body) && aborts(this.alternative) && this;\n        });\n    })(function(node, func) {\n        node.DEFMETHOD(\"aborts\", func);\n    });\n\n    /* -----[ optimizers ]----- */\n\n    var directives = makePredicate([\"use asm\", \"use strict\"]);\n    OPT(AST_Directive, function(self, compressor) {\n        if (compressor.option(\"directives\")\n            && (!directives[self.value] || compressor.has_directive(self.value) !== self)) {\n            return make_node(AST_EmptyStatement, self);\n        }\n        return self;\n    });\n\n    OPT(AST_Debugger, function(self, compressor) {\n        if (compressor.option(\"drop_debugger\"))\n            return make_node(AST_EmptyStatement, self);\n        return self;\n    });\n\n    OPT(AST_LabeledStatement, function(self, compressor) {\n        if (compressor.option(\"dead_code\")\n            && self.body instanceof AST_Break\n            && compressor.loopcontrol_target(self.body) === self.body) {\n            return make_node(AST_EmptyStatement, self);\n        }\n        return compressor.option(\"unused\") && self.label.references.length == 0 ? self.body : self;\n    });\n\n    OPT(AST_Block, function(self, compressor) {\n        self.body = tighten_body(self.body, compressor);\n        return self;\n    });\n\n    function trim_block(node) {\n        switch (node.body.length) {\n          case 0:\n            return make_node(AST_EmptyStatement, node);\n          case 1:\n            var stat = node.body[0];\n            if (!(stat instanceof AST_Const || stat instanceof AST_Let)) return stat;\n        }\n        return node;\n    }\n\n    OPT(AST_BlockStatement, function(self, compressor) {\n        self.body = tighten_body(self.body, compressor);\n        return trim_block(self);\n    });\n\n    OPT(AST_Arrow, function(self, compressor) {\n        if (!compressor.option(\"arrows\")) return self;\n        var body = tighten_body(self.value ? [ self.first_statement() ] : self.body, compressor);\n        switch (body.length) {\n          case 1:\n            var stat = body[0];\n            if (stat instanceof AST_Return) {\n                self.body.length = 0;\n                self.value = stat.value;\n                break;\n            }\n          default:\n            self.body = body;\n            self.value = null;\n            break;\n        }\n        return self;\n    });\n\n    OPT(AST_Function, function(self, compressor) {\n        self.body = tighten_body(self.body, compressor);\n        if (compressor.option(\"inline\")) for (var i = 0; i < self.body.length; i++) {\n            var stat = self.body[i];\n            if (stat instanceof AST_Directive) continue;\n            if (stat instanceof AST_Return) {\n                var call = stat.value;\n                if (!call || call.TYPE != \"Call\") break;\n                if (call.is_expr_pure(compressor)) break;\n                var fn = call.expression;\n                if (fn instanceof AST_SymbolRef) {\n                    if (self.name && self.name.definition() === fn.definition()) break;\n                    fn = fn.fixed_value();\n                }\n                if (!(fn instanceof AST_Defun || fn instanceof AST_Function)) break;\n                if (fn.uses_arguments) break;\n                if (fn === call.expression) {\n                    if (fn.parent_scope !== self) break;\n                    if (!all(fn.enclosed, function(def) {\n                        return def.scope !== self;\n                    })) break;\n                }\n                if (fn.contains_this()) break;\n                var len = fn.argnames.length;\n                if (len > 0 && compressor.option(\"inline\") < 2) break;\n                if (len > self.argnames.length) break;\n                if (!all(self.argnames, function(argname) {\n                    return argname instanceof AST_SymbolFunarg;\n                })) break;\n                if (!all(call.args, function(arg) {\n                    return !(arg instanceof AST_Spread);\n                })) break;\n                for (var j = 0; j < len; j++) {\n                    var arg = call.args[j];\n                    if (!(arg instanceof AST_SymbolRef)) break;\n                    if (arg.definition() !== self.argnames[j].definition()) break;\n                }\n                if (j < len) break;\n                for (; j < call.args.length; j++) {\n                    if (call.args[j].has_side_effects(compressor)) break;\n                }\n                if (j < call.args.length) break;\n                if (len < self.argnames.length && !compressor.drop_fargs(self, compressor.parent())) {\n                    if (!compressor.drop_fargs(fn, call)) break;\n                    do {\n                        fn.argnames.push(fn.make_var(AST_SymbolFunarg, fn, \"argument_\" + len));\n                    } while (++len < self.argnames.length);\n                }\n                return call.expression;\n            }\n            break;\n        }\n        return self;\n    });\n\n    AST_Scope.DEFMETHOD(\"merge_variables\", function(compressor) {\n        if (!compressor.option(\"merge_vars\")) return;\n        var self = this, segment = {}, root;\n        var first = [], last = [], index = 0;\n        var declarations = new Dictionary();\n        var references = Object.create(null);\n        var prev = Object.create(null);\n        var tw = new TreeWalker(function(node, descend) {\n            if (node instanceof AST_Assign) {\n                var lhs = node.left;\n                if (lhs instanceof AST_Destructured) {\n                    node.right.walk(tw);\n                    var marker = new TreeWalker(function(node) {\n                        if (node instanceof AST_Destructured) return;\n                        if (node instanceof AST_DestructuredKeyVal) {\n                            if (node.key instanceof AST_Node) {\n                                push();\n                                node.key.walk(tw);\n                                pop();\n                                push();\n                                node.value.walk(marker);\n                                pop();\n                            } else {\n                                node.value.walk(marker);\n                            }\n                        } else if (node instanceof AST_SymbolRef) {\n                            mark(node, false, true);\n                        } else {\n                            node.walk(tw);\n                        }\n                        return true;\n                    });\n                    lhs.walk(marker);\n                    return true;\n                }\n                if (lhs instanceof AST_SymbolRef) {\n                    if (node.operator != \"=\") mark(lhs, true, false);\n                    node.right.walk(tw);\n                    mark(lhs, false, true);\n                    return true;\n                }\n                return;\n            }\n            if (node instanceof AST_Binary) {\n                if (!lazy_op[node.operator]) return;\n                node.left.walk(tw);\n                push();\n                node.right.walk(tw);\n                pop();\n                return true;\n            }\n            if (node instanceof AST_Break) {\n                var target = tw.loopcontrol_target(node);\n                if (!(target instanceof AST_IterationStatement)) insert(target);\n                return true;\n            }\n            if (node instanceof AST_Call) {\n                var exp = node.expression;\n                var tail = exp.tail_node();\n                if (!is_function(tail)) return;\n                if (exp !== tail) exp.expressions.slice(0, -1).forEach(function(node) {\n                    node.walk(tw);\n                });\n                node.args.forEach(function(arg) {\n                    arg.walk(tw);\n                });\n                tail.walk(tw);\n                return true;\n            }\n            if (node instanceof AST_Conditional) {\n                node.condition.walk(tw);\n                push();\n                node.consequent.walk(tw);\n                pop();\n                push();\n                node.alternative.walk(tw);\n                pop();\n                return true;\n            }\n            if (node instanceof AST_Continue) {\n                var target = tw.loopcontrol_target(node);\n                if (target instanceof AST_Do) insert(target);\n                return true;\n            }\n            if (node instanceof AST_Do) {\n                push();\n                segment.block = node;\n                segment.loop = true;\n                var save = segment;\n                node.body.walk(tw);\n                if (segment.inserted === node) segment = save;\n                node.condition.walk(tw);\n                pop();\n                return true;\n            }\n            if (node instanceof AST_For) {\n                if (node.init) node.init.walk(tw);\n                push();\n                segment.block = node;\n                segment.loop = true;\n                if (node.condition) node.condition.walk(tw);\n                node.body.walk(tw);\n                if (node.step) node.step.walk(tw);\n                pop();\n                return true;\n            }\n            if (node instanceof AST_ForIn) {\n                node.object.walk(tw);\n                push();\n                segment.block = node;\n                segment.loop = true;\n                node.init.walk(tw);\n                node.body.walk(tw);\n                pop();\n                return true;\n            }\n            if (node instanceof AST_If) {\n                node.condition.walk(tw);\n                push();\n                node.body.walk(tw);\n                pop();\n                if (node.alternative) {\n                    push();\n                    node.alternative.walk(tw);\n                    pop();\n                }\n                return true;\n            }\n            if (node instanceof AST_LabeledStatement) {\n                push();\n                segment.block = node;\n                var save = segment;\n                node.body.walk(tw);\n                if (segment.inserted === node) segment = save;\n                pop();\n                return true;\n            }\n            if (node instanceof AST_Scope) {\n                push();\n                segment.block = node;\n                if (node === self) root = segment;\n                if (node instanceof AST_Lambda) {\n                    if (node.name) references[node.name.definition().id] = false;\n                    var marker = node.uses_arguments && !tw.has_directive(\"use strict\") ? function(node) {\n                        if (node instanceof AST_SymbolFunarg) references[node.definition().id] = false;\n                    } : function(node) {\n                        if (node instanceof AST_SymbolFunarg) mark(node, false, true);\n                    };\n                    var scanner = new TreeWalker(function(ref) {\n                        if (ref instanceof AST_SymbolDeclaration) references[ref.definition().id] = false;\n                        if (!(ref instanceof AST_SymbolRef)) return;\n                        var def = ref.definition();\n                        var ldef = node.variables.get(ref.name);\n                        if (ldef && (ldef === def\n                            || def.undeclared\n                            || node.parent_scope.find_variable(ref.name) === def)) {\n                            references[def.id] = false;\n                            references[ldef.id] = false;\n                        } else {\n                            var save = segment;\n                            pop();\n                            mark(ref, true, false);\n                            segment = save;\n                        }\n                        return true;\n                    });\n                    node.argnames.forEach(function(argname) {\n                        argname.mark_symbol(marker, scanner);\n                    });\n                }\n                if (node instanceof AST_Arrow && node.value) {\n                    node.value.walk(tw);\n                } else {\n                    walk_body(node, tw);\n                }\n                pop();\n                return true;\n            }\n            if (node instanceof AST_Switch) {\n                node.expression.walk(tw);\n                var save = segment;\n                node.body.forEach(function(branch) {\n                    if (branch instanceof AST_Default) return;\n                    branch.expression.walk(tw);\n                    if (save === segment) push();\n                });\n                segment = save;\n                node.body.forEach(function(branch) {\n                    push();\n                    segment.block = node;\n                    var save = segment;\n                    walk_body(branch, tw);\n                    if (segment.inserted === node) segment = save;\n                    pop();\n                });\n                return true;\n            }\n            if (node instanceof AST_SymbolRef) {\n                mark(node, true, false);\n                return true;\n            }\n            if (node instanceof AST_Try) {\n                push();\n                segment.block = node;\n                walk_body(node, tw);\n                pop();\n                if (node.bcatch) {\n                    if (node.bcatch.argname) node.bcatch.argname.mark_symbol(function(node) {\n                        if (node instanceof AST_SymbolCatch) {\n                            var def = node.definition();\n                            references[def.id] = false;\n                            if (def = def.redefined()) references[def.id] = false;\n                        }\n                    }, tw);\n                    push();\n                    if (node.bfinally) segment.block = node.bcatch;\n                    walk_body(node.bcatch, tw);\n                    pop();\n                }\n                if (node.bfinally) node.bfinally.walk(tw);\n                return true;\n            }\n            if (node instanceof AST_Unary) {\n                if (!UNARY_POSTFIX[node.operator]) return;\n                var sym = node.expression;\n                if (!(sym instanceof AST_SymbolRef)) return;\n                mark(sym, true, true);\n                return true;\n            }\n            if (node instanceof AST_VarDef) {\n                if (node.value) node.value.walk(tw);\n                node.name.mark_symbol(node.value ? function(node) {\n                    if (!(node instanceof AST_SymbolDeclaration)) return;\n                    if (node instanceof AST_SymbolVar) {\n                        mark(node, false, true);\n                    } else {\n                        references[node.definition().id] = false;\n                    }\n                    return true;\n                } : function(node) {\n                    if (!(node instanceof AST_SymbolDeclaration)) return;\n                    var id = node.definition().id;\n                    if (!(node instanceof AST_SymbolVar)) {\n                        references[id] = false;\n                    } else if (!(id in references)) {\n                        declarations.add(id, node);\n                    } else if (references[id]) {\n                        references[id].push(node);\n                    }\n                    return true;\n                }, tw);\n                return true;\n            }\n            if (node instanceof AST_While) {\n                push();\n                segment.block = node;\n                segment.loop = true;\n                descend();\n                pop();\n                return true;\n            }\n        });\n        tw.directives = Object.create(compressor.directives);\n        self.walk(tw);\n        var merged = Object.create(null);\n        while (first.length && last.length) {\n            var head = first.pop();\n            var def = head.definition;\n            if (!(def.id in prev)) continue;\n            if (!references[def.id]) continue;\n            var head_refs = {\n                start: references[def.id].start,\n            };\n            while (def.id in merged) def = merged[def.id];\n            head_refs.end = references[def.id].end;\n            var skipped = [];\n            do {\n                var tail = last.pop();\n                if (!tail) continue;\n                if (tail.index > head.index) continue;\n                var id = tail.definition.id;\n                var tail_refs = references[id];\n                if (!tail_refs) continue;\n                if (head_refs.start.block !== tail_refs.start.block\n                    || !mergeable(head_refs, tail_refs)\n                    || head_refs.start.loop && !mergeable(tail_refs, head_refs)\n                    || !all(tail_refs, function(sym) {\n                        return sym.scope.find_variable(def.name) === def;\n                    })) {\n                    skipped.unshift(tail);\n                    continue;\n                }\n                var orig = [], refs = [];\n                tail_refs.forEach(function(sym) {\n                    sym.thedef = def;\n                    sym.name = def.name;\n                    if (sym instanceof AST_SymbolRef) {\n                        refs.push(sym);\n                    } else {\n                        orig.push(sym);\n                    }\n                });\n                def.orig = orig.concat(def.orig);\n                def.references = refs.concat(def.references);\n                def.fixed = tail.definition.fixed && def.fixed;\n                merged[id] = def;\n                break;\n            } while (last.length);\n            if (skipped.length) last = last.concat(skipped);\n        }\n\n        function push() {\n            segment = Object.create(segment);\n        }\n\n        function pop() {\n            segment = Object.getPrototypeOf(segment);\n        }\n\n        function mark(sym, read, write) {\n            var def = sym.definition(), ldef;\n            if (def.id in references) {\n                var refs = references[def.id];\n                if (!refs) return;\n                if (refs.start.block !== segment.block) return references[def.id] = false;\n                refs.push(sym);\n                refs.end = segment;\n                if (def.id in prev) {\n                    last[prev[def.id]] = null;\n                } else if (!read) {\n                    return;\n                }\n            } else if ((ldef = self.variables.get(def.name)) !== def) {\n                if (ldef && root === segment) references[ldef.id] = false;\n                return references[def.id] = false;\n            } else if (compressor.exposed(def) || sym.name == \"arguments\" || sym.name == \"await\") {\n                return references[def.id] = false;\n            } else {\n                var refs = declarations.get(def.id) || [];\n                refs.push(sym);\n                references[def.id] = refs;\n                if (!read) {\n                    refs.start = segment;\n                    return first.push({\n                        index: index++,\n                        definition: def,\n                    });\n                }\n                if (segment.block !== self) return references[def.id] = false;\n                refs.start = root;\n            }\n            prev[def.id] = last.length;\n            last.push({\n                index: index++,\n                definition: def,\n            });\n        }\n\n        function insert(target) {\n            var stack = [];\n            while (true) {\n                if (HOP(segment, \"block\")) {\n                    var block = segment.block;\n                    if (block instanceof AST_LabeledStatement) block = block.body;\n                    if (block === target) break;\n                }\n                stack.push(segment);\n                pop();\n            }\n            segment.inserted = segment.block;\n            push();\n            while (stack.length) {\n                var seg = stack.pop();\n                push();\n                if (HOP(seg, \"block\")) segment.block = seg.block;\n                if (HOP(seg, \"loop\")) segment.loop = seg.loop;\n            }\n        }\n\n        function must_visit(base, segment) {\n            return base === segment || base.isPrototypeOf(segment);\n        }\n\n        function mergeable(head, tail) {\n            return must_visit(head.start, head.end) || must_visit(head.start, tail.start);\n        }\n    });\n\n    AST_Scope.DEFMETHOD(\"drop_unused\", function(compressor) {\n        if (!compressor.option(\"unused\")) return;\n        var self = this;\n        var drop_funcs = !(self instanceof AST_Toplevel) || compressor.toplevel.funcs;\n        var drop_vars = !(self instanceof AST_Toplevel) || compressor.toplevel.vars;\n        var assign_as_unused = /keep_assign/.test(compressor.option(\"unused\")) ? return_false : function(node, props) {\n            var sym, nested = false;\n            if (node instanceof AST_Assign) {\n                if (node.write_only || node.operator == \"=\") sym = node.left;\n            } else if (node instanceof AST_Unary) {\n                if (node.write_only) sym = node.expression;\n            }\n            if (/strict/.test(compressor.option(\"pure_getters\"))) {\n                while (sym instanceof AST_PropAccess && !sym.expression.may_throw_on_access(compressor)) {\n                    if (sym instanceof AST_Sub) props.unshift(sym.property);\n                    sym = sym.expression;\n                    nested = true;\n                }\n            }\n            if (!(sym instanceof AST_SymbolRef)) return;\n            if (compressor.exposed(sym.definition())) return;\n            if (!can_drop_symbol(sym, nested)) return;\n            return sym;\n        };\n        var assign_in_use = Object.create(null);\n        var find_variable = function(name) {\n            find_variable = compose(self, 0, noop);\n            return find_variable(name);\n\n            function compose(child, level, find) {\n                var parent = compressor.parent(level);\n                if (!parent) return find;\n                if (parent instanceof AST_DestructuredKeyVal) {\n                    var destructured = compressor.parent(level + 1);\n                    if (parent.key === child) {\n                        var fn = compressor.parent(level + 2);\n                        if (fn instanceof AST_Lambda) {\n                            return compose(fn, level + 3, fn.argnames.indexOf(destructured) >= 0 ? function(name) {\n                                var def = find(name);\n                                if (def) return def;\n                                def = fn.variables.get(name);\n                                if (def) {\n                                    var sym = def.orig[0];\n                                    if (sym instanceof AST_SymbolFunarg || sym instanceof AST_SymbolLambda) return def;\n                                }\n                            } : function(name) {\n                                return find(name) || fn.variables.get(name);\n                            });\n                        }\n                    }\n                    return compose(destructured, level + 2, find);\n                }\n                return compose(parent, level + 1, parent.variables ? function(name) {\n                    return find(name) || parent.variables.get(name);\n                } : find);\n            }\n        };\n        var for_ins = Object.create(null);\n        var in_use = [];\n        var in_use_ids = Object.create(null); // avoid expensive linear scans of in_use\n        var value_read = Object.create(null);\n        var value_modified = Object.create(null);\n        if (self instanceof AST_Toplevel && compressor.top_retain) {\n            self.variables.each(function(def) {\n                if (compressor.top_retain(def) && !(def.id in in_use_ids)) {\n                    in_use_ids[def.id] = true;\n                    in_use.push(def);\n                }\n            });\n        }\n        var assignments = new Dictionary();\n        var var_defs_by_id = new Dictionary();\n        var initializations = new Dictionary();\n        // pass 1: find out which symbols are directly used in\n        // this scope (not in nested scopes).\n        var scope = this;\n        var tw = new TreeWalker(function(node, descend) {\n            if (node instanceof AST_Lambda && node.uses_arguments && !tw.has_directive(\"use strict\")) {\n                node.each_argname(function(argname) {\n                    var def = argname.definition();\n                    if (!(def.id in in_use_ids)) {\n                        in_use_ids[def.id] = true;\n                        in_use.push(def);\n                    }\n                });\n            }\n            if (node === self) return;\n            if (scope === self) {\n                if (is_defun(node)) {\n                    var def = node.name.definition();\n                    if (!drop_funcs && !(def.id in in_use_ids)) {\n                        in_use_ids[def.id] = true;\n                        in_use.push(def);\n                    }\n                    initializations.add(def.id, node);\n                    return true; // don't go in nested scopes\n                }\n                if (node instanceof AST_Definitions) {\n                    node.definitions.forEach(function(defn) {\n                        var side_effects = defn.value\n                            && (defn.name instanceof AST_Destructured || defn.value.has_side_effects(compressor));\n                        defn.name.mark_symbol(function(name) {\n                            if (!(name instanceof AST_SymbolDeclaration)) return;\n                            var def = name.definition();\n                            var_defs_by_id.add(def.id, defn);\n                            if (node instanceof AST_Var && def.orig[0] instanceof AST_SymbolCatch) {\n                                var redef = def.redefined();\n                                if (redef) var_defs_by_id.add(redef.id, defn);\n                            }\n                            if (!(def.id in in_use_ids) && (!drop_vars\n                                || (node instanceof AST_Const ? def.redefined() : def.const_redefs)\n                                || !(node instanceof AST_Var || is_safe_lexical(def)))) {\n                                in_use_ids[def.id] = true;\n                                in_use.push(def);\n                            }\n                            if (defn.value) {\n                                if (!side_effects) initializations.add(def.id, defn.value);\n                                assignments.add(def.id, defn);\n                            }\n                            return true;\n                        }, tw);\n                        if (side_effects) defn.value.walk(tw);\n                    });\n                    return true;\n                }\n                if (node instanceof AST_SymbolFunarg) {\n                    var def = node.definition();\n                    var_defs_by_id.add(def.id, node);\n                    assignments.add(def.id, node);\n                    return true;\n                }\n            }\n            return scan_ref_scoped(node, descend, true);\n        });\n        tw.directives = Object.create(compressor.directives);\n        self.walk(tw);\n        // pass 2: for every used symbol we need to walk its\n        // initialization code to figure out if it uses other\n        // symbols (that may not be in_use).\n        tw = new TreeWalker(scan_ref_scoped);\n        for (var i = 0; i < in_use.length; i++) {\n            var init = initializations.get(in_use[i].id);\n            if (init) init.forEach(function(init) {\n                init.walk(tw);\n            });\n        }\n        Object.keys(assign_in_use).forEach(function(id) {\n            var assigns = assign_in_use[id];\n            if (!assigns) {\n                delete assign_in_use[id];\n                return;\n            }\n            assigns = assigns.reduce(function(in_use, assigns) {\n                assigns.forEach(function(assign) {\n                    push_uniq(in_use, assign);\n                });\n                return in_use;\n            }, []);\n            var in_use = (assignments.get(id) || []).filter(function(node) {\n                return find_if(node instanceof AST_Unary ? function(assign) {\n                    return assign === node;\n                } : function(assign) {\n                    if (assign === node) return true;\n                    if (assign instanceof AST_Unary) return false;\n                    return get_rvalue(assign) === get_rvalue(node);\n                }, assigns);\n            });\n            if (assigns.length == in_use.length) {\n                assign_in_use[id] = in_use;\n            } else {\n                delete assign_in_use[id];\n            }\n        });\n        var drop_fn_name = compressor.option(\"keep_fnames\") ? return_false : compressor.option(\"ie8\") ? function(def) {\n            return !compressor.exposed(def) && def.references.length == def.replaced;\n        } : function(def) {\n            if (!(def.id in in_use_ids)) return true;\n            if (def.orig.length < 2) return false;\n            // function argument will always overshadow its name\n            if (def.orig[1] instanceof AST_SymbolFunarg) return true;\n            // retain if referenced within destructured object of argument\n            return all(def.references, function(ref) {\n                return !ref.in_arg;\n            });\n        };\n        // pass 3: we should drop declarations not in_use\n        var unused_fn_names = [];\n        var calls_to_drop_args = [];\n        var fns_with_marked_args = [];\n        var trimmer = new TreeTransformer(function(node) {\n            if (node instanceof AST_DefaultValue) return trim_default(trimmer, node);\n            if (node instanceof AST_DestructuredArray) {\n                var trim = true;\n                for (var i = node.elements.length; --i >= 0;) {\n                    var element = node.elements[i].transform(trimmer);\n                    if (element) {\n                        node.elements[i] = element;\n                        trim = false;\n                    } else if (trim) {\n                        node.elements.pop();\n                    } else {\n                        node.elements[i] = make_node(AST_Hole, node.elements[i]);\n                    }\n                }\n                return node;\n            }\n            if (node instanceof AST_DestructuredKeyVal) {\n                var retain = false;\n                if (node.key instanceof AST_Node) {\n                    node.key = node.key.transform(tt);\n                    retain = node.key.has_side_effects(compressor);\n                }\n                if (retain && is_decl(node.value)) {\n                    node.value = node.value.transform(tt);\n                } else {\n                    var value = node.value.transform(trimmer);\n                    if (!value) return List.skip;\n                    node.value = value;\n                }\n                return node;\n            }\n            if (node instanceof AST_SymbolDeclaration) return node.definition().id in in_use_ids ? node : null;\n        });\n        var tt = new TreeTransformer(function(node, descend, in_list) {\n            var parent = tt.parent();\n            if (drop_vars) {\n                var props = [], sym = assign_as_unused(node, props);\n                if (sym) {\n                    var def = sym.definition();\n                    var in_use = def.id in in_use_ids;\n                    var value;\n                    if (node instanceof AST_Assign) {\n                        if (!in_use || node.left === sym && indexOf_assign(def, node) < 0) {\n                            value = get_rhs(node);\n                            if (node.write_only === true) {\n                                value = value.drop_side_effect_free(compressor) || make_node(AST_Number, node, {\n                                    value: 0\n                                });\n                            }\n                        }\n                    } else if (!in_use || node.expression === sym && indexOf_assign(def, node) < 0) {\n                        value = make_node(AST_Number, node, {\n                            value: 0\n                        });\n                    }\n                    if (value) {\n                        if (parent instanceof AST_Sequence && parent.tail_node() !== node) {\n                            value = value.drop_side_effect_free(compressor);\n                        }\n                        if (value) props.push(value);\n                        switch (props.length) {\n                          case 0:\n                            return List.skip;\n                          case 1:\n                            return maintain_this_binding(compressor, parent, node, props[0].transform(tt));\n                          default:\n                            return make_sequence(node, props.map(function(prop) {\n                                return prop.transform(tt);\n                            }));\n                        }\n                    }\n                } else if (node instanceof AST_UnaryPostfix\n                    && node.expression instanceof AST_SymbolRef\n                    && indexOf_assign(node.expression.definition(), node) < 0) {\n                    return make_node(AST_UnaryPrefix, node, {\n                        operator: \"+\",\n                        expression: node.expression\n                    });\n                }\n            }\n            if (node instanceof AST_Call) calls_to_drop_args.push(node);\n            if (scope !== self) return;\n            if (node instanceof AST_Lambda) {\n                if (drop_funcs && node !== self && is_defun(node)) {\n                    var def = node.name.definition();\n                    if (!(def.id in in_use_ids)) {\n                        log(node.name, \"Dropping unused function {name}\");\n                        def.eliminated++;\n                        return in_list ? List.skip : make_node(AST_EmptyStatement, node);\n                    }\n                }\n                if (is_function(node) && node.name && drop_fn_name(node.name.definition())) {\n                    unused_fn_names.push(node);\n                }\n                if (!(node instanceof AST_Accessor)) {\n                    var trim = compressor.drop_fargs(node, parent);\n                    for (var a = node.argnames, i = a.length; --i >= 0;) {\n                        var sym = a[i];\n                        if (!(sym instanceof AST_SymbolFunarg)) {\n                            var arg = sym.transform(trimmer);\n                            if (arg) {\n                                trim = false;\n                            } else if (trim) {\n                                log(sym.name, \"Dropping unused function argument {name}\");\n                                a.pop();\n                            } else {\n                                sym.name.__unused = true;\n                                a[i] = sym.name;\n                            }\n                            continue;\n                        }\n                        var def = sym.definition();\n                        if (def.id in in_use_ids) {\n                            trim = false;\n                            if (indexOf_assign(def, sym) < 0) sym.__unused = null;\n                        } else if (trim) {\n                            log(sym, \"Dropping unused function argument {name}\");\n                            a.pop();\n                        } else {\n                            sym.__unused = true;\n                        }\n                    }\n                    fns_with_marked_args.push(node);\n                }\n            }\n            if (node instanceof AST_Catch && node.argname instanceof AST_Destructured) {\n                node.argname.transform(trimmer);\n            }\n            if (node instanceof AST_Definitions && !(parent instanceof AST_ForIn && parent.init === node)) {\n                // place uninitialized names at the start\n                var body = [], head = [], tail = [];\n                // for unused names whose initialization has\n                // side effects, we can cascade the init. code\n                // into the next one, or next statement.\n                var side_effects = [];\n                var duplicated = 0;\n                var is_var = node instanceof AST_Var;\n                node.definitions.forEach(function(def) {\n                    if (def.value) def.value = def.value.transform(tt);\n                    if (def.name instanceof AST_Destructured) {\n                        var name = trim_destructured(def.name, def.value, function(node) {\n                            if (!drop_vars) return node;\n                            if (node.definition().id in in_use_ids) return node;\n                            if (is_catch(node)) return node;\n                            if (is_var && !can_drop_symbol(node)) return node;\n                            return null;\n                        });\n                        if (name) {\n                            flush();\n                        } else {\n                            var value = def.value.drop_side_effect_free(compressor);\n                            if (value) side_effects.push(value);\n                        }\n                        return;\n                    }\n                    var sym = def.name.definition();\n                    var drop_sym = is_var ? can_drop_symbol(def.name) : is_safe_lexical(sym);\n                    if (!drop_sym || !drop_vars || sym.id in in_use_ids) {\n                        if (def.value && indexOf_assign(sym, def) < 0) {\n                            var write_only = def.value.write_only;\n                            var value = def.value.drop_side_effect_free(compressor);\n                            if (def.value !== value) {\n                                def.value = value && make_sequence(def.value, [\n                                    value,\n                                    make_node(AST_Number, def.value, {\n                                        value: 0\n                                    }),\n                                ]);\n                            } else if (def.value.write_only !== write_only) {\n                                def.value.write_only = write_only;\n                            }\n                        }\n                        var old_def, var_defs = var_defs_by_id.get(sym.id);\n                        if (!def.value && !(node instanceof AST_Let)) {\n                            if (drop_sym && var_defs.length > 1) {\n                                AST_Node.info(\"Dropping declaration of variable {name} [{file}:{line},{col}]\", template(def.name));\n                                remove(var_defs, def);\n                                sym.eliminated++;\n                            } else {\n                                head.push(def);\n                            }\n                        } else if (compressor.option(\"functions\")\n                            && !compressor.option(\"ie8\")\n                            && !(node instanceof AST_Const || node instanceof AST_Let)\n                            && var_defs.length == 1\n                            && sym.assignments == 0\n                            && def.value instanceof AST_Function\n                            && (sym.references.length ? all(sym.references, function(ref) {\n                                    return def.value === ref.fixed_value();\n                                }) : def.value === def.name.fixed_value())\n                            && (!def.value.name || (old_def = def.value.name.definition()).assignments == 0\n                                && (old_def.name == def.name.name || all(old_def.references, function(ref) {\n                                    return ref.scope.find_variable(def.name.name) === def.name.definition();\n                                })))\n                            && can_declare_defun()\n                            && can_rename(def.value, def.name.name)) {\n                            AST_Node.warn(\"Declaring {name} as function [{file}:{line},{col}]\", template(def.name));\n                            var defun = make_node(AST_Defun, def, def.value);\n                            defun.name = make_node(AST_SymbolDefun, def.name, def.name);\n                            var name_def = def.name.scope.resolve().def_function(defun.name);\n                            if (old_def) old_def.references.forEach(function(node) {\n                                node.name = name_def.name;\n                                node.thedef = name_def;\n                                node.reference({});\n                            });\n                            body.push(defun);\n                        } else {\n                            if (drop_sym && var_defs.length > 1 && sym.orig.indexOf(def.name) > sym.eliminated) {\n                                remove(var_defs, def);\n                                duplicated++;\n                            }\n                            flush();\n                        }\n                    } else if (is_catch(def.name)) {\n                        var value = def.value && def.value.drop_side_effect_free(compressor);\n                        if (value) side_effects.push(value);\n                        var var_defs = var_defs_by_id.get(sym.id);\n                        if (var_defs.length > 1) {\n                            AST_Node.warn(\"Dropping duplicated declaration of variable {name} [{file}:{line},{col}]\", template(def.name));\n                            remove(var_defs, def);\n                            sym.eliminated++;\n                        } else {\n                            def.value = null;\n                            head.push(def);\n                        }\n                    } else {\n                        var value = def.value && !def.value.single_use && def.value.drop_side_effect_free(compressor);\n                        if (value) {\n                            AST_Node.warn(\"Side effects in initialization of unused variable {name} [{file}:{line},{col}]\", template(def.name));\n                            side_effects.push(value);\n                        } else {\n                            log(def.name, \"Dropping unused variable {name}\");\n                        }\n                        sym.eliminated++;\n                    }\n\n                    function is_catch(node) {\n                        var sym = node.definition();\n                        return sym.orig[0] instanceof AST_SymbolCatch && sym.scope.resolve() === node.scope.resolve();\n                    }\n\n                    function can_rename(fn, name) {\n                        var def = fn.variables.get(name);\n                        return !def || fn.name && def === fn.name.definition();\n                    }\n\n                    function can_declare_defun() {\n                        if (compressor.has_directive(\"use strict\")) return parent instanceof AST_Scope;\n                        return parent instanceof AST_Block\n                            || parent instanceof AST_For && parent.init === node\n                            || parent instanceof AST_If;\n                    }\n\n                    function flush() {\n                        if (side_effects.length > 0) {\n                            if (tail.length == 0) {\n                                body.push(make_node(AST_SimpleStatement, node, {\n                                    body: make_sequence(node, side_effects)\n                                }));\n                            } else if (def.value) {\n                                side_effects.push(def.value);\n                                def.value = make_sequence(def.value, side_effects);\n                            } else {\n                                def.value = make_node(AST_UnaryPrefix, def, {\n                                    operator: \"void\",\n                                    expression: make_sequence(def, side_effects)\n                                });\n                            }\n                            side_effects = [];\n                        }\n                        tail.push(def);\n                    }\n                });\n                switch (head.length) {\n                  case 0:\n                    if (tail.length == 0) break;\n                    if (tail.length == duplicated) {\n                        [].unshift.apply(side_effects, tail.map(function(def) {\n                            AST_Node.warn(\"Dropping duplicated definition of variable {name} [{file}:{line},{col}]\", template(def.name));\n                            var sym = def.name.definition();\n                            var ref = make_node(AST_SymbolRef, def.name, def.name);\n                            sym.references.push(ref);\n                            var assign = make_node(AST_Assign, def, {\n                                operator: \"=\",\n                                left: ref,\n                                right: def.value\n                            });\n                            var index = indexOf_assign(sym, def);\n                            if (index >= 0) assign_in_use[sym.id][index] = assign;\n                            sym.eliminated++;\n                            return assign;\n                        }));\n                        break;\n                    }\n                  case 1:\n                    if (tail.length == 0) {\n                        var id = head[0].name.definition().id;\n                        if (id in for_ins) {\n                            node.definitions = head;\n                            for_ins[id].init = node;\n                            break;\n                        }\n                    }\n                  default:\n                    node.definitions = head.concat(tail);\n                    body.push(node);\n                }\n                if (side_effects.length > 0) {\n                    body.push(make_node(AST_SimpleStatement, node, {\n                        body: make_sequence(node, side_effects)\n                    }));\n                }\n                return insert_statements(body, node, in_list);\n            }\n            if (node instanceof AST_Assign) {\n                descend(node, tt);\n                if (node.left instanceof AST_Destructured) {\n                    var lhs = trim_destructured(node.left, node.right, function(node) {\n                        return node;\n                    });\n                    if (!lhs) return node.right;\n                    node.left = lhs;\n                }\n                return node;\n            }\n            if (node instanceof AST_LabeledStatement && node.body instanceof AST_For) {\n                // Certain combination of unused name + side effect leads to invalid AST:\n                //    https://github.com/mishoo/UglifyJS/issues/1830\n                // We fix it at this stage by moving the label inwards, back to the `for`.\n                descend(node, tt);\n                if (node.body instanceof AST_BlockStatement) {\n                    var block = node.body;\n                    node.body = block.body.pop();\n                    block.body.push(node);\n                    return in_list ? List.splice(block.body) : block;\n                }\n                return node;\n            }\n            if (node instanceof AST_Scope) {\n                var save_scope = scope;\n                scope = node;\n                descend(node, tt);\n                scope = save_scope;\n                return node;\n            }\n        }, function(node, in_list) {\n            if (node instanceof AST_BlockStatement) switch (node.body.length) {\n              case 0:\n                return in_list ? List.skip : make_node(AST_EmptyStatement, node);\n              case 1:\n                var stat = node.body[0];\n                if (!(stat instanceof AST_Const || stat instanceof AST_Let)) return stat;\n            } else if (node instanceof AST_For) {\n                // Certain combination of unused name + side effect leads to invalid AST:\n                //    https://github.com/mishoo/UglifyJS/issues/44\n                //    https://github.com/mishoo/UglifyJS/issues/1838\n                //    https://github.com/mishoo/UglifyJS/issues/3371\n                // We fix it at this stage by moving the `var` outside the `for`.\n                var block;\n                if (node.init instanceof AST_BlockStatement) {\n                    block = node.init;\n                    node.init = block.body.pop();\n                    block.body.push(node);\n                }\n                if (node.init instanceof AST_Defun) {\n                    if (!block) {\n                        block = make_node(AST_BlockStatement, node, {\n                            body: [ node ]\n                        });\n                    }\n                    block.body.splice(-1, 0, node.init);\n                    node.init = null;\n                } else if (node.init instanceof AST_SimpleStatement) {\n                    node.init = node.init.body;\n                } else if (is_empty(node.init)) {\n                    node.init = null;\n                }\n                return !block ? node : in_list ? List.splice(block.body) : block;\n            } else if (node instanceof AST_ForIn) {\n                if (!drop_vars || !compressor.option(\"loops\")) return;\n                if (!is_empty(node.body)) return;\n                var sym = get_init_symbol(node);\n                if (!sym) return;\n                var def = sym.definition();\n                if (def.id in in_use_ids) return;\n                log(sym, \"Dropping unused loop variable {name}\");\n                if (for_ins[def.id] === node) delete for_ins[def.id];\n                var body = [];\n                var value = node.object.drop_side_effect_free(compressor);\n                if (value) {\n                    AST_Node.warn(\"Side effects in object of for-in loop [{file}:{line},{col}]\", value.start);\n                    body.push(make_node(AST_SimpleStatement, node, {\n                        body: value\n                    }));\n                }\n                if (node.init instanceof AST_Definitions && def.orig[0] instanceof AST_SymbolCatch) {\n                    body.push(node.init);\n                }\n                return insert_statements(body, node, in_list);\n            } else if (node instanceof AST_Sequence) {\n                if (node.expressions.length == 1) return node.expressions[0];\n            }\n        });\n        tt.push(compressor.parent());\n        self.transform(tt);\n        if (self instanceof AST_Lambda\n            && self.body.length == 1\n            && self.body[0] instanceof AST_Directive\n            && self.body[0].value == \"use strict\") {\n            self.body.length = 0;\n        }\n        unused_fn_names.forEach(function(fn) {\n            fn.name = null;\n        });\n        calls_to_drop_args.forEach(function(call) {\n            drop_unused_call_args(call, compressor, fns_with_marked_args);\n        });\n\n        function log(sym, text) {\n            AST_Node[sym.definition().references.length > 0 ? \"info\" : \"warn\"](text + \" [{file}:{line},{col}]\", template(sym));\n        }\n\n        function template(sym) {\n            return {\n                name: sym.name,\n                file: sym.start.file,\n                line: sym.start.line,\n                col : sym.start.col,\n            };\n        }\n\n        function insert_statements(body, orig, in_list) {\n            switch (body.length) {\n              case 0:\n                return in_list ? List.skip : make_node(AST_EmptyStatement, orig);\n              case 1:\n                return body[0];\n              default:\n                return in_list ? List.splice(body) : make_node(AST_BlockStatement, orig, {\n                    body: body\n                });\n            }\n        }\n\n        function track_assigns(def, node) {\n            if (def.scope !== self) return false;\n            if (!def.fixed || !node.fixed) assign_in_use[def.id] = false;\n            return assign_in_use[def.id] !== false;\n        }\n\n        function add_assigns(def, node) {\n            if (!assign_in_use[def.id]) assign_in_use[def.id] = [];\n            if (node.fixed.assigns) push_uniq(assign_in_use[def.id], node.fixed.assigns);\n        }\n\n        function indexOf_assign(def, node) {\n            var nodes = assign_in_use[def.id];\n            return nodes && nodes.indexOf(node);\n        }\n\n        function verify_safe_usage(def, read, modified) {\n            if (def.id in in_use_ids) return;\n            if (read && modified) {\n                in_use_ids[def.id] = true;\n                in_use.push(def);\n            } else {\n                value_read[def.id] = read;\n                value_modified[def.id] = modified;\n            }\n        }\n\n        function get_rhs(assign) {\n            var rhs = assign.right;\n            if (!assign.write_only) return rhs;\n            if (!(rhs instanceof AST_Binary && lazy_op[rhs.operator])) return rhs;\n            if (!(rhs.left instanceof AST_SymbolRef)) return rhs;\n            if (!(assign.left instanceof AST_SymbolRef)) return rhs;\n            var def = assign.left.definition();\n            if (rhs.left.definition() !== def) return rhs;\n            if (rhs.right.has_side_effects(compressor)) return rhs;\n            if (track_assigns(def, rhs.left)) add_assigns(def, rhs.left);\n            return rhs.right;\n        }\n\n        function get_init_symbol(for_in) {\n            var init = for_in.init;\n            if (init instanceof AST_Definitions) {\n                init = init.definitions[0].name;\n                return init instanceof AST_SymbolDeclaration && init;\n            }\n            while (init instanceof AST_PropAccess) init = init.expression.tail_node();\n            if (init instanceof AST_SymbolRef) return init;\n        }\n\n        function scan_ref_scoped(node, descend, init) {\n            if (node instanceof AST_Assign && node.left instanceof AST_SymbolRef) {\n                var def = node.left.definition();\n                if (def.scope === self) assignments.add(def.id, node);\n            }\n            if (node instanceof AST_Unary && node.expression instanceof AST_SymbolRef) {\n                var def = node.expression.definition();\n                if (def.scope === self) assignments.add(def.id, node);\n            }\n            var node_def, props = [], sym = assign_as_unused(node, props);\n            if (sym && self.variables.get(sym.name) === (node_def = sym.definition())\n                && !(is_arguments(node_def) && !all(self.argnames, function(argname) {\n                    return !argname.match_symbol(function(node) {\n                        if (node instanceof AST_SymbolFunarg) {\n                            var def = node.definition();\n                            return def.references.length > def.replaced;\n                        }\n                    }, true);\n                }))) {\n                props.forEach(function(prop) {\n                    prop.walk(tw);\n                });\n                if (node instanceof AST_Assign) {\n                    if (node.write_only === \"p\" && node.right.may_throw_on_access(compressor)) return;\n                    var right = get_rhs(node);\n                    if (init && node.write_only === true && node_def.scope === self && !right.has_side_effects(compressor)) {\n                        initializations.add(node_def.id, right);\n                    } else {\n                        right.walk(tw);\n                    }\n                    if (node.left === sym) {\n                        if (!node.write_only) {\n                            verify_safe_usage(node_def, true, value_modified[node_def.id]);\n                        }\n                    } else {\n                        var fixed = sym.fixed_value();\n                        if (!fixed || !fixed.is_constant()) {\n                            verify_safe_usage(node_def, value_read[node_def.id], true);\n                        }\n                    }\n                }\n                if (track_assigns(node_def, sym) && is_lhs(sym, node) !== sym) add_assigns(node_def, sym);\n                return true;\n            }\n            if (node instanceof AST_ForIn) {\n                if (node.init instanceof AST_SymbolRef && scope === self) {\n                    var id = node.init.definition().id;\n                    if (!(id in for_ins)) for_ins[id] = node;\n                }\n                if (!drop_vars || !compressor.option(\"loops\")) return;\n                if (!is_empty(node.body)) return;\n                if (node.init.has_side_effects(compressor)) return;\n                var sym = get_init_symbol(node);\n                if (!sym) return;\n                var def = sym.definition();\n                if (def.scope !== self) {\n                    var d = find_variable(sym.name);\n                    if ((d && d.redefined() || d) === def) return;\n                }\n                node.object.walk(tw);\n                return true;\n            }\n            if (node instanceof AST_SymbolRef) {\n                node_def = node.definition();\n                if (!(node_def.id in in_use_ids)) {\n                    in_use_ids[node_def.id] = true;\n                    in_use.push(node_def);\n                }\n                if (cross_scope(node_def.scope, node.scope)) {\n                    var redef = node_def.redefined();\n                    if (redef && !(redef.id in in_use_ids)) {\n                        in_use_ids[redef.id] = true;\n                        in_use.push(redef);\n                    }\n                }\n                if (track_assigns(node_def, node)) add_assigns(node_def, node);\n                return true;\n            }\n            if (node instanceof AST_Scope) {\n                var save_scope = scope;\n                scope = node;\n                descend();\n                scope = save_scope;\n                return true;\n            }\n        }\n\n        function is_decl(node) {\n            return (node instanceof AST_DefaultValue ? node.name : node) instanceof AST_SymbolDeclaration;\n        }\n\n        function trim_default(trimmer, node) {\n            node.value = node.value.transform(tt);\n            var name = node.name.transform(trimmer);\n            if (!name) {\n                var value = node.value.drop_side_effect_free(compressor);\n                if (!value) return null;\n                name = node.name;\n                if (name instanceof AST_Destructured) {\n                    name = name.clone();\n                    name[name instanceof AST_DestructuredArray ? \"elements\" : \"properties\"] = [];\n                    if (!(value instanceof AST_Array || value.is_string(compressor)\n                        || name instanceof AST_DestructuredObject\n                            && (value instanceof AST_Object\n                                || value.is_boolean(compressor)\n                                || value.is_number(compressor)))) {\n                        value = make_node(AST_Array, value, {\n                            elements: [ value ],\n                        });\n                    }\n                    node.name = name;\n                } else {\n                    log(name, \"Side effects in default value of unused variable {name}\");\n                }\n                node.value = value;\n            }\n            return node;\n        }\n\n        function trim_destructured(node, value, process) {\n            var trimmer = new TreeTransformer(function(node) {\n                if (node instanceof AST_DefaultValue) {\n                    if (compressor.option(\"default_values\") && value && value.is_defined(compressor)) {\n                        node = node.name;\n                    } else {\n                        return trim_default(trimmer, node);\n                    }\n                }\n                if (node instanceof AST_DestructuredArray) {\n                    var save = value;\n                    if (value instanceof AST_SymbolRef) value = value.fixed_value();\n                    var values = value instanceof AST_Array && value.elements;\n                    var elements = [];\n                    node.elements.forEach(function(element, index) {\n                        if (element instanceof AST_Hole) return;\n                        value = values && values[index];\n                        element = element.transform(trimmer);\n                        if (element) elements[index] = element;\n                    });\n                    value = save;\n                    if (values && elements.length == 0) return null;\n                    for (var i = elements.length; --i >= 0;) {\n                        if (!elements[i]) elements[i] = make_node(AST_Hole, node.elements[i] || node);\n                    }\n                    node.elements = elements;\n                    return node;\n                }\n                if (node instanceof AST_DestructuredObject) {\n                    var save = value;\n                    if (value instanceof AST_SymbolRef) value = value.fixed_value();\n                    var values;\n                    if (value instanceof AST_Object) {\n                        values = Object.create(null);\n                        for (var i = 0; i < value.properties.length; i++) {\n                            var prop = value.properties[i];\n                            if (typeof prop.key != \"string\") {\n                                values = null;\n                                break;\n                            }\n                            values[prop.key] = prop.value;\n                        }\n                    }\n                    var properties = [];\n                    node.properties.forEach(function(prop) {\n                        var retain;\n                        if (prop.key instanceof AST_Node) {\n                            prop.key = prop.key.transform(tt);\n                            value = null;\n                            retain = prop.key.has_side_effects(compressor);\n                        } else {\n                            value = values && values[prop.key];\n                            retain = false;\n                        }\n                        if (retain && is_decl(prop.value)) {\n                            prop.value = prop.value.transform(tt);\n                            properties.push(prop);\n                        } else {\n                            var newValue = prop.value.transform(trimmer);\n                            if (newValue) {\n                                prop.value = newValue;\n                                properties.push(prop);\n                            }\n                        }\n                    });\n                    value = save;\n                    if (properties.length == 0 && value && !value.may_throw_on_access(compressor)) {\n                        return null;\n                    }\n                    node.properties = properties;\n                    return node;\n                }\n                return process(node);\n            });\n            return node.transform(trimmer);\n        }\n    });\n\n    AST_Scope.DEFMETHOD(\"hoist_declarations\", function(compressor) {\n        if (compressor.has_directive(\"use asm\")) return;\n        var hoist_funs = compressor.option(\"hoist_funs\");\n        var hoist_vars = compressor.option(\"hoist_vars\");\n        var self = this;\n        if (hoist_vars) {\n            // let's count var_decl first, we seem to waste a lot of\n            // space if we hoist `var` when there's only one.\n            var var_decl = 0;\n            self.walk(new TreeWalker(function(node) {\n                if (var_decl > 1) return true;\n                if (node instanceof AST_Scope && node !== self) return true;\n                if (node instanceof AST_Var) {\n                    var_decl++;\n                    return true;\n                }\n            }));\n            if (var_decl <= 1) hoist_vars = false;\n        }\n        if (!hoist_funs && !hoist_vars) return;\n        var consts = Object.create(null);\n        var dirs = [];\n        var hoisted = [];\n        var vars = new Dictionary(), vars_found = 0;\n        var tt = new TreeTransformer(function(node) {\n            if (node === self) return;\n            if (node instanceof AST_Directive) {\n                dirs.push(node);\n                return make_node(AST_EmptyStatement, node);\n            }\n            if (hoist_funs && node instanceof AST_Defun\n                && (tt.parent() === self || !compressor.has_directive(\"use strict\"))) {\n                hoisted.push(node);\n                return make_node(AST_EmptyStatement, node);\n            }\n            if (hoist_vars && node instanceof AST_Var) {\n                if (!all(node.definitions, function(defn) {\n                    var sym = defn.name;\n                    return sym instanceof AST_SymbolVar\n                        && !consts[sym.name]\n                        && self.find_variable(sym.name) === sym.definition();\n                })) return node;\n                node.definitions.forEach(function(def) {\n                    vars.set(def.name.name, def);\n                    ++vars_found;\n                });\n                var seq = node.to_assignments();\n                var p = tt.parent();\n                if (p instanceof AST_ForIn && p.init === node) {\n                    if (seq) return seq;\n                    var def = node.definitions[0].name;\n                    return make_node(AST_SymbolRef, def, def);\n                }\n                if (p instanceof AST_For && p.init === node) return seq;\n                if (!seq) return make_node(AST_EmptyStatement, node);\n                return make_node(AST_SimpleStatement, node, {\n                    body: seq\n                });\n            }\n            if (node instanceof AST_Scope) return node;\n            if (node instanceof AST_SymbolConst) {\n                consts[node.name] = true;\n                return node;\n            }\n        });\n        self.transform(tt);\n        if (vars_found > 0) {\n            // collect only vars which don't show up in self's arguments list\n            var defs = [];\n            vars.each(function(def, name) {\n                if (self instanceof AST_Lambda\n                    && !all(self.argnames, function(argname) {\n                        return argname.name != name;\n                    })) {\n                    vars.del(name);\n                } else {\n                    def = def.clone();\n                    def.value = null;\n                    defs.push(def);\n                    vars.set(name, def);\n                }\n            });\n            if (defs.length > 0) {\n                // try to merge in assignments\n                insert_vars(self.body);\n                defs = make_node(AST_Var, self, {\n                    definitions: defs\n                });\n                hoisted.push(defs);\n            }\n        }\n        self.body = dirs.concat(hoisted, self.body);\n\n        function insert_vars(body) {\n            while (body.length) {\n                var stat = body[0];\n                if (stat instanceof AST_SimpleStatement) {\n                    var expr = stat.body, sym, assign;\n                    if (expr instanceof AST_Assign\n                        && expr.operator == \"=\"\n                        && (sym = expr.left) instanceof AST_Symbol\n                        && vars.has(sym.name)) {\n                        var def = vars.get(sym.name);\n                        if (def.value) break;\n                        def.value = expr.right;\n                        remove(defs, def);\n                        defs.push(def);\n                        body.shift();\n                        continue;\n                    }\n                    if (expr instanceof AST_Sequence\n                        && (assign = expr.expressions[0]) instanceof AST_Assign\n                        && assign.operator == \"=\"\n                        && (sym = assign.left) instanceof AST_Symbol\n                        && vars.has(sym.name)) {\n                        var def = vars.get(sym.name);\n                        if (def.value) break;\n                        def.value = assign.right;\n                        remove(defs, def);\n                        defs.push(def);\n                        stat.body = make_sequence(expr, expr.expressions.slice(1));\n                        continue;\n                    }\n                }\n                if (stat instanceof AST_EmptyStatement) {\n                    body.shift();\n                    continue;\n                }\n                if (stat instanceof AST_BlockStatement && !insert_vars(stat.body)) {\n                    body.shift();\n                    continue;\n                }\n                break;\n            }\n            return body.length;\n        }\n    });\n\n    function scan_local_returns(fn, transform) {\n        fn.walk(new TreeWalker(function(node) {\n            if (node instanceof AST_Return) {\n                transform(node);\n                return true;\n            }\n            if (node instanceof AST_Scope && node !== fn) return true;\n        }));\n    }\n\n    function map_bool_returns(fn) {\n        var map = Object.create(null);\n        scan_local_returns(fn, function(node) {\n            var value = node.value;\n            if (value) value = value.tail_node();\n            if (value instanceof AST_SymbolRef) {\n                var id = value.definition().id;\n                map[id] = (map[id] || 0) + 1;\n            }\n        });\n        return map;\n    }\n\n    function all_bool(def, bool_returns, compressor) {\n        return def.bool_fn + (bool_returns[def.id] || 0) === def.references.length - def.replaced\n            && !compressor.exposed(def);\n    }\n\n    function process_boolean_returns(fn, compressor) {\n        scan_local_returns(fn, function(node) {\n            node.in_bool = true;\n            var value = node.value;\n            if (value) {\n                var ev = value.is_truthy() || value.evaluate(compressor, true);\n                if (!ev) {\n                    value = value.drop_side_effect_free(compressor);\n                    node.value = value ? make_sequence(node.value, [\n                        value,\n                        make_node(AST_Number, node.value, {\n                            value: 0\n                        })\n                    ]) : null;\n                } else if (ev && !(ev instanceof AST_Node)) {\n                    value = value.drop_side_effect_free(compressor);\n                    node.value = value ? make_sequence(node.value, [\n                        value,\n                        make_node(AST_Number, node.value, {\n                            value: 1\n                        })\n                    ]) : make_node(AST_Number, node.value, {\n                        value: 1\n                    });\n                }\n            }\n        });\n    }\n\n    AST_Scope.DEFMETHOD(\"process_boolean_returns\", noop);\n    AST_Defun.DEFMETHOD(\"process_boolean_returns\", function(compressor) {\n        if (!compressor.option(\"booleans\")) return;\n        var bool_returns = map_bool_returns(this);\n        if (!all_bool(this.name.definition(), bool_returns, compressor)) return;\n        process_boolean_returns(this, compressor);\n    });\n    AST_Function.DEFMETHOD(\"process_boolean_returns\", function(compressor) {\n        if (!compressor.option(\"booleans\")) return;\n        var bool_returns = map_bool_returns(this);\n        if (this.name && !all_bool(this.name.definition(), bool_returns, compressor)) return;\n        var parent = compressor.parent();\n        if (parent instanceof AST_Assign) {\n            if (parent.operator != \"=\") return;\n            var sym = parent.left;\n            if (!(sym instanceof AST_SymbolRef)) return;\n            if (!all_bool(sym.definition(), bool_returns, compressor)) return;\n        } else if (parent instanceof AST_Call && parent.expression !== this) {\n            var exp = parent.expression;\n            if (exp instanceof AST_SymbolRef) exp = exp.fixed_value();\n            if (!(exp instanceof AST_Lambda)) return;\n            if (exp.uses_arguments || exp.pinned()) return;\n            var sym = exp.argnames[parent.args.indexOf(this)];\n            if (sym instanceof AST_DefaultValue) sym = sym.name;\n            if (sym instanceof AST_SymbolFunarg && !all_bool(sym.definition(), bool_returns, compressor)) return;\n        } else if (parent.TYPE == \"Call\") {\n            compressor.pop();\n            var in_bool = compressor.in_boolean_context();\n            compressor.push(this);\n            if (!in_bool) return;\n        } else return;\n        process_boolean_returns(this, compressor);\n    });\n\n    AST_BlockScope.DEFMETHOD(\"var_names\", function() {\n        var var_names = this._var_names;\n        if (!var_names) {\n            this._var_names = var_names = Object.create(null);\n            this.enclosed.forEach(function(def) {\n                var_names[def.name] = true;\n            });\n            this.variables.each(function(def, name) {\n                var_names[name] = true;\n            });\n        }\n        return var_names;\n    });\n\n    AST_Scope.DEFMETHOD(\"make_var\", function(type, orig, prefix) {\n        var scopes = [ this ];\n        if (orig instanceof AST_SymbolDeclaration) orig.definition().references.forEach(function(ref) {\n            var s = ref.scope;\n            if (member(s, scopes)) return;\n            do {\n                push_uniq(scopes, s);\n                s = s.parent_scope;\n            } while (s && s !== this);\n        });\n        prefix = prefix.replace(/(?:^[^a-z_$]|[^a-z0-9_$])/ig, \"_\");\n        var name = prefix;\n        for (var i = 0; !all(scopes, function(scope) {\n            return !scope.var_names()[name];\n        }); i++) name = prefix + \"$\" + i;\n        var sym = make_node(type, orig, {\n            name: name,\n            scope: this,\n        });\n        var def = this.def_variable(sym);\n        scopes.forEach(function(scope) {\n            scope.enclosed.push(def);\n            scope.var_names()[name] = true;\n        });\n        return sym;\n    });\n\n    AST_Scope.DEFMETHOD(\"hoist_properties\", function(compressor) {\n        if (!compressor.option(\"hoist_props\") || compressor.has_directive(\"use asm\")) return;\n        var self = this;\n        var top_retain = self instanceof AST_Toplevel && compressor.top_retain || return_false;\n        var defs_by_id = Object.create(null);\n        self.transform(new TreeTransformer(function(node, descend) {\n            if (node instanceof AST_Assign) {\n                if (node.operator != \"=\") return;\n                if (!node.write_only) return;\n                if (node.left.scope !== self) return;\n                if (!can_hoist(node.left, node.right, 1)) return;\n                descend(node, this);\n                var defs = new Dictionary();\n                var assignments = [];\n                var decls = [];\n                node.right.properties.forEach(function(prop) {\n                    var decl = make_sym(node.left, prop.key);\n                    decls.push(make_node(AST_VarDef, node, {\n                        name: decl,\n                        value: null\n                    }));\n                    var sym = make_node(AST_SymbolRef, node, {\n                        name: decl.name,\n                        scope: self,\n                        thedef: decl.definition()\n                    });\n                    sym.reference({});\n                    assignments.push(make_node(AST_Assign, node, {\n                        operator: \"=\",\n                        left: sym,\n                        right: prop.value\n                    }));\n                });\n                defs_by_id[node.left.definition().id] = defs;\n                self.body.splice(self.body.indexOf(this.stack[1]) + 1, 0, make_node(AST_Var, node, {\n                    definitions: decls\n                }));\n                return make_sequence(node, assignments);\n            }\n            if (node instanceof AST_Scope) return node === self ? undefined : node;\n            if (node instanceof AST_VarDef) {\n                if (!can_hoist(node.name, node.value, 0)) return;\n                descend(node, this);\n                var defs = new Dictionary();\n                var var_defs = [];\n                node.value.properties.forEach(function(prop) {\n                    var_defs.push(make_node(AST_VarDef, node, {\n                        name: make_sym(node.name, prop.key),\n                        value: prop.value\n                    }));\n                });\n                defs_by_id[node.name.definition().id] = defs;\n                return List.splice(var_defs);\n            }\n\n            function make_sym(sym, key) {\n                var new_var = self.make_var(AST_SymbolVar, sym, sym.name + \"_\" + key);\n                defs.set(key, new_var.definition());\n                return new_var;\n            }\n        }));\n        self.transform(new TreeTransformer(function(node, descend) {\n            if (node instanceof AST_Binary) return replace(\"right\");\n            if (node instanceof AST_PropAccess) {\n                if (!(node.expression instanceof AST_SymbolRef)) return;\n                var defs = defs_by_id[node.expression.definition().id];\n                if (!defs) return;\n                var def = defs.get(node.getProperty());\n                var sym = make_node(AST_SymbolRef, node, {\n                    name: def.name,\n                    scope: node.expression.scope,\n                    thedef: def\n                });\n                sym.reference({});\n                return sym;\n            }\n            if (node instanceof AST_Unary) {\n                if (unary_side_effects[node.operator]) return;\n                return replace(\"expression\");\n            }\n\n            function replace(prop) {\n                var sym = node[prop];\n                if (!(sym instanceof AST_SymbolRef)) return;\n                if (!(sym.definition().id in defs_by_id)) return;\n                var opt = node.clone();\n                opt[prop] = make_node(AST_Object, sym, {\n                    properties: []\n                });\n                return opt;\n            }\n        }));\n\n        function can_hoist(sym, right, count) {\n            if (!(sym instanceof AST_Symbol)) return;\n            var def = sym.definition();\n            if (def.assignments != count) return;\n            if (def.direct_access) return;\n            if (def.escaped.depth == 1) return;\n            if (def.references.length - def.replaced == count) return;\n            if (def.single_use) return;\n            if (top_retain(def)) return;\n            if (sym.fixed_value() !== right) return;\n            return right instanceof AST_Object\n                && right.properties.length > 0\n                && all(right.properties, function(prop) {\n                    return prop instanceof AST_ObjectKeyVal && typeof prop.key == \"string\";\n                })\n                && all(def.references, function(ref) {\n                    return ref.fixed_value() === right;\n                })\n                && can_drop_symbol(sym);\n        }\n    });\n\n    function fn_name_unused(fn, compressor) {\n        if (!fn.name || !compressor.option(\"ie8\")) return true;\n        var def = fn.name.definition();\n        if (compressor.exposed(def)) return false;\n        return all(def.references, function(sym) {\n            return !(sym instanceof AST_SymbolRef);\n        });\n    }\n\n    // drop_side_effect_free()\n    // remove side-effect-free parts which only affects return value\n    (function(def) {\n        // Drop side-effect-free elements from an array of expressions.\n        // Returns an array of expressions with side-effects or null\n        // if all elements were dropped. Note: original array may be\n        // returned if nothing changed.\n        function trim(nodes, compressor, first_in_statement, spread) {\n            var len = nodes.length;\n            if (!len) return null;\n            var ret = [], changed = false;\n            for (var i = 0; i < len; i++) {\n                var node = nodes[i];\n                var trimmed;\n                if (spread && node instanceof AST_Spread) {\n                    trimmed = spread(node, compressor, first_in_statement);\n                } else {\n                    trimmed = node.drop_side_effect_free(compressor, first_in_statement);\n                }\n                if (trimmed !== node) changed = true;\n                if (trimmed) {\n                    ret.push(trimmed);\n                    first_in_statement = false;\n                }\n            }\n            return changed ? ret.length ? ret : null : nodes;\n        }\n        function array_spread(node, compressor, first_in_statement) {\n            var exp = node.expression;\n            if (!exp.is_string(compressor)) return node;\n            return exp.drop_side_effect_free(compressor, first_in_statement);\n        }\n        function convert_spread(node) {\n            return node instanceof AST_Spread ? make_node(AST_Array, node, {\n                elements: [ node ]\n            }) : node;\n        }\n        def(AST_Node, return_this);\n        def(AST_Accessor, return_null);\n        def(AST_Array, function(compressor, first_in_statement) {\n            var values = trim(this.elements, compressor, first_in_statement, array_spread);\n            if (!values) return null;\n            if (values === this.elements && all(values, function(node) {\n                return node instanceof AST_Spread;\n            })) return this;\n            return make_sequence(this, values.map(convert_spread));\n        });\n        def(AST_Arrow, return_null);\n        def(AST_Assign, function(compressor) {\n            var left = this.left;\n            if (left instanceof AST_PropAccess) {\n                var expr = left.expression;\n                if (expr instanceof AST_Assign && expr.operator == \"=\" && !expr.may_throw_on_access(compressor)) {\n                    expr.write_only = \"p\";\n                }\n                if (compressor.has_directive(\"use strict\") && expr.is_constant()) return this;\n            }\n            if (left.has_side_effects(compressor)) return this;\n            this.write_only = true;\n            if (root_expr(left).is_constant_expression(compressor.find_parent(AST_Scope))) {\n                return this.right.drop_side_effect_free(compressor);\n            }\n            return this;\n        });\n        def(AST_AsyncFunction, return_null);\n        def(AST_Binary, function(compressor, first_in_statement) {\n            if (this.operator == \"in\" && !is_object(this.right)) {\n                var left = this.left.drop_side_effect_free(compressor, first_in_statement);\n                if (left === this.left) return this;\n                var node = this.clone();\n                node.left = left || make_node(AST_Number, this.left, {\n                    value: 0\n                });\n                return node;\n            }\n            var right = this.right.drop_side_effect_free(compressor, first_in_statement);\n            if (!right) return this.left.drop_side_effect_free(compressor, first_in_statement);\n            if (lazy_op[this.operator] && !(right instanceof AST_Function)) {\n                var node = this;\n                if (right !== node.right) {\n                    node = this.clone();\n                    node.right = right.drop_side_effect_free(compressor);\n                }\n                return (first_in_statement ? best_of_statement : best_of_expression)(node, make_node(AST_Binary, this, {\n                    operator: node.operator == \"&&\" ? \"||\" : \"&&\",\n                    left: node.left.negate(compressor, first_in_statement),\n                    right: node.right\n                }));\n            } else {\n                var left = this.left.drop_side_effect_free(compressor, first_in_statement);\n                if (!left) return right;\n                return make_sequence(this, [ left, right.drop_side_effect_free(compressor) ]);\n            }\n        });\n        def(AST_Call, function(compressor, first_in_statement) {\n            var self = this;\n            if (self.is_expr_pure(compressor)) {\n                if (self.pure) AST_Node.warn(\"Dropping __PURE__ call [{file}:{line},{col}]\", self.start);\n                var args = trim(self.args, compressor, first_in_statement, array_spread);\n                return args && make_sequence(self, args.map(convert_spread));\n            }\n            var exp = self.expression;\n            if (self.is_call_pure(compressor)) {\n                var exprs = self.args.slice();\n                exprs.unshift(exp.expression);\n                exprs = trim(exprs, compressor, first_in_statement, array_spread);\n                return exprs && make_sequence(self, exprs.map(convert_spread));\n            }\n            var def;\n            if (exp instanceof AST_Function\n                && !(exp.name && (def = exp.name.definition()).references.length > def.replaced)) {\n                exp.process_expression(false, function(node) {\n                    var value = node.value && node.value.drop_side_effect_free(compressor, true);\n                    return value ? make_node(AST_SimpleStatement, node, {\n                        body: value\n                    }) : make_node(AST_EmptyStatement, node);\n                });\n                scan_local_returns(exp, function(node) {\n                    if (node.value) node.value = node.value.drop_side_effect_free(compressor);\n                });\n                // always shallow clone to ensure stripping of negated IIFEs\n                self = self.clone();\n                self.expression = exp.clone();\n            }\n            if (self instanceof AST_New) {\n                var fn = exp;\n                if (fn instanceof AST_SymbolRef) fn = fn.fixed_value();\n                if (fn instanceof AST_Lambda) {\n                    fn.new = true;\n                    var assign_this_only = all(fn.body, function(stat) {\n                        return !stat.has_side_effects(compressor);\n                    });\n                    delete fn.new;\n                    if (assign_this_only) {\n                        var exprs = self.args.slice();\n                        exprs.unshift(exp);\n                        exprs = trim(exprs, compressor, first_in_statement, array_spread);\n                        return exprs && make_sequence(self, exprs.map(convert_spread));\n                    }\n                    if (!fn.contains_this()) return make_node(AST_Call, self, self);\n                }\n            }\n            return self;\n        });\n        def(AST_Conditional, function(compressor) {\n            var consequent = this.consequent.drop_side_effect_free(compressor);\n            var alternative = this.alternative.drop_side_effect_free(compressor);\n            if (consequent === this.consequent && alternative === this.alternative) return this;\n            var exprs;\n            if (compressor.option(\"ie8\")) {\n                exprs = [];\n                if (consequent instanceof AST_Function) {\n                    exprs.push(consequent);\n                    consequent = null;\n                }\n                if (alternative instanceof AST_Function) {\n                    exprs.push(alternative);\n                    alternative = null;\n                }\n            }\n            var node;\n            if (!consequent) {\n                node = alternative ? make_node(AST_Binary, this, {\n                    operator: \"||\",\n                    left: this.condition,\n                    right: alternative\n                }) : this.condition.drop_side_effect_free(compressor);\n            } else if (!alternative) {\n                node = make_node(AST_Binary, this, {\n                    operator: \"&&\",\n                    left: this.condition,\n                    right: consequent\n                });\n            } else {\n                node = this.clone();\n                node.consequent = consequent;\n                node.alternative = alternative;\n            }\n            if (!compressor.option(\"ie8\")) return node;\n            if (node) exprs.push(node);\n            return exprs.length == 0 ? null : make_sequence(this, exprs);\n        });\n        def(AST_Constant, return_null);\n        def(AST_Dot, function(compressor, first_in_statement) {\n            var expr = this.expression;\n            if (expr.may_throw_on_access(compressor)) return this;\n            return expr.drop_side_effect_free(compressor, first_in_statement);\n        });\n        def(AST_Function, function(compressor) {\n            return fn_name_unused(this, compressor) ? null : this;\n        });\n        def(AST_Object, function(compressor, first_in_statement) {\n            var exprs = [];\n            this.properties.forEach(function(prop) {\n                if (prop instanceof AST_Spread) {\n                    exprs.push(prop);\n                } else {\n                    if (prop.key instanceof AST_Node) exprs.push(prop.key);\n                    exprs.push(prop.value);\n                }\n            });\n            var values = trim(exprs, compressor, first_in_statement, function(node, compressor, first_in_statement) {\n                var exp = node.expression;\n                return spread_side_effects(exp) ? node : exp.drop_side_effect_free(compressor, first_in_statement);\n            });\n            if (!values) return null;\n            if (values === exprs && !all(values, function(node) {\n                return !(node instanceof AST_Spread);\n            })) return this;\n            return make_sequence(this, values.map(function(node) {\n                return node instanceof AST_Spread ? make_node(AST_Object, node, {\n                    properties: [ node ],\n                }) : node;\n            }));\n        });\n        def(AST_Sequence, function(compressor, first_in_statement) {\n            var expressions = trim(this.expressions, compressor, first_in_statement);\n            if (!expressions) return null;\n            var end = expressions.length - 1;\n            var assign, cond, lhs;\n            if (compressor.option(\"conditionals\")\n                && end > 0\n                && (assign = expressions[end - 1]) instanceof AST_Assign\n                && assign.operator == \"=\"\n                && (lhs = assign.left) instanceof AST_SymbolRef\n                && (cond = to_conditional_assignment(compressor, lhs.definition(), assign.right, expressions[end]))) {\n                assign = assign.clone();\n                assign.right = cond;\n                expressions = expressions.slice(0, -2);\n                expressions.push(assign);\n            }\n            return expressions === this.expressions ? this : make_sequence(this, expressions);\n        });\n        def(AST_Sub, function(compressor, first_in_statement) {\n            if (this.expression.may_throw_on_access(compressor)) return this;\n            var expression = this.expression.drop_side_effect_free(compressor, first_in_statement);\n            if (!expression) return this.property.drop_side_effect_free(compressor, first_in_statement);\n            var property = this.property.drop_side_effect_free(compressor);\n            if (!property) return expression;\n            return make_sequence(this, [ expression, property ]);\n        });\n        def(AST_SymbolRef, function(compressor) {\n            return this.is_declared(compressor) && can_drop_symbol(this) ? null : this;\n        });\n        def(AST_This, return_null);\n        def(AST_Unary, function(compressor, first_in_statement) {\n            var exp = this.expression;\n            if (unary_side_effects[this.operator]) {\n                this.write_only = !exp.has_side_effects(compressor);\n                return this;\n            }\n            if (this.operator == \"typeof\" && exp instanceof AST_SymbolRef && can_drop_symbol(exp)) return null;\n            var node = exp.drop_side_effect_free(compressor, first_in_statement);\n            if (first_in_statement && node && is_iife_call(node)) {\n                if (node === exp && this.operator == \"!\") return this;\n                return node.negate(compressor, first_in_statement);\n            }\n            return node;\n        });\n    })(function(node, func) {\n        node.DEFMETHOD(\"drop_side_effect_free\", func);\n    });\n\n    OPT(AST_SimpleStatement, function(self, compressor) {\n        if (compressor.option(\"side_effects\")) {\n            var body = self.body;\n            var node = body.drop_side_effect_free(compressor, true);\n            if (!node) {\n                AST_Node.warn(\"Dropping side-effect-free statement [{file}:{line},{col}]\", self.start);\n                return make_node(AST_EmptyStatement, self);\n            }\n            if (node !== body) {\n                return make_node(AST_SimpleStatement, self, { body: node });\n            }\n        }\n        return self;\n    });\n\n    OPT(AST_While, function(self, compressor) {\n        return compressor.option(\"loops\") ? make_node(AST_For, self, self).optimize(compressor) : self;\n    });\n\n    function has_loop_control(loop, parent, type) {\n        if (!type) type = AST_LoopControl;\n        var found = false;\n        var tw = new TreeWalker(function(node) {\n            if (found || node instanceof AST_Scope) return true;\n            if (node instanceof type && tw.loopcontrol_target(node) === loop) {\n                return found = true;\n            }\n        });\n        if (parent instanceof AST_LabeledStatement) tw.push(parent);\n        tw.push(loop);\n        loop.body.walk(tw);\n        return found;\n    }\n\n    OPT(AST_Do, function(self, compressor) {\n        if (!compressor.option(\"loops\")) return self;\n        var cond = self.condition.is_truthy() || self.condition.evaluate(compressor, true);\n        if (!(cond instanceof AST_Node)) {\n            if (cond && !has_loop_control(self, compressor.parent(), AST_Continue)) return make_node(AST_For, self, {\n                body: make_node(AST_BlockStatement, self.body, {\n                    body: [\n                        self.body,\n                        make_node(AST_SimpleStatement, self.condition, {\n                            body: self.condition\n                        }),\n                    ]\n                })\n            }).optimize(compressor);\n            if (!has_loop_control(self, compressor.parent())) return make_node(AST_BlockStatement, self.body, {\n                body: [\n                    self.body,\n                    make_node(AST_SimpleStatement, self.condition, {\n                        body: self.condition\n                    }),\n                ]\n            }).optimize(compressor);\n        }\n        if (self.body instanceof AST_BlockStatement && !has_loop_control(self, compressor.parent(), AST_Continue)) {\n            var body = self.body.body;\n            for (var i = body.length; --i >= 0;) {\n                var stat = body[i];\n                if (stat instanceof AST_If\n                    && !stat.alternative\n                    && stat.body instanceof AST_Break\n                    && compressor.loopcontrol_target(stat.body) === self) {\n                    if (has_block_scope_refs(stat.condition)) break;\n                    self.condition = make_node(AST_Binary, self, {\n                        operator: \"&&\",\n                        left: stat.condition.negate(compressor),\n                        right: self.condition,\n                    });\n                    body.splice(i, 1);\n                } else if (stat instanceof AST_SimpleStatement) {\n                    if (has_block_scope_refs(stat.body)) break;\n                    self.condition = make_sequence(self, [\n                        stat.body,\n                        self.condition,\n                    ]);\n                    body.splice(i, 1);\n                } else if (!is_declaration(stat)) {\n                    break;\n                }\n            }\n            self.body = trim_block(self.body);\n        }\n        if (self.body instanceof AST_EmptyStatement) return make_node(AST_For, self, self).optimize(compressor);\n        if (self.body instanceof AST_SimpleStatement) return make_node(AST_For, self, {\n            condition: make_sequence(self.condition, [\n                self.body.body,\n                self.condition\n            ]),\n            body: make_node(AST_EmptyStatement, self)\n        }).optimize(compressor);\n        return self;\n\n        function has_block_scope_refs(node) {\n            var found = false;\n            node.walk(new TreeWalker(function(node) {\n                if (found) return true;\n                if (node instanceof AST_SymbolRef) {\n                    if (!member(node.definition(), self.enclosed)) found = true;\n                    return true;\n                }\n            }));\n            return found;\n        }\n    });\n\n    function if_break_in_loop(self, compressor) {\n        var first = first_statement(self.body);\n        if (compressor.option(\"dead_code\")\n            && (first instanceof AST_Break\n                || first instanceof AST_Continue && external_target(first)\n                || first instanceof AST_Exit)) {\n            var body = [];\n            if (self.init instanceof AST_Statement) {\n                body.push(self.init);\n            } else if (self.init) {\n                body.push(make_node(AST_SimpleStatement, self.init, {\n                    body: self.init\n                }));\n            }\n            var retain = external_target(first) || first instanceof AST_Exit;\n            if (self.condition && retain) {\n                body.push(make_node(AST_If, self, {\n                    condition: self.condition,\n                    body: first,\n                    alternative: null\n                }));\n            } else if (self.condition) {\n                body.push(make_node(AST_SimpleStatement, self.condition, {\n                    body: self.condition\n                }));\n            } else if (retain) {\n                body.push(first);\n            }\n            extract_declarations_from_unreachable_code(compressor, self.body, body);\n            return make_node(AST_BlockStatement, self, {\n                body: body\n            });\n        }\n        if (first instanceof AST_If) {\n            var ab = first_statement(first.body);\n            if (ab instanceof AST_Break && !external_target(ab)) {\n                if (self.condition) {\n                    self.condition = make_node(AST_Binary, self.condition, {\n                        left: self.condition,\n                        operator: \"&&\",\n                        right: first.condition.negate(compressor),\n                    });\n                } else {\n                    self.condition = first.condition.negate(compressor);\n                }\n                var body = as_statement_array(first.alternative);\n                extract_declarations_from_unreachable_code(compressor, first.body, body);\n                return drop_it(body);\n            }\n            ab = first_statement(first.alternative);\n            if (ab instanceof AST_Break && !external_target(ab)) {\n                if (self.condition) {\n                    self.condition = make_node(AST_Binary, self.condition, {\n                        left: self.condition,\n                        operator: \"&&\",\n                        right: first.condition,\n                    });\n                } else {\n                    self.condition = first.condition;\n                }\n                var body = as_statement_array(first.body);\n                extract_declarations_from_unreachable_code(compressor, first.alternative, body);\n                return drop_it(body);\n            }\n        }\n        return self;\n\n        function first_statement(body) {\n            return body instanceof AST_BlockStatement ? body.body[0] : body;\n        }\n\n        function external_target(node) {\n            return compressor.loopcontrol_target(node) !== compressor.self();\n        }\n\n        function drop_it(rest) {\n            if (self.body instanceof AST_BlockStatement) {\n                self.body = self.body.clone();\n                self.body.body = rest.concat(self.body.body.slice(1));\n                self.body = self.body.transform(compressor);\n            } else {\n                self.body = make_node(AST_BlockStatement, self.body, {\n                    body: rest\n                }).transform(compressor);\n            }\n            return if_break_in_loop(self, compressor);\n        }\n    }\n\n    OPT(AST_For, function(self, compressor) {\n        if (!compressor.option(\"loops\")) return self;\n        if (compressor.option(\"side_effects\")) {\n            if (self.init) self.init = self.init.drop_side_effect_free(compressor);\n            if (self.step) self.step = self.step.drop_side_effect_free(compressor);\n        }\n        if (self.condition) {\n            var cond = self.condition.evaluate(compressor);\n            if (cond instanceof AST_Node) {\n                cond = self.condition.is_truthy() || self.condition.evaluate(compressor, true);\n            } else if (cond) {\n                self.condition = null;\n            } else if (!compressor.option(\"dead_code\")) {\n                var orig = self.condition;\n                self.condition = make_node_from_constant(cond, self.condition);\n                self.condition = best_of_expression(self.condition.transform(compressor), orig);\n            }\n            if (!cond) {\n                if (compressor.option(\"dead_code\")) {\n                    var body = [];\n                    if (self.init instanceof AST_Statement) {\n                        body.push(self.init);\n                    } else if (self.init) {\n                        body.push(make_node(AST_SimpleStatement, self.init, {\n                            body: self.init\n                        }));\n                    }\n                    body.push(make_node(AST_SimpleStatement, self.condition, {\n                        body: self.condition\n                    }));\n                    extract_declarations_from_unreachable_code(compressor, self.body, body);\n                    return make_node(AST_BlockStatement, self, { body: body }).optimize(compressor);\n                }\n            } else if (self.condition && !(cond instanceof AST_Node)) {\n                self.body = make_node(AST_BlockStatement, self.body, {\n                    body: [\n                        make_node(AST_SimpleStatement, self.condition, {\n                            body: self.condition\n                        }),\n                        self.body\n                    ]\n                });\n                self.condition = null;\n            }\n        }\n        return if_break_in_loop(self, compressor);\n    });\n\n    OPT(AST_ForIn, function(self, compressor) {\n        if (compressor.option(\"varify\") && (self.init instanceof AST_Const || self.init instanceof AST_Let)) {\n            var name = self.init.definitions[0].name;\n            if ((name instanceof AST_Destructured || name instanceof AST_SymbolLet)\n                && !name.match_symbol(function(node) {\n                    if (node instanceof AST_SymbolDeclaration) return may_overlap(compressor, node.definition());\n                }, true)) {\n                self.init = to_var(self.init);\n            }\n        }\n        return self;\n    });\n\n    function mark_locally_defined(condition, consequent, alternative) {\n        if (!(condition instanceof AST_Binary)) return;\n        if (!(condition.left instanceof AST_String)) {\n            switch (condition.operator) {\n              case \"&&\":\n                mark_locally_defined(condition.left, consequent);\n                mark_locally_defined(condition.right, consequent);\n                break;\n              case \"||\":\n                mark_locally_defined(negate(condition.left), alternative);\n                mark_locally_defined(negate(condition.right), alternative);\n                break;\n            }\n            return;\n        }\n        if (!(condition.right instanceof AST_UnaryPrefix)) return;\n        if (condition.right.operator != \"typeof\") return;\n        var sym = condition.right.expression;\n        if (!is_undeclared_ref(sym)) return;\n        var body;\n        var undef = condition.left.value == \"undefined\";\n        switch (condition.operator) {\n          case \"==\":\n            body = undef ? alternative : consequent;\n            break;\n          case \"!=\":\n            body = undef ? consequent : alternative;\n            break;\n          default:\n            return;\n        }\n        if (!body) return;\n        var def = sym.definition();\n        var tw = new TreeWalker(function(node) {\n            if (node instanceof AST_Scope) {\n                var parent = tw.parent();\n                if (parent instanceof AST_Call && parent.expression === node) return;\n                return true;\n            }\n            if (node instanceof AST_SymbolRef && node.definition() === def) node.defined = true;\n        });\n        body.walk(tw);\n\n        function negate(node) {\n            if (!(node instanceof AST_Binary)) return;\n            switch (node.operator) {\n              case \"==\":\n                node = node.clone();\n                node.operator = \"!=\";\n                return node;\n              case \"!=\":\n                node = node.clone();\n                node.operator = \"==\";\n                return node;\n            }\n        }\n    }\n\n    OPT(AST_If, function(self, compressor) {\n        if (is_empty(self.alternative)) self.alternative = null;\n\n        if (!compressor.option(\"conditionals\")) return self;\n        // if condition can be statically determined, warn and drop\n        // one of the blocks.  note, statically determined implies\n        // “has no side effects”; also it doesn't work for cases like\n        // `x && true`, though it probably should.\n        var cond = self.condition.evaluate(compressor);\n        if (!compressor.option(\"dead_code\") && !(cond instanceof AST_Node)) {\n            var orig = self.condition;\n            self.condition = make_node_from_constant(cond, orig);\n            self.condition = best_of_expression(self.condition.transform(compressor), orig);\n        }\n        if (compressor.option(\"dead_code\")) {\n            if (cond instanceof AST_Node) {\n                cond = self.condition.is_truthy() || self.condition.evaluate(compressor, true);\n            }\n            if (!cond) {\n                AST_Node.warn(\"Condition always false [{file}:{line},{col}]\", self.condition.start);\n                var body = [\n                    make_node(AST_SimpleStatement, self.condition, {\n                        body: self.condition\n                    }),\n                ];\n                extract_declarations_from_unreachable_code(compressor, self.body, body);\n                if (self.alternative) body.push(self.alternative);\n                return make_node(AST_BlockStatement, self, { body: body }).optimize(compressor);\n            } else if (!(cond instanceof AST_Node)) {\n                AST_Node.warn(\"Condition always true [{file}:{line},{col}]\", self.condition.start);\n                var body = [\n                    make_node(AST_SimpleStatement, self.condition, {\n                        body: self.condition\n                    }),\n                    self.body,\n                ];\n                if (self.alternative) extract_declarations_from_unreachable_code(compressor, self.alternative, body);\n                return make_node(AST_BlockStatement, self, { body: body }).optimize(compressor);\n            }\n        }\n        var negated = self.condition.negate(compressor);\n        var self_condition_length = self.condition.print_to_string().length;\n        var negated_length = negated.print_to_string().length;\n        var negated_is_best = negated_length < self_condition_length;\n        if (self.alternative && negated_is_best) {\n            negated_is_best = false; // because we already do the switch here.\n            // no need to swap values of self_condition_length and negated_length\n            // here because they are only used in an equality comparison later on.\n            self.condition = negated;\n            var tmp = self.body;\n            self.body = self.alternative || make_node(AST_EmptyStatement, self);\n            self.alternative = tmp;\n        }\n        var body = [], var_defs = [], refs = [];\n        var body_exprs = sequencesize(self.body, body, var_defs, refs);\n        var alt_exprs = sequencesize(self.alternative, body, var_defs, refs);\n        if (body_exprs && alt_exprs) {\n            if (var_defs.length > 0) body.push(make_node(AST_Var, self, {\n                definitions: var_defs\n            }));\n            if (body_exprs.length == 0) {\n                body.push(make_node(AST_SimpleStatement, self.condition, {\n                    body: alt_exprs.length > 0 ? make_node(AST_Binary, self, {\n                        operator : \"||\",\n                        left     : self.condition,\n                        right    : make_sequence(self.alternative, alt_exprs)\n                    }).transform(compressor) : self.condition.clone()\n                }).optimize(compressor));\n            } else if (alt_exprs.length == 0) {\n                if (self_condition_length === negated_length && !negated_is_best\n                    && self.condition instanceof AST_Binary && self.condition.operator == \"||\") {\n                    // although the code length of self.condition and negated are the same,\n                    // negated does not require additional surrounding parentheses.\n                    // see https://github.com/mishoo/UglifyJS/issues/979\n                    negated_is_best = true;\n                }\n                body.push(make_node(AST_SimpleStatement, self, {\n                    body: make_node(AST_Binary, self, {\n                        operator : negated_is_best ? \"||\" : \"&&\",\n                        left     : negated_is_best ? negated : self.condition,\n                        right    : make_sequence(self.body, body_exprs)\n                    }).transform(compressor)\n                }).optimize(compressor));\n            } else {\n                body.push(make_node(AST_SimpleStatement, self, {\n                    body: make_node(AST_Conditional, self, {\n                        condition   : self.condition,\n                        consequent  : make_sequence(self.body, body_exprs),\n                        alternative : make_sequence(self.alternative, alt_exprs)\n                    })\n                }).optimize(compressor));\n            }\n            refs.forEach(function(ref) {\n                ref.definition().references.push(ref);\n            });\n            return make_node(AST_BlockStatement, self, {\n                body: body\n            }).optimize(compressor);\n        }\n        if (is_empty(self.body)) {\n            self = make_node(AST_If, self, {\n                condition: negated,\n                body: self.alternative,\n                alternative: null\n            });\n        }\n        if (self.body instanceof AST_Exit\n            && self.alternative instanceof AST_Exit\n            && self.body.TYPE == self.alternative.TYPE) {\n            var exit = make_node(self.body.CTOR, self, {\n                value: make_node(AST_Conditional, self, {\n                    condition   : self.condition,\n                    consequent  : self.body.value || make_node(AST_Undefined, self.body).transform(compressor),\n                    alternative : self.alternative.value || make_node(AST_Undefined, self.alternative).transform(compressor)\n                })\n            });\n            if (exit instanceof AST_Return) {\n                exit.in_bool = self.body.in_bool || self.alternative.in_bool;\n            }\n            return exit;\n        }\n        if (self.body instanceof AST_If\n            && !self.body.alternative\n            && !self.alternative) {\n            self = make_node(AST_If, self, {\n                condition: make_node(AST_Binary, self.condition, {\n                    operator: \"&&\",\n                    left: self.condition,\n                    right: self.body.condition\n                }),\n                body: self.body.body,\n                alternative: null\n            });\n        }\n        if (aborts(self.body)) {\n            if (self.alternative) {\n                var alt = self.alternative;\n                self.alternative = null;\n                return make_node(AST_BlockStatement, self, {\n                    body: [ self, alt ]\n                }).optimize(compressor);\n            }\n        }\n        if (aborts(self.alternative)) {\n            var body = self.body;\n            self.body = self.alternative;\n            self.condition = negated_is_best ? negated : self.condition.negate(compressor);\n            self.alternative = null;\n            return make_node(AST_BlockStatement, self, {\n                body: [ self, body ]\n            }).optimize(compressor);\n        }\n        if (compressor.option(\"typeofs\")) mark_locally_defined(self.condition, self.body, self.alternative);\n        return self;\n\n        function sequencesize(stat, defuns, var_defs, refs) {\n            if (stat == null) return [];\n            if (stat instanceof AST_BlockStatement) {\n                var exprs = [];\n                for (var i = 0; i < stat.body.length; i++) {\n                    var line = stat.body[i];\n                    if (line instanceof AST_Defun) {\n                        defuns.push(line);\n                    } else if (line instanceof AST_EmptyStatement) {\n                        continue;\n                    } else if (line instanceof AST_SimpleStatement) {\n                        if (!compressor.option(\"sequences\") && exprs.length > 0) return;\n                        exprs.push(line.body);\n                    } else if (line instanceof AST_Var) {\n                        if (!compressor.option(\"sequences\") && exprs.length > 0) return;\n                        line.remove_initializers(compressor, var_defs);\n                        line.definitions.forEach(process_var_def);\n                    } else {\n                        return;\n                    }\n                }\n                return exprs;\n            }\n            if (stat instanceof AST_Defun) {\n                defuns.push(stat);\n                return [];\n            }\n            if (stat instanceof AST_EmptyStatement) return [];\n            if (stat instanceof AST_SimpleStatement) return [ stat.body ];\n            if (stat instanceof AST_Var) {\n                var exprs = [];\n                stat.remove_initializers(compressor, var_defs);\n                stat.definitions.forEach(process_var_def);\n                return exprs;\n            }\n\n            function process_var_def(var_def) {\n                if (!var_def.value) return;\n                exprs.push(make_node(AST_Assign, var_def, {\n                    operator: \"=\",\n                    left: var_def.name.convert_symbol(AST_SymbolRef, function(ref) {\n                        refs.push(ref);\n                    }),\n                    right: var_def.value\n                }));\n            }\n        }\n    });\n\n    OPT(AST_Switch, function(self, compressor) {\n        if (!compressor.option(\"switches\")) return self;\n        var branch;\n        var value = self.expression.evaluate(compressor);\n        if (!(value instanceof AST_Node)) {\n            var orig = self.expression;\n            self.expression = make_node_from_constant(value, orig);\n            self.expression = best_of_expression(self.expression.transform(compressor), orig);\n        }\n        if (!compressor.option(\"dead_code\")) return self;\n        if (value instanceof AST_Node) {\n            value = self.expression.evaluate(compressor, true);\n        }\n        var decl = [];\n        var body = [];\n        var default_branch;\n        var exact_match;\n        for (var i = 0, len = self.body.length; i < len && !exact_match; i++) {\n            branch = self.body[i];\n            if (branch instanceof AST_Default) {\n                var prev = body[body.length - 1];\n                if (default_branch || is_break(branch.body[0], compressor) && (!prev || aborts(prev))) {\n                    eliminate_branch(branch, prev);\n                    continue;\n                } else {\n                    default_branch = branch;\n                }\n            } else if (!(value instanceof AST_Node)) {\n                var exp = branch.expression.evaluate(compressor);\n                if (!(exp instanceof AST_Node) && exp !== value) {\n                    eliminate_branch(branch, body[body.length - 1]);\n                    continue;\n                }\n                if (exp instanceof AST_Node) exp = branch.expression.evaluate(compressor, true);\n                if (exp === value) {\n                    exact_match = branch;\n                    if (default_branch) {\n                        var default_index = body.indexOf(default_branch);\n                        body.splice(default_index, 1);\n                        eliminate_branch(default_branch, body[default_index - 1]);\n                        default_branch = null;\n                    }\n                }\n            }\n            if (aborts(branch)) {\n                var prev = body[body.length - 1];\n                if (aborts(prev) && prev.body.length == branch.body.length\n                    && make_node(AST_BlockStatement, prev, prev).equivalent_to(make_node(AST_BlockStatement, branch, branch))) {\n                    prev.body = [];\n                }\n            }\n            body.push(branch);\n        }\n        while (i < len) eliminate_branch(self.body[i++], body[body.length - 1]);\n        while (branch = body[body.length - 1]) {\n            var stat = branch.body[branch.body.length - 1];\n            if (is_break(stat, compressor)) branch.body.pop();\n            if (branch === default_branch) {\n                if (!has_declarations_only(branch)) break;\n            } else if (branch.expression.has_side_effects(compressor)) {\n                break;\n            } else if (default_branch) {\n                if (!has_declarations_only(default_branch)) break;\n                if (body[body.length - 2] !== default_branch) break;\n                default_branch.body = default_branch.body.concat(branch.body);\n                branch.body = [];\n            } else if (!has_declarations_only(branch)) break;\n            eliminate_branch(branch);\n            if (body.pop() === default_branch) default_branch = null;\n        }\n        if (body.length == 0) {\n            return make_node(AST_BlockStatement, self, {\n                body: decl.concat(make_node(AST_SimpleStatement, self.expression, {\n                    body: self.expression\n                }))\n            }).optimize(compressor);\n        }\n        body[0].body = decl.concat(body[0].body);\n        self.body = body;\n        if (compressor.option(\"conditionals\")) switch (body.length) {\n          case 1:\n            if (!no_break(body[0])) break;\n            var exp = body[0].expression;\n            var statements = body[0].body.slice();\n            if (body[0] !== default_branch && body[0] !== exact_match) return make_node(AST_If, self, {\n                condition: make_node(AST_Binary, self, {\n                    operator: \"===\",\n                    left: self.expression,\n                    right: exp,\n                }),\n                body: make_node(AST_BlockStatement, self, {\n                    body: statements,\n                }),\n                alternative: null,\n            }).optimize(compressor);\n            if (exp) statements.unshift(make_node(AST_SimpleStatement, exp, {\n                body: exp,\n            }));\n            statements.unshift(make_node(AST_SimpleStatement, self.expression, {\n                body:self.expression,\n            }));\n            return make_node(AST_BlockStatement, self, {\n                body: statements,\n            }).optimize(compressor);\n          case 2:\n            if (!member(default_branch, body) || !no_break(body[1])) break;\n            var statements = body[0].body.slice();\n            var exclusive = statements.length && is_break(statements[statements.length - 1], compressor);\n            if (exclusive) statements.pop();\n            if (!all(statements, no_break)) break;\n            var alternative = body[1].body.length && make_node(AST_BlockStatement, body[1], body[1]);\n            var node = make_node(AST_If, self, {\n                condition: make_node(AST_Binary, self, body[0] === default_branch ? {\n                    operator: \"!==\",\n                    left: self.expression,\n                    right: body[1].expression,\n                } : {\n                    operator: \"===\",\n                    left: self.expression,\n                    right: body[0].expression,\n                }),\n                body: make_node(AST_BlockStatement, body[0], {\n                    body: statements,\n                }),\n                alternative: exclusive && alternative || null,\n            });\n            if (!exclusive && alternative) node = make_node(AST_BlockStatement, self, {\n                body: [ node, alternative ],\n            });\n            return node.optimize(compressor);\n        }\n        return self;\n\n        function is_break(node, tw) {\n            return node instanceof AST_Break && tw.loopcontrol_target(node) === self;\n        }\n\n        function no_break(node) {\n            var found = false;\n            var tw = new TreeWalker(function(node) {\n                if (found\n                    || node instanceof AST_Lambda\n                    || node instanceof AST_SimpleStatement) return true;\n                if (is_break(node, tw)) found = true;\n            });\n            tw.push(self);\n            node.walk(tw);\n            return !found;\n        }\n\n        function eliminate_branch(branch, prev) {\n            if (prev && !aborts(prev)) {\n                prev.body = prev.body.concat(branch.body);\n            } else {\n                extract_declarations_from_unreachable_code(compressor, branch, decl);\n            }\n        }\n    });\n\n    OPT(AST_Try, function(self, compressor) {\n        self.body = tighten_body(self.body, compressor);\n        if (compressor.option(\"dead_code\")) {\n            if (has_declarations_only(self)\n                && !(self.bcatch && self.bcatch.argname && self.bcatch.argname.match_symbol(function(node) {\n                    return node instanceof AST_SymbolCatch && !can_drop_symbol(node);\n                }, true))) {\n                var body = [];\n                if (self.bcatch) {\n                    extract_declarations_from_unreachable_code(compressor, self.bcatch, body);\n                    body.forEach(function(stat) {\n                        if (!(stat instanceof AST_Var)) return;\n                        stat.definitions.forEach(function(var_def) {\n                            var def = var_def.name.definition().redefined();\n                            if (!def) return;\n                            var_def.name = var_def.name.clone();\n                            var_def.name.thedef = def;\n                        });\n                    });\n                }\n                body.unshift(make_node(AST_BlockStatement, self, self).optimize(compressor));\n                if (self.bfinally) {\n                    body.push(make_node(AST_BlockStatement, self.bfinally, self.bfinally).optimize(compressor));\n                }\n                return make_node(AST_BlockStatement, self, {\n                    body: body\n                }).optimize(compressor);\n            }\n            if (self.bfinally && has_declarations_only(self.bfinally)) {\n                var body = make_node(AST_BlockStatement, self.bfinally, self.bfinally).optimize(compressor);\n                body = self.body.concat(body);\n                if (!self.bcatch) return make_node(AST_BlockStatement, self, {\n                    body: body\n                }).optimize(compressor);\n                self.body = body;\n                self.bfinally = null;\n            }\n        }\n        return self;\n    });\n\n    function remove_initializers(make_value) {\n        return function(compressor, defns) {\n            var dropped = false;\n            this.definitions.forEach(function(defn) {\n                if (defn.value) dropped = true;\n                defn.name.match_symbol(function(node) {\n                    if (node instanceof AST_SymbolDeclaration) defns.push(make_node(AST_VarDef, node, {\n                        name: node,\n                        value: make_value(compressor, node)\n                    }));\n                }, true);\n            });\n            return dropped;\n        };\n    }\n\n    AST_Const.DEFMETHOD(\"remove_initializers\", remove_initializers(function(compressor, node) {\n        return make_node(AST_Undefined, node).optimize(compressor);\n    }));\n    AST_Let.DEFMETHOD(\"remove_initializers\", remove_initializers(return_null));\n    AST_Var.DEFMETHOD(\"remove_initializers\", remove_initializers(return_null));\n\n    AST_Definitions.DEFMETHOD(\"to_assignments\", function() {\n        var assignments = this.definitions.reduce(function(a, defn) {\n            var def = defn.name.definition();\n            if (defn.value) {\n                var name = make_node(AST_SymbolRef, defn.name, defn.name);\n                a.push(make_node(AST_Assign, defn, {\n                    operator : \"=\",\n                    left     : name,\n                    right    : defn.value\n                }));\n                def.references.push(name);\n            }\n            def.eliminated++;\n            return a;\n        }, []);\n        if (assignments.length == 0) return null;\n        return make_sequence(this, assignments);\n    });\n\n    function is_safe_lexical(def) {\n        return def.name != \"arguments\" && def.orig.length < (def.orig[0] instanceof AST_SymbolLambda ? 3 : 2);\n    }\n\n    function may_overlap(compressor, def) {\n        if (compressor.exposed(def)) return true;\n        var scope = def.scope.resolve();\n        for (var s = def.scope; s !== scope;) {\n            s = s.parent_scope;\n            if (s.var_names()[def.name]) return true;\n        }\n    }\n\n    function to_var(stat) {\n        return make_node(AST_Var, stat, {\n            definitions: stat.definitions.map(function(defn) {\n                return make_node(AST_VarDef, defn, {\n                    name: defn.name.convert_symbol(AST_SymbolVar, function(name, node) {\n                        var def = name.definition();\n                        def.orig[def.orig.indexOf(node)] = name;\n                        var scope = def.scope.resolve();\n                        if (def.scope === scope) return;\n                        def.scope = scope;\n                        scope.variables.set(def.name, def);\n                    }),\n                    value: defn.value\n                });\n            })\n        });\n    }\n\n    function varify(self, compressor) {\n        return compressor.option(\"varify\") && all(self.definitions, function(defn) {\n            return !defn.name.match_symbol(function(node) {\n                if (node instanceof AST_SymbolDeclaration) {\n                    var def = node.definition();\n                    return !node.fixed_value() || !is_safe_lexical(def) || may_overlap(compressor, def);\n                }\n            }, true);\n        }) ? to_var(self) : self;\n    }\n\n    OPT(AST_Const, varify);\n    OPT(AST_Let, varify);\n\n    function lift_sequence_in_expression(node, compressor) {\n        var exp = node.expression;\n        if (!(exp instanceof AST_Sequence)) return node;\n        var x = exp.expressions.slice();\n        var e = node.clone();\n        e.expression = x.pop();\n        x.push(e);\n        return make_sequence(node, x);\n    }\n\n    function drop_unused_call_args(call, compressor, fns_with_marked_args) {\n        var exp = call.expression;\n        var fn = exp instanceof AST_SymbolRef ? exp.fixed_value() : exp;\n        if (!(fn instanceof AST_Lambda)) return;\n        if (fn.uses_arguments) return;\n        if (fn.pinned()) return;\n        if (fns_with_marked_args && fns_with_marked_args.indexOf(fn) < 0) return;\n        var args = call.args;\n        if (!all(args, function(arg) {\n            return !(arg instanceof AST_Spread);\n        })) return;\n        var pos = 0, last = 0;\n        var drop_fargs = fn === exp && !fn.name && compressor.drop_fargs(fn, call) ? function(argname, arg) {\n            if (!argname) return true;\n            if (argname instanceof AST_DestructuredArray) {\n                return argname.elements.length == 0 && arg instanceof AST_Array;\n            }\n            if (argname instanceof AST_DestructuredObject) {\n                return argname.properties.length == 0 && arg && !arg.may_throw_on_access(compressor);\n            }\n            return argname.__unused;\n        } : return_false;\n        var side_effects = [];\n        for (var i = 0; i < args.length; i++) {\n            var argname = fn.argnames[i];\n            if (compressor.option(\"default_values\")\n                && argname instanceof AST_DefaultValue\n                && args[i].is_defined(compressor)) {\n                fn.argnames[i] = argname = argname.name;\n            }\n            if (!argname || \"__unused\" in argname) {\n                var node = args[i].drop_side_effect_free(compressor);\n                if (drop_fargs(argname)) {\n                    if (argname) fn.argnames.splice(i, 1);\n                    args.splice(i, 1);\n                    if (node) side_effects.push(node);\n                    i--;\n                    continue;\n                } else if (node) {\n                    side_effects.push(node);\n                    args[pos++] = make_sequence(call, side_effects);\n                    side_effects = [];\n                } else if (argname) {\n                    if (side_effects.length) {\n                        args[pos++] = make_sequence(call, side_effects);\n                        side_effects = [];\n                    } else {\n                        args[pos++] = make_node(AST_Number, args[i], {\n                            value: 0\n                        });\n                        continue;\n                    }\n                }\n            } else if (argname && drop_fargs(argname, args[i])) {\n                var node = args[i].drop_side_effect_free(compressor);\n                fn.argnames.splice(i, 1);\n                args.splice(i, 1);\n                if (node) side_effects.push(node);\n                i--;\n                continue;\n            } else {\n                side_effects.push(args[i]);\n                args[pos++] = make_sequence(call, side_effects);\n                side_effects = [];\n            }\n            last = pos;\n        }\n        for (; i < fn.argnames.length; i++) {\n            if (drop_fargs(fn.argnames[i])) fn.argnames.splice(i--, 1);\n        }\n        args.length = last;\n        if (!side_effects.length) return;\n        var arg = make_sequence(call, side_effects);\n        args.push(args.length < fn.argnames.length ? make_node(AST_UnaryPrefix, call, {\n            operator: \"void\",\n            expression: arg\n        }) : arg);\n    }\n\n    OPT(AST_Call, function(self, compressor) {\n        var exp = self.expression;\n        if (compressor.option(\"sequences\")) {\n            if (exp instanceof AST_PropAccess) {\n                var seq = lift_sequence_in_expression(exp, compressor);\n                if (seq !== exp) {\n                    var call = self.clone();\n                    call.expression = seq.expressions.pop();\n                    seq.expressions.push(call);\n                    return seq.optimize(compressor);\n                }\n            } else if (!needs_unbinding(compressor, exp.tail_node())) {\n                var seq = lift_sequence_in_expression(self, compressor);\n                if (seq !== self) return seq.optimize(compressor);\n            }\n        }\n        if (compressor.option(\"unused\")) drop_unused_call_args(self, compressor);\n        if (compressor.option(\"unsafe\")) {\n            if (is_undeclared_ref(exp)) switch (exp.name) {\n              case \"Array\":\n                if (self.args.length == 1) {\n                    var first = self.args[0];\n                    if (first instanceof AST_Number) try {\n                        var length = first.value;\n                        if (length > 6) break;\n                        var elements = Array(length);\n                        for (var i = 0; i < length; i++) elements[i] = make_node(AST_Hole, self);\n                        return make_node(AST_Array, self, {\n                            elements: elements\n                        });\n                    } catch (ex) {\n                        AST_Node.warn(\"Invalid array length: {length} [{file}:{line},{col}]\", {\n                            length: length,\n                            file: self.start.file,\n                            line: self.start.line,\n                            col: self.start.col,\n                        });\n                        break;\n                    }\n                    if (!first.is_boolean(compressor) && !first.is_string(compressor)) break;\n                }\n                return make_node(AST_Array, self, {\n                    elements: self.args\n                });\n              case \"Object\":\n                if (self.args.length == 0) {\n                    return make_node(AST_Object, self, {\n                        properties: []\n                    });\n                }\n                break;\n              case \"String\":\n                if (self.args.length == 0) return make_node(AST_String, self, {\n                    value: \"\"\n                });\n                if (self.args.length <= 1) return make_node(AST_Binary, self, {\n                    left: self.args[0],\n                    operator: \"+\",\n                    right: make_node(AST_String, self, { value: \"\" })\n                }).optimize(compressor);\n                break;\n              case \"Number\":\n                if (self.args.length == 0) return make_node(AST_Number, self, {\n                    value: 0\n                });\n                if (self.args.length == 1) return make_node(AST_UnaryPrefix, self, {\n                    expression: self.args[0],\n                    operator: \"+\"\n                }).optimize(compressor);\n              case \"Boolean\":\n                if (self.args.length == 0) return make_node(AST_False, self);\n                if (self.args.length == 1) return make_node(AST_UnaryPrefix, self, {\n                    expression: make_node(AST_UnaryPrefix, self, {\n                        expression: self.args[0],\n                        operator: \"!\"\n                    }),\n                    operator: \"!\"\n                }).optimize(compressor);\n                break;\n              case \"RegExp\":\n                var params = [];\n                if (all(self.args, function(arg) {\n                    var value = arg.evaluate(compressor);\n                    params.unshift(value);\n                    return arg !== value;\n                })) {\n                    try {\n                        return best_of(compressor, self, make_node(AST_RegExp, self, {\n                            value: RegExp.apply(RegExp, params),\n                        }));\n                    } catch (ex) {\n                        AST_Node.warn(\"Error converting {expr} [{file}:{line},{col}]\", {\n                            expr: self,\n                            file: self.start.file,\n                            line: self.start.line,\n                            col: self.start.col,\n                        });\n                    }\n                }\n                break;\n            } else if (exp instanceof AST_Dot) switch(exp.property) {\n              case \"toString\":\n                if (self.args.length == 0 && !exp.expression.may_throw_on_access(compressor)) {\n                    return make_node(AST_Binary, self, {\n                        left: make_node(AST_String, self, { value: \"\" }),\n                        operator: \"+\",\n                        right: exp.expression\n                    }).optimize(compressor);\n                }\n                break;\n              case \"join\":\n                if (exp.expression instanceof AST_Array) EXIT: {\n                    var separator;\n                    if (self.args.length > 0) {\n                        separator = self.args[0].evaluate(compressor);\n                        if (separator === self.args[0]) break EXIT; // not a constant\n                    }\n                    var elements = [];\n                    var consts = [];\n                    exp.expression.elements.forEach(function(el) {\n                        var value = el.evaluate(compressor);\n                        if (value !== el) {\n                            consts.push(value);\n                        } else {\n                            if (consts.length > 0) {\n                                elements.push(make_node(AST_String, self, {\n                                    value: consts.join(separator)\n                                }));\n                                consts.length = 0;\n                            }\n                            elements.push(el);\n                        }\n                    });\n                    if (consts.length > 0) {\n                        elements.push(make_node(AST_String, self, {\n                            value: consts.join(separator)\n                        }));\n                    }\n                    if (elements.length == 0) return make_node(AST_String, self, { value: \"\" });\n                    if (elements.length == 1) {\n                        if (elements[0].is_string(compressor)) {\n                            return elements[0];\n                        }\n                        return make_node(AST_Binary, elements[0], {\n                            operator : \"+\",\n                            left     : make_node(AST_String, self, { value: \"\" }),\n                            right    : elements[0]\n                        });\n                    }\n                    if (separator == \"\") {\n                        var first;\n                        if (elements[0].is_string(compressor)\n                            || elements[1].is_string(compressor)) {\n                            first = elements.shift();\n                        } else {\n                            first = make_node(AST_String, self, { value: \"\" });\n                        }\n                        return elements.reduce(function(prev, el) {\n                            return make_node(AST_Binary, el, {\n                                operator : \"+\",\n                                left     : prev,\n                                right    : el\n                            });\n                        }, first).optimize(compressor);\n                    }\n                    // need this awkward cloning to not affect original element\n                    // best_of will decide which one to get through.\n                    var node = self.clone();\n                    node.expression = node.expression.clone();\n                    node.expression.expression = node.expression.expression.clone();\n                    node.expression.expression.elements = elements;\n                    return best_of(compressor, self, node);\n                }\n                break;\n              case \"charAt\":\n                if (self.args.length < 2) {\n                    var node = make_node(AST_Sub, self, {\n                        expression: exp.expression,\n                        property: self.args.length ? make_node(AST_Binary, self.args[0], {\n                            operator: \"|\",\n                            left: make_node(AST_Number, self, {\n                                value: 0\n                            }),\n                            right: self.args[0]\n                        }) : make_node(AST_Number, self, {\n                            value: 0\n                        })\n                    });\n                    node.is_string = return_true;\n                    return node.optimize(compressor);\n                }\n                break;\n              case \"apply\":\n                if (self.args.length == 2 && self.args[1] instanceof AST_Array) {\n                    var args = self.args[1].elements.slice();\n                    args.unshift(self.args[0]);\n                    return make_node(AST_Call, self, {\n                        expression: make_node(AST_Dot, exp, {\n                            expression: exp.expression,\n                            property: \"call\"\n                        }),\n                        args: args\n                    }).optimize(compressor);\n                }\n                break;\n              case \"call\":\n                var func = exp.expression;\n                if (func instanceof AST_SymbolRef) {\n                    func = func.fixed_value();\n                }\n                if (func instanceof AST_Lambda && !func.contains_this()) {\n                    return (self.args.length ? make_sequence(this, [\n                        self.args[0],\n                        make_node(AST_Call, self, {\n                            expression: exp.expression,\n                            args: self.args.slice(1)\n                        })\n                    ]) : make_node(AST_Call, self, {\n                        expression: exp.expression,\n                        args: []\n                    })).optimize(compressor);\n                }\n                break;\n            }\n        }\n        if (compressor.option(\"unsafe_Function\")\n            && is_undeclared_ref(exp)\n            && exp.name == \"Function\") {\n            // new Function() => function(){}\n            if (self.args.length == 0) return make_node(AST_Function, self, {\n                argnames: [],\n                body: []\n            }).init_vars(exp.scope);\n            if (all(self.args, function(x) {\n                return x instanceof AST_String;\n            })) {\n                // quite a corner-case, but we can handle it:\n                //   https://github.com/mishoo/UglifyJS/issues/203\n                // if the code argument is a constant, then we can minify it.\n                try {\n                    var code = \"n(function(\" + self.args.slice(0, -1).map(function(arg) {\n                        return arg.value;\n                    }).join(\",\") + \"){\" + self.args[self.args.length - 1].value + \"})\";\n                    var ast = parse(code);\n                    var mangle = { ie8: compressor.option(\"ie8\") };\n                    ast.figure_out_scope(mangle);\n                    var comp = new Compressor(compressor.options);\n                    ast = ast.transform(comp);\n                    ast.figure_out_scope(mangle);\n                    ast.compute_char_frequency(mangle);\n                    ast.mangle_names(mangle);\n                    var fun;\n                    ast.walk(new TreeWalker(function(node) {\n                        if (fun) return true;\n                        if (node instanceof AST_Lambda) {\n                            fun = node;\n                            return true;\n                        }\n                    }));\n                    var code = OutputStream();\n                    AST_BlockStatement.prototype._codegen.call(fun, code);\n                    self.args = [\n                        make_node(AST_String, self, {\n                            value: fun.argnames.map(function(arg) {\n                                return arg.print_to_string();\n                            }).join(\",\")\n                        }),\n                        make_node(AST_String, self.args[self.args.length - 1], {\n                            value: code.get().replace(/^\\{|\\}$/g, \"\")\n                        })\n                    ];\n                    return self;\n                } catch (ex) {\n                    if (ex instanceof JS_Parse_Error) {\n                        AST_Node.warn(\"Error parsing code passed to new Function [{file}:{line},{col}]\", self.args[self.args.length - 1].start);\n                        AST_Node.warn(ex.toString());\n                    } else {\n                        throw ex;\n                    }\n                }\n            }\n        }\n        var fn = exp instanceof AST_SymbolRef ? exp.fixed_value() : exp;\n        var is_func = fn instanceof AST_Arrow || fn instanceof AST_Defun || fn instanceof AST_Function;\n        var stat = is_func && fn.first_statement();\n        var has_default = false;\n        var can_drop = is_func && all(fn.argnames, function(argname, index) {\n            if (argname instanceof AST_DefaultValue) {\n                has_default = true;\n                var arg = self.args[index];\n                if (arg && !is_undefined(arg)) return false;\n                var abort = false;\n                argname.value.walk(new TreeWalker(function(node) {\n                    if (abort) return true;\n                    if (node instanceof AST_SymbolRef && fn.find_variable(node.name) === node.definition()) {\n                        return abort = true;\n                    }\n                }));\n                if (abort) return false;\n                argname = argname.name;\n            }\n            return !(argname instanceof AST_Destructured);\n        });\n        var can_inline = can_drop && compressor.option(\"inline\") && !self.is_expr_pure(compressor);\n        if (can_inline && stat instanceof AST_Return) {\n            var value = stat.value;\n            if (exp === fn && (!value || value.is_constant_expression() && safe_from_await(value))) {\n                return make_sequence(self, convert_args(value)).optimize(compressor);\n            }\n        }\n        if (is_func) {\n            var def, value, var_assigned = false;\n            if (can_inline\n                && !fn.uses_arguments\n                && !fn.pinned()\n                && !(fn.name && fn instanceof AST_Function)\n                && (exp === fn || !recursive_ref(compressor, def = exp.definition())\n                    && fn.is_constant_expression(find_scope(compressor)))\n                && all(self.args, function(arg) {\n                    return !(arg instanceof AST_Spread);\n                })\n                && (value = can_flatten_body(stat))\n                && !fn.contains_this()) {\n                var replacing = exp === fn || def.single_use && def.references.length - def.replaced == 1;\n                if (can_substitute_directly()) {\n                    var args = self.args.slice();\n                    var refs = [];\n                    args.push(value.clone(true).transform(new TreeTransformer(function(node) {\n                        if (node instanceof AST_SymbolRef) {\n                            var def = node.definition();\n                            if (fn.variables.get(node.name) !== def) {\n                                refs.push(node);\n                                return node;\n                            }\n                            var index = resolve_index(def);\n                            var arg = args[index];\n                            if (!arg) return make_node(AST_Undefined, self);\n                            args[index] = null;\n                            var parent = this.parent();\n                            return parent ? maintain_this_binding(compressor, parent, node, arg) : arg;\n                        }\n                    })));\n                    var node = make_sequence(self, args.filter(function(arg) {\n                        return arg;\n                    })).optimize(compressor);\n                    node = maintain_this_binding(compressor, compressor.parent(), compressor.self(), node);\n                    if (replacing || best_of_expression(node, self) === node) {\n                        refs.forEach(function(ref) {\n                            var def = ref.definition();\n                            def.references.push(ref);\n                            if (replacing) {\n                                def.replaced++;\n                            } else {\n                                def.single_use = false;\n                            }\n                        });\n                        return node;\n                    }\n                }\n                var insert, in_loop, scope;\n                if (replacing && can_inject_symbols()) {\n                    fn._squeezed = true;\n                    if (exp !== fn) fn.parent_scope = exp.scope;\n                    var node = make_sequence(self, flatten_fn()).optimize(compressor);\n                    return maintain_this_binding(compressor, compressor.parent(), compressor.self(), node);\n                }\n            }\n            if (compressor.option(\"side_effects\")\n                && can_drop\n                && all(fn.body, is_empty)\n                && (fn !== exp || fn_name_unused(fn, compressor))\n                && !(fn instanceof AST_Arrow && fn.value)) {\n                return make_sequence(self, convert_args()).optimize(compressor);\n            }\n        }\n        if (compressor.option(\"drop_console\")) {\n            if (exp instanceof AST_PropAccess) {\n                var name = exp.expression;\n                while (name.expression) {\n                    name = name.expression;\n                }\n                if (is_undeclared_ref(name) && name.name == \"console\") {\n                    return make_node(AST_Undefined, self).optimize(compressor);\n                }\n            }\n        }\n        if (compressor.option(\"negate_iife\")\n            && compressor.parent() instanceof AST_SimpleStatement\n            && is_iife_call(self)) {\n            return self.negate(compressor, true);\n        }\n        return try_evaluate(compressor, self);\n\n        function convert_args(value) {\n            var args = self.args.map(function(arg) {\n                return arg instanceof AST_Spread ? make_node(AST_Array, arg, {\n                    elements: [ arg ],\n                }) : arg;\n            });\n            fn.argnames.forEach(function(argname, index) {\n                if (argname instanceof AST_DefaultValue) args.push(argname.value);\n            });\n            args.push(value || make_node(AST_Undefined, self));\n            return args;\n        }\n\n        function safe_from_await(node) {\n            if (!is_async(scope || compressor.find_parent(AST_Scope))) return true;\n            var safe = true;\n            var tw = new TreeWalker(function(node) {\n                if (!safe) return true;\n                if (node instanceof AST_Scope) {\n                    if (node === fn) return;\n                    if (node instanceof AST_Arrow) {\n                        for (var i = 0; safe && i < node.argnames.length; i++) node.argnames[i].walk(tw);\n                    } else if (is_defun(node) && node.name.name == \"await\") {\n                        safe = false;\n                    }\n                    return true;\n                }\n                if (node instanceof AST_Symbol && node.name == \"await\" && node !== fn.name) safe = false;\n            });\n            node.walk(tw);\n            return safe;\n        }\n\n        function return_value(stat) {\n            if (!stat) return make_node(AST_Undefined, self);\n            if (stat instanceof AST_Return) return stat.value || make_node(AST_Undefined, self);\n            if (stat instanceof AST_SimpleStatement) return make_node(AST_UnaryPrefix, stat, {\n                operator: \"void\",\n                expression: stat.body\n            });\n        }\n\n        function can_flatten_body(stat) {\n            var len = fn.body.length;\n            if (len < 2) {\n                stat = return_value(stat);\n                if (stat) return stat;\n            }\n            if (compressor.option(\"inline\") < 3) return false;\n            stat = null;\n            for (var i = 0; i < len; i++) {\n                var line = fn.body[i];\n                if (line instanceof AST_Var) {\n                    var assigned = var_assigned || !all(line.definitions, function(var_def) {\n                        return !var_def.value;\n                    });\n                    if (assigned) {\n                        var_assigned = true;\n                        if (stat) return false;\n                    }\n                } else if (line instanceof AST_AsyncDefun\n                    || line instanceof AST_Defun\n                    || line instanceof AST_EmptyStatement) {\n                    continue;\n                } else if (stat) {\n                    return false;\n                } else {\n                    stat = line;\n                }\n            }\n            return return_value(stat);\n        }\n\n        function resolve_index(def) {\n            for (var i = fn.argnames.length; --i >= 0;) {\n                if (fn.argnames[i].definition() === def) return i;\n            }\n        }\n\n        function can_substitute_directly() {\n            if (has_default) return;\n            if (var_assigned) return;\n            if (compressor.option(\"inline\") < 2 && fn.argnames.length) return;\n            if (!fn.variables.all(function(def) {\n                return def.references.length - def.replaced < 2 && def.orig[0] instanceof AST_SymbolFunarg;\n            })) return;\n            var abort = false;\n            var begin;\n            var in_order = [];\n            var side_effects = false;\n            var verify_await = true;\n            value.walk(new TreeWalker(function(node, descend) {\n                if (abort) return true;\n                if (node instanceof AST_Binary && lazy_op[node.operator]\n                    || node instanceof AST_Conditional) {\n                    in_order = null;\n                    return;\n                }\n                if (node instanceof AST_Scope) return abort = true;\n                if (verify_await && node instanceof AST_Symbol && node.name == \"await\") {\n                    if (is_async(compressor.find_parent(AST_Scope))) return abort = true;\n                    verify_await = false;\n                }\n                if (node instanceof AST_SymbolRef) {\n                    var def = node.definition();\n                    if (fn.variables.get(node.name) !== def) {\n                        in_order = null;\n                        return;\n                    }\n                    if (is_defun(def.init)) return abort = true;\n                    if (is_lhs(node, this.parent())) return abort = true;\n                    var index = resolve_index(def);\n                    if (!(begin < index)) begin = index;\n                    if (!in_order) return;\n                    if (side_effects) {\n                        in_order = null;\n                    } else {\n                        in_order.push(fn.argnames[index]);\n                    }\n                    return;\n                }\n                if (node.has_side_effects(compressor)) {\n                    descend();\n                    side_effects = true;\n                    return true;\n                }\n            }));\n            if (abort) return;\n            var end = self.args.length;\n            if (in_order && fn.argnames.length >= end) {\n                end = fn.argnames.length;\n                while (end-- > begin && fn.argnames[end] === in_order.pop());\n                end++;\n            }\n            var scope = side_effects && !in_order && compressor.find_parent(AST_Scope);\n            return end <= begin || all(self.args.slice(begin, end), scope ? function(funarg) {\n                return funarg.is_constant_expression(scope);\n            } : function(funarg) {\n                return !funarg.has_side_effects(compressor);\n            });\n        }\n\n        function var_exists(defined, name) {\n            return defined[name] || identifier_atom[name] || scope.var_names()[name];\n        }\n\n        function can_inject_args(defined, used, safe_to_inject) {\n            for (var i = 0; i < fn.argnames.length; i++) {\n                var arg = fn.argnames[i];\n                if (arg.__unused) continue;\n                if (arg instanceof AST_DefaultValue) arg = arg.name;\n                if (!safe_to_inject || var_exists(defined, arg.name)) return false;\n                used[arg.name] = true;\n                if (in_loop) in_loop.push(arg.definition());\n            }\n            return true;\n        }\n\n        function can_inject_vars(defined, used, safe_to_inject) {\n            for (var i = 0; i < fn.body.length; i++) {\n                var stat = fn.body[i];\n                if (is_defun(stat)) {\n                    if (!safe_to_inject || var_exists(used, stat.name.name)) return false;\n                    if (!all(stat.enclosed, function(def) {\n                        return def.scope === stat || !defined[def.name];\n                    })) return false;\n                    continue;\n                }\n                if (!(stat instanceof AST_Var)) continue;\n                if (!safe_to_inject) return false;\n                for (var j = stat.definitions.length; --j >= 0;) {\n                    var name = stat.definitions[j].name;\n                    if (var_exists(defined, name.name)) return false;\n                    if (in_loop) in_loop.push(name.definition());\n                }\n            }\n            return true;\n        }\n\n        function can_inject_symbols() {\n            var defined = Object.create(null);\n            var level = 0, child;\n            scope = compressor.self();\n            do {\n                if (scope.variables) scope.variables.each(function(def) {\n                    defined[def.name] = true;\n                });\n                child = scope;\n                scope = compressor.parent(level++);\n                if (scope instanceof AST_DWLoop) {\n                    in_loop = [];\n                } else if (scope instanceof AST_For) {\n                    if (scope.init === child) continue;\n                    in_loop = [];\n                } else if (scope instanceof AST_ForIn) {\n                    if (scope.init === child) continue;\n                    if (scope.object === child) continue;\n                    in_loop = [];\n                } else if (scope instanceof AST_SymbolRef) {\n                    if (scope.fixed_value() instanceof AST_Scope) return false;\n                }\n            } while (!(scope instanceof AST_Scope));\n            insert = scope.body.indexOf(child) + 1;\n            if (!insert) return false;\n            if (!safe_from_await(fn)) return false;\n            var safe_to_inject = exp !== fn || fn.parent_scope.resolve() === scope;\n            if (scope instanceof AST_Toplevel) {\n                if (compressor.toplevel.vars) {\n                    defined[\"arguments\"] = true;\n                } else {\n                    safe_to_inject = false;\n                }\n            }\n            var inline = compressor.option(\"inline\");\n            var used = Object.create(defined);\n            if (!can_inject_args(defined, used, inline >= 2 && safe_to_inject)) return false;\n            if (!can_inject_vars(defined, used, inline >= 3 && safe_to_inject)) return false;\n            return !in_loop || in_loop.length == 0 || !is_reachable(fn, in_loop);\n        }\n\n        function append_var(decls, expressions, name, value) {\n            var def = name.definition();\n            scope.variables.set(name.name, def);\n            scope.enclosed.push(def);\n            if (!scope.var_names()[name.name]) {\n                scope.var_names()[name.name] = true;\n                decls.push(make_node(AST_VarDef, name, {\n                    name: name,\n                    value: null\n                }));\n            }\n            if (!value) return;\n            var sym = make_node(AST_SymbolRef, name, name);\n            def.references.push(sym);\n            expressions.push(make_node(AST_Assign, self, {\n                operator: \"=\",\n                left: sym,\n                right: value\n            }));\n        }\n\n        function flatten_args(decls, expressions) {\n            var len = fn.argnames.length;\n            for (var i = self.args.length; --i >= len;) {\n                expressions.push(self.args[i]);\n            }\n            for (i = len; --i >= 0;) {\n                var name = fn.argnames[i];\n                var value = self.args[i];\n                if (name instanceof AST_DefaultValue) {\n                    value = value ? make_sequence(self, [ value, name.value ]) : name.value;\n                    name = name.name;\n                }\n                if (name.__unused || scope.var_names()[name.name]) {\n                    if (value) expressions.push(value);\n                } else {\n                    var symbol = make_node(AST_SymbolVar, name, name);\n                    name.definition().orig.push(symbol);\n                    if (!value && in_loop) value = make_node(AST_Undefined, self);\n                    if (\"__unused\" in name) {\n                        append_var(decls, expressions, symbol);\n                        if (value) expressions.push(value);\n                    } else {\n                        append_var(decls, expressions, symbol, value);\n                    }\n                }\n            }\n            decls.reverse();\n            expressions.reverse();\n        }\n\n        function flatten_vars(decls, expressions) {\n            var pos = expressions.length;\n            for (var i = 0; i < fn.body.length; i++) {\n                var stat = fn.body[i];\n                if (!(stat instanceof AST_Var)) continue;\n                for (var j = 0; j < stat.definitions.length; j++) {\n                    var var_def = stat.definitions[j];\n                    var name = var_def.name;\n                    var redef = name.definition().redefined();\n                    if (redef) {\n                        name = name.clone();\n                        name.thedef = redef;\n                    }\n                    append_var(decls, expressions, name, var_def.value);\n                    if (in_loop && all(fn.argnames, function(argname) {\n                        if (argname instanceof AST_DefaultValue) argname = argname.name;\n                        return argname.name != name.name;\n                    })) {\n                        var def = fn.variables.get(name.name);\n                        var sym = make_node(AST_SymbolRef, name, name);\n                        def.references.push(sym);\n                        expressions.splice(pos++, 0, make_node(AST_Assign, var_def, {\n                            operator: \"=\",\n                            left: sym,\n                            right: make_node(AST_Undefined, name)\n                        }));\n                    }\n                }\n            }\n        }\n\n        function flatten_fn() {\n            var decls = [];\n            var expressions = [];\n            flatten_args(decls, expressions);\n            flatten_vars(decls, expressions);\n            expressions.push(value);\n            var args = fn.body.filter(function(stat) {\n                if (is_defun(stat)) {\n                    var def = stat.name.definition();\n                    scope.functions.set(def.name, def);\n                    scope.variables.set(def.name, def);\n                    scope.enclosed.push(def);\n                    scope.var_names()[def.name] = true;\n                    return true;\n                }\n            });\n            args.unshift(insert, 0);\n            if (decls.length) args.push(make_node(AST_Var, fn, {\n                definitions: decls\n            }));\n            [].splice.apply(scope.body, args);\n            fn.enclosed.forEach(function(def) {\n                if (scope.var_names()[def.name]) return;\n                scope.enclosed.push(def);\n                scope.var_names()[def.name] = true;\n            });\n            return expressions;\n        }\n    });\n\n    OPT(AST_New, function(self, compressor) {\n        if (compressor.option(\"sequences\")) {\n            var seq = lift_sequence_in_expression(self, compressor);\n            if (seq !== self) return seq.optimize(compressor);\n        }\n        if (compressor.option(\"unsafe\")) {\n            var exp = self.expression;\n            if (is_undeclared_ref(exp)) {\n                switch (exp.name) {\n                  case \"Object\":\n                  case \"RegExp\":\n                  case \"Function\":\n                  case \"Error\":\n                  case \"Array\":\n                    return make_node(AST_Call, self, self).transform(compressor);\n                }\n            }\n        }\n        return self;\n    });\n\n    // (a = b, x && a = c) => a = x ? c : b\n    // (a = b, x || a = c) => a = x ? b : c\n    function to_conditional_assignment(compressor, def, value, node) {\n        if (!(node instanceof AST_Binary)) return;\n        if (!lazy_op[node.operator]) return;\n        if (!(node.right instanceof AST_Assign)) return;\n        if (node.right.operator != \"=\") return;\n        if (!(node.right.left instanceof AST_SymbolRef)) return;\n        if (node.right.left.definition() !== def) return;\n        if (value.has_side_effects(compressor)) return;\n        if (!safe_from_assignment(node.left)) return;\n        if (!safe_from_assignment(node.right.right)) return;\n        def.replaced++;\n        return node.operator == \"&&\" ? make_node(AST_Conditional, node, {\n            condition: node.left,\n            consequent: node.right.right,\n            alternative: value\n        }) : make_node(AST_Conditional, node, {\n            condition: node.left,\n            consequent: value,\n            alternative: node.right.right\n        });\n\n        function safe_from_assignment(node) {\n            if (node.has_side_effects(compressor)) return;\n            var hit = false;\n            node.walk(new TreeWalker(function(node) {\n                if (hit) return true;\n                if (node instanceof AST_SymbolRef && node.definition() === def) return hit = true;\n            }));\n            return !hit;\n        }\n    }\n\n    OPT(AST_Sequence, function(self, compressor) {\n        var expressions = filter_for_side_effects();\n        var end = expressions.length - 1;\n        merge_conditional_assignments();\n        trim_right_for_undefined();\n        if (end == 0) {\n            self = maintain_this_binding(compressor, compressor.parent(), compressor.self(), expressions[0]);\n            if (!(self instanceof AST_Sequence)) self = self.optimize(compressor);\n            return self;\n        }\n        self.expressions = expressions;\n        return self;\n\n        function filter_for_side_effects() {\n            if (!compressor.option(\"side_effects\")) return self.expressions;\n            var expressions = [];\n            var first = first_in_statement(compressor);\n            var last = self.expressions.length - 1;\n            self.expressions.forEach(function(expr, index) {\n                if (index < last) expr = expr.drop_side_effect_free(compressor, first);\n                if (expr) {\n                    merge_sequence(expressions, expr);\n                    first = false;\n                }\n            });\n            return expressions;\n        }\n\n        function trim_right_for_undefined() {\n            if (!compressor.option(\"side_effects\")) return;\n            while (end > 0 && is_undefined(expressions[end], compressor)) end--;\n            if (end < expressions.length - 1) {\n                expressions[end] = make_node(AST_UnaryPrefix, self, {\n                    operator   : \"void\",\n                    expression : expressions[end]\n                });\n                expressions.length = end + 1;\n            }\n        }\n\n        function merge_conditional_assignments() {\n            if (!compressor.option(\"conditionals\")) return;\n            for (var i = 1; i < end; i++) {\n                var assign = expressions[i - 1];\n                if (!(assign instanceof AST_Assign)) continue;\n                if (assign.operator != \"=\") continue;\n                if (!(assign.left instanceof AST_SymbolRef)) continue;\n                var def = assign.left.definition();\n                var cond = to_conditional_assignment(compressor, def, assign.right, expressions[i]);\n                if (!cond) continue;\n                assign.right = cond;\n                expressions.splice(i, 1);\n                end--;\n            }\n        }\n    });\n\n    OPT(AST_UnaryPostfix, function(self, compressor) {\n        if (compressor.option(\"sequences\")) {\n            var seq = lift_sequence_in_expression(self, compressor);\n            if (seq !== self) return seq.optimize(compressor);\n        }\n        return try_evaluate(compressor, self);\n    });\n\n    var SIGN_OPS = makePredicate(\"+ -\");\n    var MULTIPLICATIVE_OPS = makePredicate(\"* / %\");\n    OPT(AST_UnaryPrefix, function(self, compressor) {\n        var op = self.operator;\n        var exp = self.expression;\n        if (compressor.option(\"evaluate\")\n            && op == \"delete\"\n            && !(exp instanceof AST_SymbolRef\n                || exp instanceof AST_PropAccess\n                || is_identifier_atom(exp))) {\n            if (exp instanceof AST_Sequence) {\n                exp = exp.expressions.slice();\n                exp.push(make_node(AST_True, self));\n                return make_sequence(self, exp).optimize(compressor);\n            }\n            return make_sequence(self, [ exp, make_node(AST_True, self) ]).optimize(compressor);\n        }\n        if (compressor.option(\"sequences\") && !(op == \"typeof\" && is_undeclared_ref(exp.tail_node()))) {\n            var seq = lift_sequence_in_expression(self, compressor);\n            if (seq !== self) return seq.optimize(compressor);\n        }\n        if (compressor.option(\"side_effects\") && op == \"void\") {\n            exp = exp.drop_side_effect_free(compressor);\n            if (!exp) return make_node(AST_Undefined, self).optimize(compressor);\n            self.expression = exp;\n            return self;\n        }\n        if (compressor.option(\"booleans\")) {\n            if (op == \"!\" && exp.is_truthy()) {\n                return make_sequence(self, [ exp, make_node(AST_False, self) ]).optimize(compressor);\n            } else if (compressor.in_boolean_context()) switch (op) {\n              case \"!\":\n                if (exp instanceof AST_UnaryPrefix && exp.operator == \"!\") {\n                    // !!foo => foo, if we're in boolean context\n                    return exp.expression;\n                }\n                if (exp instanceof AST_Binary) {\n                    self = best_of(compressor, self, exp.negate(compressor, first_in_statement(compressor)));\n                }\n                break;\n              case \"typeof\":\n                // typeof always returns a non-empty string, thus it's\n                // always true in booleans\n                AST_Node.warn(\"Boolean expression always true [{file}:{line},{col}]\", self.start);\n                var exprs = [ make_node(AST_True, self) ];\n                if (!(exp instanceof AST_SymbolRef && can_drop_symbol(exp))) exprs.unshift(exp);\n                return make_sequence(self, exprs).optimize(compressor);\n            }\n        }\n        if (op == \"-\" && exp instanceof AST_Infinity) exp = exp.transform(compressor);\n        if (compressor.option(\"evaluate\")\n            && exp instanceof AST_Binary\n            && SIGN_OPS[op]\n            && MULTIPLICATIVE_OPS[exp.operator]\n            && (exp.left.is_constant() || !exp.right.has_side_effects(compressor))) {\n            return make_node(AST_Binary, self, {\n                operator: exp.operator,\n                left: make_node(AST_UnaryPrefix, exp.left, {\n                    operator: op,\n                    expression: exp.left\n                }),\n                right: exp.right\n            });\n        }\n        // avoids infinite recursion of numerals\n        return op == \"-\" && (exp instanceof AST_Number || exp instanceof AST_Infinity)\n            ? self : try_evaluate(compressor, self);\n    });\n\n    AST_Binary.DEFMETHOD(\"lift_sequences\", function(compressor) {\n        if (this.left instanceof AST_PropAccess) {\n            if (!(this.left.expression instanceof AST_Sequence)) return this;\n            var x = this.left.expression.expressions.slice();\n            var e = this.clone();\n            e.left = e.left.clone();\n            e.left.expression = x.pop();\n            x.push(e);\n            return make_sequence(this, x);\n        }\n        if (this.left instanceof AST_Sequence) {\n            var x = this.left.expressions.slice();\n            var e = this.clone();\n            e.left = x.pop();\n            x.push(e);\n            return make_sequence(this, x);\n        }\n        if (this.right instanceof AST_Sequence) {\n            if (this.left.has_side_effects(compressor)) return this;\n            var assign = this.operator == \"=\" && this.left instanceof AST_SymbolRef;\n            var x = this.right.expressions;\n            var last = x.length - 1;\n            for (var i = 0; i < last; i++) {\n                if (!assign && x[i].has_side_effects(compressor)) break;\n            }\n            if (i == last) {\n                x = x.slice();\n                var e = this.clone();\n                e.right = x.pop();\n                x.push(e);\n                return make_sequence(this, x);\n            }\n            if (i > 0) {\n                var e = this.clone();\n                e.right = make_sequence(this.right, x.slice(i));\n                x = x.slice(0, i);\n                x.push(e);\n                return make_sequence(this, x);\n            }\n        }\n        return this;\n    });\n\n    var indexFns = makePredicate(\"indexOf lastIndexOf\");\n    var commutativeOperators = makePredicate(\"== === != !== * & | ^\");\n    function is_object(node) {\n        if (node instanceof AST_Assign) return node.operator == \"=\" && is_object(node.right);\n        if (node instanceof AST_Sequence) return is_object(node.tail_node());\n        if (node instanceof AST_SymbolRef) return is_object(node.fixed_value());\n        return node instanceof AST_Array\n            || node instanceof AST_Lambda\n            || node instanceof AST_New\n            || node instanceof AST_Object;\n    }\n\n    function repeatable(compressor, node) {\n        if (node instanceof AST_Dot) return repeatable(compressor, node.expression);\n        if (node instanceof AST_Sub) {\n            return repeatable(compressor, node.expression) && repeatable(compressor, node.property);\n        }\n        if (node instanceof AST_Symbol) return true;\n        return !node.has_side_effects(compressor);\n    }\n\n    OPT(AST_Binary, function(self, compressor) {\n        function reversible() {\n            return self.left.is_constant()\n                || self.right.is_constant()\n                || !self.left.has_side_effects(compressor)\n                    && !self.right.has_side_effects(compressor);\n        }\n        function reverse(op) {\n            if (reversible()) {\n                if (op) self.operator = op;\n                var tmp = self.left;\n                self.left = self.right;\n                self.right = tmp;\n            }\n        }\n        function swap_chain() {\n            var rhs = self.right;\n            self.left = make_node(AST_Binary, self, {\n                operator: self.operator,\n                left: self.left,\n                right: rhs.left,\n                start: self.left.start,\n                end: rhs.left.end\n            });\n            self.right = rhs.right;\n            self.left = self.left.transform(compressor);\n        }\n        if (commutativeOperators[self.operator]\n            && self.right.is_constant()\n            && !self.left.is_constant()\n            && !(self.left instanceof AST_Binary\n                && PRECEDENCE[self.left.operator] >= PRECEDENCE[self.operator])) {\n            // if right is a constant, whatever side effects the\n            // left side might have could not influence the\n            // result.  hence, force switch.\n            reverse();\n        }\n        if (compressor.option(\"sequences\")) {\n            var seq = self.lift_sequences(compressor);\n            if (seq !== self) return seq.optimize(compressor);\n        }\n        if (compressor.option(\"assignments\") && lazy_op[self.operator]) {\n            var assign = self.right;\n            // a || (a = x) => a = a || x\n            // a && (a = x) => a = a && x\n            if (self.left instanceof AST_SymbolRef\n                && assign instanceof AST_Assign\n                && assign.operator == \"=\"\n                && self.left.equivalent_to(assign.left)) {\n                self.right = assign.right;\n                assign.right = self;\n                return assign;\n            }\n        }\n        if (compressor.option(\"comparisons\")) switch (self.operator) {\n          case \"===\":\n          case \"!==\":\n            if (is_undefined(self.left, compressor) && self.right.is_defined(compressor)) {\n                AST_Node.warn(\"Expression always defined [{file}:{line},{col}]\", self.start);\n                return make_sequence(self, [\n                    self.right,\n                    make_node(self.operator == \"===\" ? AST_False : AST_True, self)\n                ]).optimize(compressor);\n            }\n            var is_strict_comparison = true;\n            if ((self.left.is_string(compressor) && self.right.is_string(compressor)) ||\n                (self.left.is_number(compressor) && self.right.is_number(compressor)) ||\n                (self.left.is_boolean(compressor) && self.right.is_boolean(compressor)) ||\n                repeatable(compressor, self.left) && self.left.equivalent_to(self.right)) {\n                self.operator = self.operator.slice(0, 2);\n            }\n            // XXX: intentionally falling down to the next case\n          case \"==\":\n          case \"!=\":\n            // void 0 == x => null == x\n            if (!is_strict_comparison && is_undefined(self.left, compressor)) {\n                self.left = make_node(AST_Null, self.left);\n            }\n            // \"undefined\" == typeof x => undefined === x\n            else if (compressor.option(\"typeofs\")\n                && self.left instanceof AST_String\n                && self.left.value == \"undefined\"\n                && self.right instanceof AST_UnaryPrefix\n                && self.right.operator == \"typeof\") {\n                var expr = self.right.expression;\n                if (expr instanceof AST_SymbolRef ? expr.is_declared(compressor)\n                    : !(expr instanceof AST_PropAccess && compressor.option(\"ie8\"))) {\n                    self.right = expr;\n                    self.left = make_node(AST_Undefined, self.left).optimize(compressor);\n                    if (self.operator.length == 2) self.operator += \"=\";\n                }\n            }\n            // obj !== obj => false\n            else if (self.left instanceof AST_SymbolRef\n                && self.right instanceof AST_SymbolRef\n                && self.left.definition() === self.right.definition()\n                && is_object(self.left)) {\n                return make_node(self.operator[0] == \"=\" ? AST_True : AST_False, self).optimize(compressor);\n            }\n            break;\n          case \"&&\":\n          case \"||\":\n            // void 0 !== x && null !== x => null != x\n            // void 0 === x || null === x => null == x\n            var lhs = self.left;\n            if (lhs.operator == self.operator) {\n                lhs = lhs.right;\n            }\n            if (lhs instanceof AST_Binary\n                && lhs.operator == (self.operator == \"&&\" ? \"!==\" : \"===\")\n                && self.right instanceof AST_Binary\n                && lhs.operator == self.right.operator\n                && (is_undefined(lhs.left, compressor) && self.right.left instanceof AST_Null\n                    || lhs.left instanceof AST_Null && is_undefined(self.right.left, compressor))\n                && !lhs.right.has_side_effects(compressor)\n                && lhs.right.equivalent_to(self.right.right)) {\n                var combined = make_node(AST_Binary, self, {\n                    operator: lhs.operator.slice(0, -1),\n                    left: make_node(AST_Null, self),\n                    right: lhs.right\n                });\n                if (lhs !== self.left) {\n                    combined = make_node(AST_Binary, self, {\n                        operator: self.operator,\n                        left: self.left.left,\n                        right: combined\n                    });\n                }\n                return combined;\n            }\n            break;\n        }\n        var in_bool = compressor.option(\"booleans\") && compressor.in_boolean_context();\n        if (in_bool) switch (self.operator) {\n          case \"+\":\n            var ll = self.left.evaluate(compressor);\n            var rr = self.right.evaluate(compressor);\n            if (ll && typeof ll == \"string\") {\n                AST_Node.warn(\"+ in boolean context always true [{file}:{line},{col}]\", self.start);\n                return make_sequence(self, [\n                    self.right,\n                    make_node(AST_True, self)\n                ]).optimize(compressor);\n            }\n            if (rr && typeof rr == \"string\") {\n                AST_Node.warn(\"+ in boolean context always true [{file}:{line},{col}]\", self.start);\n                return make_sequence(self, [\n                    self.left,\n                    make_node(AST_True, self)\n                ]).optimize(compressor);\n            }\n            break;\n          case \"==\":\n            if (self.left instanceof AST_String && self.left.value == \"\" && self.right.is_string(compressor)) {\n                return make_node(AST_UnaryPrefix, self, {\n                    operator: \"!\",\n                    expression: self.right\n                }).optimize(compressor);\n            }\n            break;\n          case \"!=\":\n            if (self.left instanceof AST_String && self.left.value == \"\" && self.right.is_string(compressor)) {\n                return self.right.optimize(compressor);\n            }\n            break;\n        }\n        var parent = compressor.parent();\n        if (compressor.option(\"comparisons\") && self.is_boolean(compressor)) {\n            if (!(parent instanceof AST_Binary) || parent instanceof AST_Assign) {\n                var negated = best_of(compressor, self, make_node(AST_UnaryPrefix, self, {\n                    operator: \"!\",\n                    expression: self.negate(compressor, first_in_statement(compressor))\n                }));\n                if (negated !== self) return negated;\n            }\n            switch (self.operator) {\n              case \">\": reverse(\"<\"); break;\n              case \">=\": reverse(\"<=\"); break;\n            }\n        }\n        // x && (y && z) => x && y && z\n        // x || (y || z) => x || y || z\n        if (compressor.option(\"conditionals\")\n            && lazy_op[self.operator]\n            && self.right instanceof AST_Binary\n            && self.operator == self.right.operator) {\n            swap_chain();\n        }\n        if (compressor.option(\"strings\") && self.operator == \"+\") {\n            // \"foo\" + 42 + \"\" => \"foo\" + 42\n            if (self.right instanceof AST_String\n                && self.right.value == \"\"\n                && self.left.is_string(compressor)) {\n                return self.left.optimize(compressor);\n            }\n            // \"\" + (\"foo\" + 42) => \"foo\" + 42\n            if (self.left instanceof AST_String\n                && self.left.value == \"\"\n                && self.right.is_string(compressor)) {\n                return self.right.optimize(compressor);\n            }\n            // \"\" + 42 + \"foo\" => 42 + \"foo\"\n            if (self.left instanceof AST_Binary\n                && self.left.operator == \"+\"\n                && self.left.left instanceof AST_String\n                && self.left.left.value == \"\"\n                && self.right.is_string(compressor)) {\n                self.left = self.left.right;\n                return self.optimize(compressor);\n            }\n            // \"x\" + (y + \"z\") => \"x\" + y + \"z\"\n            // x + (\"y\" + z) => x + \"y\" + z\n            if (self.right instanceof AST_Binary\n                && self.operator == self.right.operator\n                && (self.left.is_string(compressor) && self.right.is_string(compressor)\n                    || self.right.left.is_string(compressor)\n                        && (self.left.is_constant() || !self.right.right.has_side_effects(compressor)))) {\n                swap_chain();\n            }\n        }\n        if (compressor.option(\"evaluate\")) {\n            var associative = true;\n            switch (self.operator) {\n              case \"&&\":\n                var ll = fuzzy_eval(self.left);\n                if (!ll) {\n                    AST_Node.warn(\"Condition left of && always false [{file}:{line},{col}]\", self.start);\n                    return maintain_this_binding(compressor, parent, compressor.self(), self.left).optimize(compressor);\n                } else if (!(ll instanceof AST_Node)) {\n                    AST_Node.warn(\"Condition left of && always true [{file}:{line},{col}]\", self.start);\n                    return make_sequence(self, [ self.left, self.right ]).optimize(compressor);\n                }\n                var rr = self.right.evaluate(compressor);\n                if (!rr) {\n                    if (in_bool) {\n                        AST_Node.warn(\"Boolean && always false [{file}:{line},{col}]\", self.start);\n                        return make_sequence(self, [\n                            self.left,\n                            make_node(AST_False, self)\n                        ]).optimize(compressor);\n                    } else self.falsy = true;\n                } else if (!(rr instanceof AST_Node)) {\n                    if (in_bool || parent.operator == \"&&\" && parent.left === compressor.self()) {\n                        AST_Node.warn(\"Dropping side-effect-free && [{file}:{line},{col}]\", self.start);\n                        return self.left.optimize(compressor);\n                    }\n                }\n                // (x || false) && y => x ? y : false\n                if (self.left.operator == \"||\") {\n                    var lr = self.left.right.evaluate(compressor, true);\n                    if (!lr) return make_node(AST_Conditional, self, {\n                        condition: self.left.left,\n                        consequent: self.right,\n                        alternative: self.left.right\n                    }).optimize(compressor);\n                }\n                break;\n              case \"||\":\n                var ll = fuzzy_eval(self.left);\n                if (!ll) {\n                    AST_Node.warn(\"Condition left of || always false [{file}:{line},{col}]\", self.start);\n                    return make_sequence(self, [ self.left, self.right ]).optimize(compressor);\n                } else if (!(ll instanceof AST_Node)) {\n                    AST_Node.warn(\"Condition left of || always true [{file}:{line},{col}]\", self.start);\n                    return maintain_this_binding(compressor, parent, compressor.self(), self.left).optimize(compressor);\n                }\n                var rr = self.right.evaluate(compressor);\n                if (!rr) {\n                    if (in_bool || parent.operator == \"||\" && parent.left === compressor.self()) {\n                        AST_Node.warn(\"Dropping side-effect-free || [{file}:{line},{col}]\", self.start);\n                        return self.left.optimize(compressor);\n                    }\n                } else if (!(rr instanceof AST_Node)) {\n                    if (in_bool) {\n                        AST_Node.warn(\"Boolean || always true [{file}:{line},{col}]\", self.start);\n                        return make_sequence(self, [\n                            self.left,\n                            make_node(AST_True, self)\n                        ]).optimize(compressor);\n                    } else self.truthy = true;\n                }\n                // x && true || y => x ? true : y\n                if (self.left.operator == \"&&\") {\n                    var lr = self.left.right.is_truthy() || self.left.right.evaluate(compressor, true);\n                    if (lr && !(lr instanceof AST_Node)) return make_node(AST_Conditional, self, {\n                        condition: self.left.left,\n                        consequent: self.left.right,\n                        alternative: self.right\n                    }).optimize(compressor);\n                }\n                break;\n              case \"+\":\n                // \"foo\" + (\"bar\" + x) => \"foobar\" + x\n                if (self.left instanceof AST_Constant\n                    && self.right instanceof AST_Binary\n                    && self.right.operator == \"+\"\n                    && self.right.left instanceof AST_Constant\n                    && self.right.is_string(compressor)) {\n                    self = make_node(AST_Binary, self, {\n                        operator: \"+\",\n                        left: make_node(AST_String, self.left, {\n                            value: \"\" + self.left.value + self.right.left.value,\n                            start: self.left.start,\n                            end: self.right.left.end\n                        }),\n                        right: self.right.right\n                    });\n                }\n                // (x + \"foo\") + \"bar\" => x + \"foobar\"\n                if (self.right instanceof AST_Constant\n                    && self.left instanceof AST_Binary\n                    && self.left.operator == \"+\"\n                    && self.left.right instanceof AST_Constant\n                    && self.left.is_string(compressor)) {\n                    self = make_node(AST_Binary, self, {\n                        operator: \"+\",\n                        left: self.left.left,\n                        right: make_node(AST_String, self.right, {\n                            value: \"\" + self.left.right.value + self.right.value,\n                            start: self.left.right.start,\n                            end: self.right.end\n                        })\n                    });\n                }\n                // a + -b => a - b\n                if (self.right instanceof AST_UnaryPrefix\n                    && self.right.operator == \"-\"\n                    && self.left.is_number(compressor)) {\n                    self = make_node(AST_Binary, self, {\n                        operator: \"-\",\n                        left: self.left,\n                        right: self.right.expression\n                    });\n                    break;\n                }\n                // -a + b => b - a\n                if (self.left instanceof AST_UnaryPrefix\n                    && self.left.operator == \"-\"\n                    && reversible()\n                    && self.right.is_number(compressor)) {\n                    self = make_node(AST_Binary, self, {\n                        operator: \"-\",\n                        left: self.right,\n                        right: self.left.expression\n                    });\n                    break;\n                }\n                // (a + b) + 3 => 3 + (a + b)\n                if (compressor.option(\"unsafe_math\")\n                    && self.left instanceof AST_Binary\n                    && PRECEDENCE[self.left.operator] == PRECEDENCE[self.operator]\n                    && self.right.is_constant()\n                    && (self.right.is_boolean(compressor) || self.right.is_number(compressor))\n                    && self.left.is_number(compressor)\n                    && !self.left.right.is_constant()\n                    && (self.left.left.is_boolean(compressor) || self.left.left.is_number(compressor))) {\n                    self = make_node(AST_Binary, self, {\n                        operator: self.left.operator,\n                        left: make_node(AST_Binary, self, {\n                            operator: self.operator,\n                            left: self.right,\n                            right: self.left.left\n                        }),\n                        right: self.left.right\n                    });\n                    break;\n                }\n              case \"-\":\n                // a - -b => a + b\n                if (self.right instanceof AST_UnaryPrefix\n                    && self.right.operator == \"-\"\n                    && self.left.is_number(compressor)\n                    && self.right.expression.is_number(compressor)) {\n                    self = make_node(AST_Binary, self, {\n                        operator: \"+\",\n                        left: self.left,\n                        right: self.right.expression\n                    });\n                    break;\n                }\n              case \"*\":\n              case \"/\":\n                associative = compressor.option(\"unsafe_math\");\n                // +a - b => a - b\n                // a - +b => a - b\n                if (self.operator != \"+\") [ \"left\", \"right\" ].forEach(function(operand) {\n                    var node = self[operand];\n                    if (node instanceof AST_UnaryPrefix && node.operator == \"+\") {\n                        var exp = node.expression;\n                        if (exp.is_boolean(compressor) || exp.is_number(compressor) || exp.is_string(compressor)) {\n                            self[operand] = exp;\n                        }\n                    }\n                });\n              case \"&\":\n              case \"|\":\n              case \"^\":\n                // a + +b => +b + a\n                if (self.operator != \"-\"\n                    && self.operator != \"/\"\n                    && (self.left.is_boolean(compressor) || self.left.is_number(compressor))\n                    && (self.right.is_boolean(compressor) || self.right.is_number(compressor))\n                    && reversible()\n                    && !(self.left instanceof AST_Binary\n                        && self.left.operator != self.operator\n                        && PRECEDENCE[self.left.operator] >= PRECEDENCE[self.operator])) {\n                    var reversed = make_node(AST_Binary, self, {\n                        operator: self.operator,\n                        left: self.right,\n                        right: self.left\n                    });\n                    if (self.right instanceof AST_Constant\n                        && !(self.left instanceof AST_Constant)) {\n                        self = best_of(compressor, reversed, self);\n                    } else {\n                        self = best_of(compressor, self, reversed);\n                    }\n                }\n                if (!associative || !self.is_number(compressor)) break;\n                // a + (b + c) => (a + b) + c\n                if (self.right instanceof AST_Binary\n                    && self.right.operator != \"%\"\n                    && PRECEDENCE[self.right.operator] == PRECEDENCE[self.operator]\n                    && self.right.is_number(compressor)\n                    && (self.operator != \"+\"\n                        || self.right.left.is_boolean(compressor)\n                        || self.right.left.is_number(compressor))\n                    && (self.operator != \"-\" || !self.left.is_negative_zero())\n                    && (self.right.left.is_constant_expression()\n                        || !self.right.right.has_side_effects(compressor))) {\n                    self = make_node(AST_Binary, self, {\n                        operator: align(self.operator, self.right.operator),\n                        left: make_node(AST_Binary, self.left, {\n                            operator: self.operator,\n                            left: self.left,\n                            right: self.right.left,\n                            start: self.left.start,\n                            end: self.right.left.end\n                        }),\n                        right: self.right.right\n                    });\n                    if (self.operator == \"+\"\n                        && !self.right.is_boolean(compressor)\n                        && !self.right.is_number(compressor)) {\n                        self.right = make_node(AST_UnaryPrefix, self.right, {\n                            operator: \"+\",\n                            expression: self.right\n                        });\n                    }\n                }\n                // (2 * n) * 3 => 6 * n\n                // (n + 2) + 3 => n + 5\n                if (self.right instanceof AST_Constant\n                    && self.left instanceof AST_Binary\n                    && self.left.operator != \"%\"\n                    && PRECEDENCE[self.left.operator] == PRECEDENCE[self.operator]\n                    && self.left.is_number(compressor)) {\n                    if (self.left.left instanceof AST_Constant) {\n                        var lhs = make_binary(self.left, self.operator, self.left.left, self.right, self.left.left.start, self.right.end);\n                        self = make_binary(self, self.left.operator, try_evaluate(compressor, lhs), self.left.right);\n                    } else if (self.left.right instanceof AST_Constant) {\n                        var op = align(self.left.operator, self.operator);\n                        var rhs = try_evaluate(compressor, make_binary(self.left, op, self.left.right, self.right));\n                        if (rhs.is_constant()\n                            && !(self.left.operator == \"-\"\n                                && self.right.value != 0\n                                && +rhs.value == 0\n                                && self.left.left.is_negative_zero())) {\n                            self = make_binary(self, self.left.operator, self.left.left, rhs);\n                        }\n                    }\n                }\n                break;\n            }\n            if (!(parent instanceof AST_UnaryPrefix && parent.operator == \"delete\")) {\n                if (self.left instanceof AST_Number && !self.right.is_constant()) switch (self.operator) {\n                  // 0 + n => n\n                  case \"+\":\n                    if (self.left.value == 0) {\n                        if (self.right.is_boolean(compressor)) return make_node(AST_UnaryPrefix, self, {\n                            operator: \"+\",\n                            expression: self.right\n                        }).optimize(compressor);\n                        if (self.right.is_number(compressor) && !self.right.is_negative_zero()) return self.right;\n                    }\n                    break;\n                  // 1 * n => n\n                  case \"*\":\n                    if (self.left.value == 1) {\n                        return self.right.is_number(compressor) ? self.right : make_node(AST_UnaryPrefix, self, {\n                            operator: \"+\",\n                            expression: self.right\n                        }).optimize(compressor);\n                    }\n                    break;\n                }\n                if (self.right instanceof AST_Number && !self.left.is_constant()) switch (self.operator) {\n                  // n + 0 => n\n                  case \"+\":\n                    if (self.right.value == 0) {\n                        if (self.left.is_boolean(compressor)) return make_node(AST_UnaryPrefix, self, {\n                            operator: \"+\",\n                            expression: self.left\n                        }).optimize(compressor);\n                        if (self.left.is_number(compressor) && !self.left.is_negative_zero()) return self.left;\n                    }\n                    break;\n                  // n - 0 => n\n                  case \"-\":\n                    if (self.right.value == 0) {\n                        return self.left.is_number(compressor) ? self.left : make_node(AST_UnaryPrefix, self, {\n                            operator: \"+\",\n                            expression: self.left\n                        }).optimize(compressor);\n                    }\n                    break;\n                  // n / 1 => n\n                  case \"/\":\n                    if (self.right.value == 1) {\n                        return self.left.is_number(compressor) ? self.left : make_node(AST_UnaryPrefix, self, {\n                            operator: \"+\",\n                            expression: self.left\n                        }).optimize(compressor);\n                    }\n                    break;\n                }\n            }\n        }\n        if (compressor.option(\"typeofs\")) switch (self.operator) {\n          case \"&&\":\n            mark_locally_defined(self.left, self.right, null);\n            break;\n          case \"||\":\n            mark_locally_defined(self.left, null, self.right);\n            break;\n        }\n        if (compressor.option(\"unsafe\")) {\n            var indexRight = is_indexFn(self.right);\n            if (in_bool\n                && indexRight\n                && (self.operator == \"==\" || self.operator == \"!=\")\n                && self.left instanceof AST_Number\n                && self.left.value == 0) {\n                return (self.operator == \"==\" ? make_node(AST_UnaryPrefix, self, {\n                    operator: \"!\",\n                    expression: self.right\n                }) : self.right).optimize(compressor);\n            }\n            var indexLeft = is_indexFn(self.left);\n            if (compressor.option(\"comparisons\") && is_indexOf_match_pattern()) {\n                var node = make_node(AST_UnaryPrefix, self, {\n                    operator: \"!\",\n                    expression: make_node(AST_UnaryPrefix, self, {\n                        operator: \"~\",\n                        expression: indexLeft ? self.left : self.right\n                    })\n                });\n                switch (self.operator) {\n                  case \"<\":\n                    if (indexLeft) break;\n                  case \"<=\":\n                  case \"!=\":\n                    node = make_node(AST_UnaryPrefix, self, {\n                        operator: \"!\",\n                        expression: node\n                    });\n                    break;\n                }\n                return node.optimize(compressor);\n            }\n        }\n        return try_evaluate(compressor, self);\n\n        function align(ref, op) {\n            switch (ref) {\n              case \"-\":\n                return op == \"+\" ? \"-\" : \"+\";\n              case \"/\":\n                return op == \"*\" ? \"/\" : \"*\";\n              default:\n                return op;\n            }\n        }\n\n        function make_binary(orig, op, left, right, start, end) {\n            if (op == \"+\") {\n                if (!left.is_boolean(compressor) && !left.is_number(compressor)) {\n                    left = make_node(AST_UnaryPrefix, left, {\n                        operator: \"+\",\n                        expression: left\n                    });\n                }\n                if (!right.is_boolean(compressor) && !right.is_number(compressor)) {\n                    right = make_node(AST_UnaryPrefix, right, {\n                        operator: \"+\",\n                        expression: right\n                    });\n                }\n            }\n            return make_node(AST_Binary, orig, {\n                operator: op,\n                left: left,\n                right: right,\n                start: start,\n                end: end\n            });\n        }\n\n        function fuzzy_eval(node) {\n            if (node.truthy) return true;\n            if (node.falsy) return false;\n            if (node.is_truthy()) return true;\n            return node.evaluate(compressor, true);\n        }\n\n        function is_indexFn(node) {\n            return node.TYPE == \"Call\"\n                && node.expression instanceof AST_Dot\n                && indexFns[node.expression.property];\n        }\n\n        function is_indexOf_match_pattern() {\n            switch (self.operator) {\n              case \"<=\":\n                // 0 <= array.indexOf(string) => !!~array.indexOf(string)\n                return indexRight && self.left instanceof AST_Number && self.left.value == 0;\n              case \"<\":\n                // array.indexOf(string) < 0 => !~array.indexOf(string)\n                if (indexLeft && self.right instanceof AST_Number && self.right.value == 0) return true;\n                // -1 < array.indexOf(string) => !!~array.indexOf(string)\n              case \"==\":\n              case \"!=\":\n                // -1 == array.indexOf(string) => !~array.indexOf(string)\n                // -1 != array.indexOf(string) => !!~array.indexOf(string)\n                if (!indexRight) return false;\n                return self.left instanceof AST_Number && self.left.value == -1\n                    || self.left instanceof AST_UnaryPrefix && self.left.operator == \"-\"\n                        && self.left.expression instanceof AST_Number && self.left.expression.value == 1;\n            }\n        }\n    });\n\n    function recursive_ref(compressor, def) {\n        var level = 0, node = compressor.self();\n        do {\n            if (node instanceof AST_Lambda && node.name && node.name.definition() === def) return node;\n        } while (node = compressor.parent(level++));\n    }\n\n    OPT(AST_SymbolRef, function(self, compressor) {\n        if (!compressor.option(\"ie8\")\n            && is_undeclared_ref(self)\n            // testing against `self.scope.uses_with` is an optimization\n            && !(self.scope.resolve().uses_with && compressor.find_parent(AST_With))) {\n            switch (self.name) {\n              case \"undefined\":\n                return make_node(AST_Undefined, self).optimize(compressor);\n              case \"NaN\":\n                return make_node(AST_NaN, self).optimize(compressor);\n              case \"Infinity\":\n                return make_node(AST_Infinity, self).optimize(compressor);\n            }\n        }\n        var parent = compressor.parent();\n        if (compressor.option(\"reduce_vars\") && is_lhs(compressor.self(), parent) !== compressor.self()) {\n            var def = self.definition();\n            var fixed = self.fixed_value();\n            var single_use = def.single_use && !(parent instanceof AST_Call && parent.is_expr_pure(compressor));\n            if (single_use) {\n                if (fixed instanceof AST_Lambda) {\n                    if ((def.scope !== self.scope.resolve() || def.in_loop)\n                        && (!compressor.option(\"reduce_funcs\") || def.escaped.depth == 1 || fixed.inlined)) {\n                        single_use = false;\n                    } else if (recursive_ref(compressor, def)) {\n                        single_use = false;\n                    } else if (fixed.name && fixed.name.definition() !== def) {\n                        single_use = false;\n                    } else if (fixed.parent_scope !== self.scope.resolve() || is_funarg(def)) {\n                        single_use = fixed.is_constant_expression(self.scope);\n                        if (single_use == \"f\") {\n                            var scope = self.scope;\n                            do if (is_defun(scope) || is_function(scope)) {\n                                scope.inlined = true;\n                            } while (scope = scope.parent_scope);\n                        }\n                    } else if (fixed.name && fixed.name.name == \"await\" && is_async(fixed)) {\n                        single_use = false;\n                    }\n                    if (single_use) fixed.parent_scope = self.scope;\n                } else if (!fixed || !fixed.is_constant_expression()) {\n                    single_use = false;\n                }\n            }\n            if (single_use) {\n                def.single_use = false;\n                fixed._squeezed = true;\n                fixed.single_use = true;\n                if (fixed instanceof AST_AsyncDefun) {\n                    fixed = make_node(AST_AsyncFunction, fixed, fixed);\n                    fixed.name = make_node(AST_SymbolLambda, fixed.name, fixed.name);\n                } else if (fixed instanceof AST_Defun) {\n                    fixed = make_node(AST_Function, fixed, fixed);\n                    fixed.name = make_node(AST_SymbolLambda, fixed.name, fixed.name);\n                }\n                if (fixed instanceof AST_Lambda) {\n                    var scope = self.scope.resolve();\n                    fixed.enclosed.forEach(function(def) {\n                        if (fixed.variables.has(def.name)) return;\n                        if (scope.var_names()[def.name]) return;\n                        scope.enclosed.push(def);\n                        scope.var_names()[def.name] = true;\n                    });\n                }\n                var value;\n                if (def.recursive_refs > 0) {\n                    value = fixed.clone(true);\n                    var defun_def = value.name.definition();\n                    var lambda_def = value.variables.get(value.name.name);\n                    var name = lambda_def && lambda_def.orig[0];\n                    if (!(name instanceof AST_SymbolLambda)) {\n                        name = make_node(AST_SymbolLambda, value.name, value.name);\n                        name.scope = value;\n                        value.name = name;\n                        lambda_def = value.def_function(name);\n                        lambda_def.recursive_refs = def.recursive_refs;\n                    }\n                    value.walk(new TreeWalker(function(node) {\n                        if (!(node instanceof AST_SymbolRef)) return;\n                        var def = node.definition();\n                        if (def === defun_def) {\n                            node.thedef = lambda_def;\n                            lambda_def.references.push(node);\n                        } else {\n                            def.single_use = false;\n                            var fn = node.fixed_value();\n                            if (!(fn instanceof AST_Lambda)) return;\n                            if (!fn.name) return;\n                            if (fn.name.definition() !== def) return;\n                            if (def.scope !== fn.name.scope) return;\n                            if (fixed.variables.get(fn.name.name) !== def) return;\n                            fn.name = fn.name.clone();\n                            var value_def = value.variables.get(fn.name.name) || value.def_function(fn.name);\n                            node.thedef = value_def;\n                            value_def.references.push(node);\n                        }\n                    }));\n                } else {\n                    value = fixed.optimize(compressor);\n                    if (value === fixed) value = value.transform(new TreeTransformer(function(node, descend) {\n                        if (node instanceof AST_Scope) return node;\n                        node = node.clone();\n                        descend(node, this);\n                        return node;\n                    }));\n                }\n                def.replaced++;\n                return value;\n            }\n            var local = self.fixed !== def.fixed;\n            if (fixed && (local || def.should_replace !== false)) {\n                var init;\n                if (fixed instanceof AST_This) {\n                    if (!is_funarg(def) && same_scope(def)) {\n                        init = fixed;\n                    }\n                } else {\n                    var ev = fixed.evaluate(compressor, true);\n                    if (ev !== fixed\n                        && typeof ev != \"function\"\n                        && (typeof ev != \"object\"\n                            || ev instanceof RegExp\n                                && compressor.option(\"unsafe_regexp\")\n                                && !def.cross_loop && same_scope(def))) {\n                        init = make_node_from_constant(ev, fixed);\n                    }\n                }\n                if (init) {\n                    if (!local && def.should_replace === undefined) {\n                        var value_length = init.optimize(compressor).print_to_string().length;\n                        if (!has_symbol_ref(fixed)) {\n                            value_length = Math.min(value_length, fixed.print_to_string().length);\n                        }\n                        var name_length = def.name.length;\n                        if (compressor.option(\"unused\") && !compressor.exposed(def)) {\n                            var referenced = def.references.length - def.replaced;\n                            name_length += (name_length + 2 + value_length) / (referenced - def.assignments);\n                        }\n                        var delta = value_length - Math.floor(name_length);\n                        def.should_replace = delta < compressor.eval_threshold;\n                    }\n                    if (local || def.should_replace) {\n                        var value;\n                        if (has_symbol_ref(fixed)) {\n                            value = init.optimize(compressor);\n                            if (value === init) value = value.clone(true);\n                        } else {\n                            value = best_of_expression(init.optimize(compressor), fixed);\n                            if (value === init || value === fixed) value = value.clone(true);\n                        }\n                        def.replaced++;\n                        return value;\n                    }\n                }\n            }\n        }\n        return self;\n\n        function same_scope(def) {\n            var scope = def.scope.resolve();\n            return all(def.references, function(ref) {\n                return scope === ref.scope.resolve();\n            });\n        }\n\n        function has_symbol_ref(value) {\n            var found;\n            value.walk(new TreeWalker(function(node) {\n                if (node instanceof AST_SymbolRef) found = true;\n                if (found) return true;\n            }));\n            return found;\n        }\n    });\n\n    function is_atomic(lhs, self) {\n        return lhs instanceof AST_SymbolRef || lhs.TYPE === self.TYPE;\n    }\n\n    OPT(AST_Undefined, function(self, compressor) {\n        if (compressor.option(\"unsafe_undefined\")) {\n            var undef = find_scope(compressor).find_variable(\"undefined\");\n            if (undef) {\n                var ref = make_node(AST_SymbolRef, self, {\n                    name   : \"undefined\",\n                    scope  : undef.scope,\n                    thedef : undef\n                });\n                ref.is_undefined = true;\n                return ref;\n            }\n        }\n        var lhs = is_lhs(compressor.self(), compressor.parent());\n        if (lhs && is_atomic(lhs, self)) return self;\n        return make_node(AST_UnaryPrefix, self, {\n            operator: \"void\",\n            expression: make_node(AST_Number, self, {\n                value: 0\n            })\n        });\n    });\n\n    OPT(AST_Infinity, function(self, compressor) {\n        var lhs = is_lhs(compressor.self(), compressor.parent());\n        if (lhs && is_atomic(lhs, self)) return self;\n        if (compressor.option(\"keep_infinity\") && !lhs && !find_scope(compressor).find_variable(\"Infinity\")) {\n            return self;\n        }\n        return make_node(AST_Binary, self, {\n            operator: \"/\",\n            left: make_node(AST_Number, self, {\n                value: 1\n            }),\n            right: make_node(AST_Number, self, {\n                value: 0\n            })\n        });\n    });\n\n    OPT(AST_NaN, function(self, compressor) {\n        var lhs = is_lhs(compressor.self(), compressor.parent());\n        if (lhs && is_atomic(lhs, self)) return self;\n        if (!lhs && !find_scope(compressor).find_variable(\"NaN\")) return self;\n        return make_node(AST_Binary, self, {\n            operator: \"/\",\n            left: make_node(AST_Number, self, {\n                value: 0\n            }),\n            right: make_node(AST_Number, self, {\n                value: 0\n            })\n        });\n    });\n\n    function is_reachable(self, defs) {\n        var reachable = false;\n        var find_ref = new TreeWalker(function(node) {\n            if (reachable) return true;\n            if (node instanceof AST_SymbolRef && member(node.definition(), defs)) {\n                return reachable = true;\n            }\n        });\n        var scan_scope = new TreeWalker(function(node) {\n            if (reachable) return true;\n            if (node instanceof AST_Scope && node !== self) {\n                var parent = scan_scope.parent();\n                if (parent instanceof AST_Call && parent.expression === node) return;\n                node.walk(find_ref);\n                return true;\n            }\n        });\n        self.walk(scan_scope);\n        return reachable;\n    }\n\n    var ASSIGN_OPS = makePredicate(\"+ - * / % >> << >>> | ^ &\");\n    var ASSIGN_OPS_COMMUTATIVE = makePredicate(\"* | ^ &\");\n    OPT(AST_Assign, function(self, compressor) {\n        if (compressor.option(\"dead_code\")) {\n            if (self.left instanceof AST_PropAccess) {\n                if (self.operator == \"=\") {\n                    if (self.__drop) {\n                        var exprs = [ self.left.expression ];\n                        if (self.left instanceof AST_Sub) exprs.push(self.left.property);\n                        exprs.push(self.right);\n                        return make_sequence(self, exprs).optimize(compressor);\n                    }\n                    if (self.left.equivalent_to(self.right) && !self.left.has_side_effects(compressor)) {\n                        return self.right;\n                    }\n                    var exp = self.left.expression;\n                    if (exp instanceof AST_Lambda\n                        || !compressor.has_directive(\"use strict\")\n                            && exp instanceof AST_Constant\n                            && !exp.may_throw_on_access(compressor)) {\n                        return self.left instanceof AST_Dot ? self.right : make_sequence(self, [\n                            self.left.property,\n                            self.right\n                        ]).optimize(compressor);\n                    }\n                }\n            } else if (self.left instanceof AST_SymbolRef && all(self.left.definition().orig, function(sym) {\n                return !(sym instanceof AST_SymbolConst);\n            })) {\n                var parent;\n                if (self.operator == \"=\" && self.left.equivalent_to(self.right)\n                    && !((parent = compressor.parent()) instanceof AST_UnaryPrefix && parent.operator == \"delete\")) {\n                    return self.right;\n                }\n                if (self.left.is_immutable()) return strip_assignment();\n                var def = self.left.definition();\n                var scope = def.scope.resolve();\n                var local = scope === compressor.find_parent(AST_Lambda);\n                var level = 0, node;\n                parent = self;\n                do {\n                    node = parent;\n                    parent = compressor.parent(level++);\n                    if (parent instanceof AST_Assign) {\n                        var found = false;\n                        if (parent.left.match_symbol(function(node) {\n                            if (node instanceof AST_PropAccess) return true;\n                            if (!found && node instanceof AST_SymbolRef && node.definition() === def) {\n                                if (in_try(level, parent)) return true;\n                                def.fixed = false;\n                                found = true;\n                            }\n                        })) break;\n                        if (found) return strip_assignment();\n                    } else if (parent instanceof AST_Exit) {\n                        if (!local) break;\n                        if (in_try(level, parent)) break;\n                        if (is_reachable(scope, [ def ])) break;\n                        def.fixed = false;\n                        return strip_assignment();\n                    } else if (parent instanceof AST_VarDef) {\n                        if (!(parent.name instanceof AST_SymbolDeclaration)) continue;\n                        if (parent.name.definition() !== def) continue;\n                        if (in_try(level, parent)) break;\n                        def.fixed = false;\n                        return strip_assignment();\n                    }\n                } while (parent instanceof AST_Binary && parent.right === node\n                    || parent instanceof AST_Sequence && parent.tail_node() === node\n                    || parent instanceof AST_UnaryPrefix);\n            }\n        }\n        if (compressor.option(\"sequences\")) {\n            var seq = self.lift_sequences(compressor);\n            if (seq !== self) return seq.optimize(compressor);\n        }\n        if (compressor.option(\"assignments\")) {\n            if (self.operator == \"=\" && self.left instanceof AST_SymbolRef && self.right instanceof AST_Binary) {\n                // x = expr1 OP expr2\n                if (self.right.left instanceof AST_SymbolRef\n                    && self.right.left.name == self.left.name\n                    && ASSIGN_OPS[self.right.operator]) {\n                    // x = x - 2 => x -= 2\n                    return make_node(AST_Assign, self, {\n                        operator: self.right.operator + \"=\",\n                        left: self.left,\n                        right: self.right.right,\n                    }).optimize(compressor);\n                }\n                else if (self.right.right instanceof AST_SymbolRef\n                    && self.right.right.name == self.left.name\n                    && ASSIGN_OPS_COMMUTATIVE[self.right.operator]\n                    && !self.right.left.has_side_effects(compressor)) {\n                    // x = 2 & x => x &= 2\n                    return make_node(AST_Assign, self, {\n                        operator: self.right.operator + \"=\",\n                        left: self.left,\n                        right: self.right.left,\n                    }).optimize(compressor);\n                }\n            }\n            if ((self.operator == \"-=\" || self.operator == \"+=\"\n                    && (self.left.is_boolean(compressor) || self.left.is_number(compressor)))\n                && self.right instanceof AST_Number\n                && self.right.value == 1) {\n                var op = self.operator.slice(0, -1);\n                return make_node(AST_UnaryPrefix, self, {\n                    operator: op + op,\n                    expression: self.left\n                });\n            }\n        }\n        return try_evaluate(compressor, self);\n\n        function in_try(level, node) {\n            var right = self.right;\n            self.right = make_node(AST_Null, right);\n            var may_throw = node.may_throw(compressor);\n            self.right = right;\n            var parent;\n            while (parent = compressor.parent(level++)) {\n                if (parent === scope) return false;\n                if (parent instanceof AST_Try) {\n                    if (parent.bfinally) return true;\n                    if (may_throw && parent.bcatch) return true;\n                }\n            }\n        }\n\n        function strip_assignment() {\n            return (self.operator != \"=\" ? make_node(AST_Binary, self, {\n                operator: self.operator.slice(0, -1),\n                left: self.left,\n                right: self.right\n            }) : maintain_this_binding(compressor, compressor.parent(), self, self.right)).optimize(compressor);\n        }\n    });\n\n    OPT(AST_Conditional, function(self, compressor) {\n        if (compressor.option(\"sequences\") && self.condition instanceof AST_Sequence) {\n            var expressions = self.condition.expressions.slice();\n            self.condition = expressions.pop();\n            expressions.push(self);\n            return make_sequence(self, expressions);\n        }\n        if (!compressor.option(\"conditionals\")) return self;\n        var condition = self.condition.is_truthy() || self.condition.evaluate(compressor, true);\n        if (!condition) {\n            AST_Node.warn(\"Condition always false [{file}:{line},{col}]\", self.start);\n            return make_sequence(self, [ self.condition, self.alternative ]).optimize(compressor);\n        } else if (!(condition instanceof AST_Node)) {\n            AST_Node.warn(\"Condition always true [{file}:{line},{col}]\", self.start);\n            return make_sequence(self, [ self.condition, self.consequent ]).optimize(compressor);\n        }\n        var negated = condition.negate(compressor, first_in_statement(compressor));\n        if (best_of(compressor, condition, negated) === negated) {\n            self = make_node(AST_Conditional, self, {\n                condition: negated,\n                consequent: self.alternative,\n                alternative: self.consequent\n            });\n            negated = condition;\n            condition = self.condition;\n        }\n        var consequent = self.consequent;\n        var alternative = self.alternative;\n        if (repeatable(compressor, condition)) {\n            // x ? x : y => x || y\n            if (condition.equivalent_to(consequent)) return make_node(AST_Binary, self, {\n                operator: \"||\",\n                left: condition,\n                right: alternative,\n            }).optimize(compressor);\n            // x ? y : x => x && y\n            if (condition.equivalent_to(alternative)) return make_node(AST_Binary, self, {\n                operator: \"&&\",\n                left: condition,\n                right: consequent,\n            }).optimize(compressor);\n        }\n        // if (foo) exp = something; else exp = something_else;\n        //                   |\n        //                   v\n        // exp = foo ? something : something_else;\n        var seq_tail = consequent.tail_node();\n        if (seq_tail instanceof AST_Assign) {\n            var is_eq = seq_tail.operator == \"=\";\n            var alt_tail = is_eq ? alternative.tail_node() : alternative;\n            if ((is_eq || consequent === seq_tail)\n                && alt_tail instanceof AST_Assign\n                && seq_tail.operator == alt_tail.operator\n                && seq_tail.left.equivalent_to(alt_tail.left)\n                && (is_eq && seq_tail.left instanceof AST_SymbolRef\n                    || !condition.has_side_effects(compressor)\n                        && can_shift_lhs_of_tail(consequent)\n                        && can_shift_lhs_of_tail(alternative))) {\n                return make_node(AST_Assign, self, {\n                    operator: seq_tail.operator,\n                    left: seq_tail.left,\n                    right: make_node(AST_Conditional, self, {\n                        condition: condition,\n                        consequent: pop_lhs(consequent),\n                        alternative: pop_lhs(alternative)\n                    })\n                });\n            }\n        }\n        // x ? y : y => x, y\n        if (consequent.equivalent_to(alternative)) return make_sequence(self, [\n            condition,\n            consequent\n        ]).optimize(compressor);\n        // x ? y.p : z.p => (x ? y : z).p\n        // x ? y(a) : z(a) => (x ? y : z)(a)\n        // x ? y.f(a) : z.f(a) => (x ? y : z).f(a)\n        var combined = combine_tail(consequent, alternative, true);\n        if (combined) return combined;\n        // x ? y(a) : y(b) => y(x ? a : b)\n        var arg_index;\n        if (consequent instanceof AST_Call\n            && alternative.TYPE == consequent.TYPE\n            && (arg_index = arg_diff(consequent, alternative)) >= 0\n            && consequent.expression.equivalent_to(alternative.expression)\n            && !condition.has_side_effects(compressor)\n            && !consequent.expression.has_side_effects(compressor)) {\n            var node = consequent.clone();\n            node.args[arg_index] = make_node(AST_Conditional, self, {\n                condition: condition,\n                consequent: consequent.args[arg_index],\n                alternative: alternative.args[arg_index]\n            });\n            return node;\n        }\n        // x ? (y ? a : b) : b => x && y ? a : b\n        if (consequent instanceof AST_Conditional\n            && consequent.alternative.equivalent_to(alternative)) {\n            return make_node(AST_Conditional, self, {\n                condition: make_node(AST_Binary, self, {\n                    left: condition,\n                    operator: \"&&\",\n                    right: consequent.condition\n                }),\n                consequent: consequent.consequent,\n                alternative: alternative\n            });\n        }\n        // x ? (y ? a : b) : a => !x || y ? a : b\n        if (consequent instanceof AST_Conditional\n            && consequent.consequent.equivalent_to(alternative)) {\n            return make_node(AST_Conditional, self, {\n                condition: make_node(AST_Binary, self, {\n                    left: negated,\n                    operator: \"||\",\n                    right: consequent.condition\n                }),\n                consequent: alternative,\n                alternative: consequent.alternative\n            });\n        }\n        // x ? a : (y ? a : b) => x || y ? a : b\n        if (alternative instanceof AST_Conditional\n            && consequent.equivalent_to(alternative.consequent)) {\n            return make_node(AST_Conditional, self, {\n                condition: make_node(AST_Binary, self, {\n                    left: condition,\n                    operator: \"||\",\n                    right: alternative.condition\n                }),\n                consequent: consequent,\n                alternative: alternative.alternative\n            });\n        }\n        // x ? b : (y ? a : b) => !x && y ? a : b\n        if (alternative instanceof AST_Conditional\n            && consequent.equivalent_to(alternative.alternative)) {\n            return make_node(AST_Conditional, self, {\n                condition: make_node(AST_Binary, self, {\n                    left: negated,\n                    operator: \"&&\",\n                    right: alternative.condition\n                }),\n                consequent: alternative.consequent,\n                alternative: consequent\n            });\n        }\n        // x ? (a, c) : (b, c) => x ? a : b, c\n        if ((consequent instanceof AST_Sequence || alternative instanceof AST_Sequence)\n            && consequent.tail_node().equivalent_to(alternative.tail_node())) {\n            return make_sequence(self, [\n                make_node(AST_Conditional, self, {\n                    condition: condition,\n                    consequent: pop_seq(consequent),\n                    alternative: pop_seq(alternative)\n                }),\n                consequent.tail_node()\n            ]).optimize(compressor);\n        }\n        // x ? y && a : a => (!x || y) && a\n        if (consequent instanceof AST_Binary\n            && consequent.operator == \"&&\"\n            && consequent.right.equivalent_to(alternative)) {\n            return make_node(AST_Binary, self, {\n                operator: \"&&\",\n                left: make_node(AST_Binary, self, {\n                    operator: \"||\",\n                    left: negated,\n                    right: consequent.left\n                }),\n                right: alternative\n            }).optimize(compressor);\n        }\n        // x ? y || a : a => x && y || a\n        if (consequent instanceof AST_Binary\n            && consequent.operator == \"||\"\n            && consequent.right.equivalent_to(alternative)) {\n            return make_node(AST_Binary, self, {\n                operator: \"||\",\n                left: make_node(AST_Binary, self, {\n                    operator: \"&&\",\n                    left: condition,\n                    right: consequent.left\n                }),\n                right: alternative\n            }).optimize(compressor);\n        }\n        // x ? a : y && a => (x || y) && a\n        if (alternative instanceof AST_Binary\n            && alternative.operator == \"&&\"\n            && alternative.right.equivalent_to(consequent)) {\n            return make_node(AST_Binary, self, {\n                operator: \"&&\",\n                left: make_node(AST_Binary, self, {\n                    operator: \"||\",\n                    left: condition,\n                    right: alternative.left\n                }),\n                right: consequent\n            }).optimize(compressor);\n        }\n        // x ? a : y || a => !x && y || a\n        if (alternative instanceof AST_Binary\n            && alternative.operator == \"||\"\n            && alternative.right.equivalent_to(consequent)) {\n            return make_node(AST_Binary, self, {\n                operator: \"||\",\n                left: make_node(AST_Binary, self, {\n                    operator: \"&&\",\n                    left: negated,\n                    right: alternative.left\n                }),\n                right: consequent\n            }).optimize(compressor);\n        }\n        var in_bool = compressor.option(\"booleans\") && compressor.in_boolean_context();\n        if (is_true(consequent)) {\n            if (is_false(alternative)) {\n                // c ? true : false => !!c\n                return booleanize(condition);\n            }\n            // c ? true : x => !!c || x\n            return make_node(AST_Binary, self, {\n                operator: \"||\",\n                left: booleanize(condition),\n                right: alternative\n            });\n        }\n        if (is_false(consequent)) {\n            if (is_true(alternative)) {\n                // c ? false : true => !c\n                return booleanize(condition.negate(compressor));\n            }\n            // c ? false : x => !c && x\n            return make_node(AST_Binary, self, {\n                operator: \"&&\",\n                left: booleanize(condition.negate(compressor)),\n                right: alternative\n            });\n        }\n        if (is_true(alternative)) {\n            // c ? x : true => !c || x\n            return make_node(AST_Binary, self, {\n                operator: \"||\",\n                left: booleanize(condition.negate(compressor)),\n                right: consequent\n            });\n        }\n        if (is_false(alternative)) {\n            // c ? x : false => !!c && x\n            return make_node(AST_Binary, self, {\n                operator: \"&&\",\n                left: booleanize(condition),\n                right: consequent\n            });\n        }\n        if (compressor.option(\"typeofs\")) mark_locally_defined(condition, consequent, alternative);\n        return self;\n\n        function booleanize(node) {\n            if (node.is_boolean(compressor)) return node;\n            // !!expression\n            return make_node(AST_UnaryPrefix, node, {\n                operator: \"!\",\n                expression: node.negate(compressor)\n            });\n        }\n\n        // AST_True or !0\n        function is_true(node) {\n            return node instanceof AST_True\n                || in_bool\n                    && node instanceof AST_Constant\n                    && node.value\n                || (node instanceof AST_UnaryPrefix\n                    && node.operator == \"!\"\n                    && node.expression instanceof AST_Constant\n                    && !node.expression.value);\n        }\n        // AST_False or !1 or void 0\n        function is_false(node) {\n            return node instanceof AST_False\n                || in_bool\n                    && (node instanceof AST_Constant\n                            && !node.value\n                        || node instanceof AST_UnaryPrefix\n                            && node.operator == \"void\"\n                            && !node.expression.has_side_effects(compressor))\n                || (node instanceof AST_UnaryPrefix\n                    && node.operator == \"!\"\n                    && node.expression instanceof AST_Constant\n                    && node.expression.value);\n        }\n\n        function arg_diff(consequent, alternative) {\n            var a = consequent.args;\n            var b = alternative.args;\n            var len = a.length;\n            if (len != b.length) return -2;\n            for (var i = 0; i < len; i++) {\n                if (!a[i].equivalent_to(b[i])) {\n                    for (var j = i + 1; j < len; j++) {\n                        if (!a[j].equivalent_to(b[j])) return -2;\n                    }\n                    return i;\n                }\n            }\n            return -1;\n        }\n\n        function is_tail_equivalent(consequent, alternative) {\n            if (consequent.TYPE != alternative.TYPE) return;\n            if (consequent instanceof AST_Call) {\n                if (arg_diff(consequent, alternative) != -1) return;\n                return consequent.TYPE != \"Call\"\n                    || !(consequent.expression instanceof AST_PropAccess\n                        || alternative.expression instanceof AST_PropAccess)\n                    || is_tail_equivalent(consequent.expression, alternative.expression);\n            }\n            if (consequent instanceof AST_Dot) return consequent.property == alternative.property;\n            if (consequent instanceof AST_Sub) return consequent.property.equivalent_to(alternative.property);\n        }\n\n        function combine_tail(consequent, alternative, top) {\n            if (!is_tail_equivalent(consequent, alternative)) return !top && make_node(AST_Conditional, self, {\n                condition: condition,\n                consequent: consequent,\n                alternative: alternative\n            });\n            var exp = combine_tail(consequent.expression, alternative.expression);\n            if (!exp) return;\n            var node = consequent.clone();\n            node.expression = exp;\n            return node;\n        }\n\n        function can_shift_lhs_of_tail(node) {\n            return node === node.tail_node() || all(node.expressions.slice(0, -1), function(expr) {\n                return !expr.has_side_effects(compressor);\n            });\n        }\n\n        function pop_lhs(node) {\n            if (!(node instanceof AST_Sequence)) return node.right;\n            var exprs = node.expressions.slice();\n            exprs.push(exprs.pop().right);\n            return make_sequence(node, exprs);\n        }\n\n        function pop_seq(node) {\n            if (!(node instanceof AST_Sequence)) return make_node(AST_Number, node, {\n                value: 0\n            });\n            return make_sequence(node, node.expressions.slice(0, -1));\n        }\n    });\n\n    OPT(AST_Boolean, function(self, compressor) {\n        if (!compressor.option(\"booleans\")) return self;\n        if (compressor.in_boolean_context()) return make_node(AST_Number, self, {\n            value: +self.value\n        });\n        var p = compressor.parent();\n        if (p instanceof AST_Binary && (p.operator == \"==\" || p.operator == \"!=\")) {\n            AST_Node.warn(\"Non-strict equality against boolean: {operator} {value} [{file}:{line},{col}]\", {\n                operator : p.operator,\n                value    : self.value,\n                file     : p.start.file,\n                line     : p.start.line,\n                col      : p.start.col,\n            });\n            return make_node(AST_Number, self, {\n                value: +self.value\n            });\n        }\n        return make_node(AST_UnaryPrefix, self, {\n            operator: \"!\",\n            expression: make_node(AST_Number, self, {\n                value: 1 - self.value\n            })\n        });\n    });\n\n    OPT(AST_Spread, function(self, compressor) {\n        var exp = self.expression;\n        if (compressor.option(\"spread\") && exp instanceof AST_Array && !(compressor.parent() instanceof AST_Object)) {\n            return List.splice(exp.elements.map(function(node) {\n                return node instanceof AST_Hole ? make_node(AST_Undefined, node).optimize(compressor) : node;\n            }));\n        }\n        return self;\n    });\n\n    function safe_to_flatten(value, compressor) {\n        if (value instanceof AST_SymbolRef) {\n            value = value.fixed_value();\n        }\n        if (!value) return false;\n        if (!(value instanceof AST_Lambda)) return true;\n        var parent = compressor.parent();\n        if (parent.TYPE != \"Call\") return true;\n        if (parent.expression !== compressor.self()) return true;\n        return !value.contains_this();\n    }\n\n    OPT(AST_Sub, function(self, compressor) {\n        var expr = self.expression;\n        var prop = self.property;\n        if (compressor.option(\"properties\")) {\n            var key = prop.evaluate(compressor);\n            if (key !== prop) {\n                if (typeof key == \"string\") {\n                    if (key == \"undefined\") {\n                        key = undefined;\n                    } else {\n                        var value = parseFloat(key);\n                        if (value.toString() == key) {\n                            key = value;\n                        }\n                    }\n                }\n                prop = self.property = best_of_expression(prop, make_node_from_constant(key, prop).transform(compressor));\n                var property = \"\" + key;\n                if (is_identifier_string(property)\n                    && property.length <= prop.print_to_string().length + 1) {\n                    return make_node(AST_Dot, self, {\n                        expression: expr,\n                        property: property\n                    }).optimize(compressor);\n                }\n            }\n        }\n        var parent = compressor.parent();\n        var assigned = is_lhs(compressor.self(), parent);\n        var def, fn, fn_parent;\n        if (compressor.option(\"arguments\")\n            && expr instanceof AST_SymbolRef\n            && is_arguments(def = expr.definition())\n            && !expr.in_arg\n            && prop instanceof AST_Number\n            && (fn = def.scope) === find_lambda()\n            && fn.uses_arguments < (assigned ? 2 : 3)) {\n            var index = prop.value;\n            if (parent instanceof AST_UnaryPrefix && parent.operator == \"delete\") {\n                if (!def.deleted) def.deleted = [];\n                def.deleted[index] = true;\n            }\n            var argname = fn.argnames[index];\n            if (def.deleted && def.deleted[index]) {\n                argname = null;\n            } else if (argname) {\n                var arg_def;\n                if (!(argname instanceof AST_SymbolFunarg)) {\n                    argname = null;\n                } else if (expr.scope.find_variable(argname.name) !== (arg_def = argname.definition())) {\n                    argname = null;\n                } else if (compressor.has_directive(\"use strict\")\n                    || fn.name\n                    || !(fn_parent instanceof AST_Call && index < fn_parent.args.length)\n                    || !all(fn.argnames, function(argname) {\n                        return argname instanceof AST_SymbolFunarg;\n                    })) {\n                    if (!compressor.option(\"reduce_vars\")\n                        || def.reassigned\n                        || arg_def.assignments\n                        || arg_def.orig.length > 1) {\n                        argname = null;\n                    }\n                }\n            } else if (index < fn.argnames.length + 5 && compressor.drop_fargs(fn, fn_parent)) {\n                while (index >= fn.argnames.length) {\n                    argname = fn.make_var(AST_SymbolFunarg, fn, \"argument_\" + fn.argnames.length);\n                    fn.argnames.push(argname);\n                }\n            }\n            if (argname && find_if(function(node) {\n                return node.name === argname.name;\n            }, fn.argnames) === argname) {\n                def.reassigned = false;\n                var sym = make_node(AST_SymbolRef, self, argname);\n                sym.reference({});\n                delete argname.__unused;\n                return sym;\n            }\n        }\n        if (assigned) return self;\n        if (compressor.option(\"sequences\")\n            && parent.TYPE != \"Call\"\n            && !(parent instanceof AST_ForIn && parent.init === self)) {\n            var seq = lift_sequence_in_expression(self, compressor);\n            if (seq !== self) return seq.optimize(compressor);\n        }\n        if (key !== prop) {\n            var sub = self.flatten_object(property, compressor);\n            if (sub) {\n                expr = self.expression = sub.expression;\n                prop = self.property = sub.property;\n            }\n        }\n        var elements;\n        if (compressor.option(\"properties\")\n            && compressor.option(\"side_effects\")\n            && prop instanceof AST_Number\n            && expr instanceof AST_Array\n            && all(elements = expr.elements, function(value) {\n                return !(value instanceof AST_Spread);\n            })) {\n            var index = prop.value;\n            var retValue = elements[index];\n            if (safe_to_flatten(retValue, compressor)) {\n                var is_hole = retValue instanceof AST_Hole;\n                var flatten = !is_hole;\n                var values = [];\n                for (var i = elements.length; --i > index;) {\n                    var value = elements[i].drop_side_effect_free(compressor);\n                    if (value) {\n                        values.unshift(value);\n                        if (flatten && value.has_side_effects(compressor)) flatten = false;\n                    }\n                }\n                if (!flatten) values.unshift(retValue);\n                while (--i >= 0) {\n                    var value = elements[i].drop_side_effect_free(compressor);\n                    if (value) {\n                        values.unshift(value);\n                    } else if (is_hole) {\n                        values.unshift(make_node(AST_Hole, elements[i]));\n                    } else {\n                        index--;\n                    }\n                }\n                if (flatten) {\n                    values.push(retValue);\n                    return make_sequence(self, values).optimize(compressor);\n                } else return make_node(AST_Sub, self, {\n                    expression: make_node(AST_Array, expr, {\n                        elements: values\n                    }),\n                    property: make_node(AST_Number, prop, {\n                        value: index\n                    })\n                });\n            }\n        }\n        return try_evaluate(compressor, self);\n\n        function find_lambda() {\n            var i = 0, p;\n            while (p = compressor.parent(i++)) {\n                if (p instanceof AST_Lambda) {\n                    if (p instanceof AST_Accessor) return;\n                    if (p instanceof AST_Arrow) continue;\n                    fn_parent = compressor.parent(i);\n                    return p;\n                }\n            }\n        }\n    });\n\n    AST_Arrow.DEFMETHOD(\"contains_this\", return_false);\n    AST_Scope.DEFMETHOD(\"contains_this\", function() {\n        var result;\n        var self = this;\n        self.walk(new TreeWalker(function(node) {\n            if (result) return true;\n            if (node instanceof AST_This) return result = true;\n            if (node !== self && node instanceof AST_Scope && !(node instanceof AST_Arrow)) return true;\n        }));\n        return result;\n    });\n\n    AST_PropAccess.DEFMETHOD(\"flatten_object\", function(key, compressor) {\n        if (!compressor.option(\"properties\")) return;\n        var expr = this.expression;\n        if (expr instanceof AST_Object) {\n            var props = expr.properties;\n            for (var i = props.length; --i >= 0;) {\n                var prop = props[i];\n                if (prop.key != key) continue;\n                if (!all(props, function(prop) {\n                    return prop instanceof AST_ObjectKeyVal && typeof prop.key == \"string\";\n                })) break;\n                if (!safe_to_flatten(prop.value, compressor)) break;\n                return make_node(AST_Sub, this, {\n                    expression: make_node(AST_Array, expr, {\n                        elements: props.map(function(prop) {\n                            return prop.value;\n                        })\n                    }),\n                    property: make_node(AST_Number, this, {\n                        value: i\n                    })\n                });\n            }\n        }\n    });\n\n    OPT(AST_Dot, function(self, compressor) {\n        if (self.property == \"arguments\" || self.property == \"caller\") {\n            AST_Node.warn(\"Function.prototype.{prop} not supported [{file}:{line},{col}]\", {\n                prop: self.property,\n                file: self.start.file,\n                line: self.start.line,\n                col: self.start.col,\n            });\n        }\n        var parent = compressor.parent();\n        if (is_lhs(compressor.self(), parent)) return self;\n        if (compressor.option(\"sequences\")\n            && parent.TYPE != \"Call\"\n            && !(parent instanceof AST_ForIn && parent.init === self)) {\n            var seq = lift_sequence_in_expression(self, compressor);\n            if (seq !== self) return seq.optimize(compressor);\n        }\n        if (compressor.option(\"unsafe_proto\")\n            && self.expression instanceof AST_Dot\n            && self.expression.property == \"prototype\") {\n            var exp = self.expression.expression;\n            if (is_undeclared_ref(exp)) switch (exp.name) {\n              case \"Array\":\n                self.expression = make_node(AST_Array, self.expression, {\n                    elements: []\n                });\n                break;\n              case \"Function\":\n                self.expression = make_node(AST_Function, self.expression, {\n                    argnames: [],\n                    body: []\n                }).init_vars(exp.scope);\n                break;\n              case \"Number\":\n                self.expression = make_node(AST_Number, self.expression, {\n                    value: 0\n                });\n                break;\n              case \"Object\":\n                self.expression = make_node(AST_Object, self.expression, {\n                    properties: []\n                });\n                break;\n              case \"RegExp\":\n                self.expression = make_node(AST_RegExp, self.expression, {\n                    value: /t/\n                });\n                break;\n              case \"String\":\n                self.expression = make_node(AST_String, self.expression, {\n                    value: \"\"\n                });\n                break;\n            }\n        }\n        var sub = self.flatten_object(self.property, compressor);\n        if (sub) return sub.optimize(compressor);\n        return try_evaluate(compressor, self);\n    });\n\n    OPT(AST_DestructuredKeyVal, function(self, compressor) {\n        if (compressor.option(\"objects\")) {\n            var key = self.key;\n            if (key instanceof AST_Node) {\n                key = key.evaluate(compressor);\n                if (key !== self.key) self.key = \"\" + key;\n            }\n        }\n        return self;\n    });\n\n    OPT(AST_Object, function(self, compressor) {\n        if (!compressor.option(\"objects\")) return self;\n        var changed = false;\n        var found = false;\n        var generated = false;\n        var keep_duplicate = compressor.has_directive(\"use strict\");\n        var keys = new Dictionary();\n        var values = [];\n        self.properties.forEach(function(prop) {\n            if (!(prop instanceof AST_Spread)) return process(prop);\n            found = true;\n            var exp = prop.expression;\n            if (compressor.option(\"spread\") && exp instanceof AST_Object && all(exp.properties, function(prop) {\n                return !(prop instanceof AST_ObjectGetter || prop instanceof AST_Spread);\n            })) {\n                changed = true;\n                exp.properties.forEach(function(prop) {\n                    process(prop instanceof AST_ObjectSetter ? make_node(AST_ObjectKeyVal, prop, {\n                        key: prop.key,\n                        value: make_node(AST_Undefined, prop).optimize(compressor)\n                    }) : prop);\n                });\n            } else {\n                generated = true;\n                flush();\n                values.push(prop);\n            }\n        });\n        flush();\n        if (!changed) return self;\n        if (found && generated && values.length == 1) {\n            var value = values[0];\n            if (value instanceof AST_ObjectProperty && value.key instanceof AST_Number) {\n                value.key = \"\" + value.key.value;\n            }\n        }\n        return changed ? make_node(AST_Object, self, {\n            properties: values\n        }) :  self;\n\n        function flush() {\n            keys.each(function(props) {\n                if (props.length == 1) return values.push(props[0]);\n                changed = true;\n                var tail = keep_duplicate && !generated && props.pop();\n                values.push(props.length == 1 ? props[0] : make_node(AST_ObjectKeyVal, self, {\n                    key: props[0].key,\n                    value: make_sequence(self, props.map(function(prop) {\n                        return prop.value;\n                    }))\n                }));\n                if (tail) values.push(tail);\n            });\n            keys = new Dictionary();\n        }\n\n        function process(prop) {\n            var key = prop.key;\n            if (key instanceof AST_Node) {\n                found = true;\n                key = key.evaluate(compressor);\n                if (key === prop.key) {\n                    generated = true;\n                } else {\n                    key = prop.key = \"\" + key;\n                }\n            }\n            if (prop instanceof AST_ObjectKeyVal && typeof key == \"string\") {\n                if (prop.value.has_side_effects(compressor)) flush();\n                keys.add(key, prop);\n            } else {\n                flush();\n                values.push(prop);\n            }\n            if (found && !generated && typeof key == \"string\" && /^[1-9]*[0-9]$/.test(key)) {\n                generated = true;\n                if (keys.has(key)) prop = keys.get(key)[0];\n                prop.key = make_node(AST_Number, prop, {\n                    value: +key\n                });\n            }\n        }\n    });\n\n    OPT(AST_Return, function(self, compressor) {\n        if (self.value && is_undefined(self.value, compressor)) {\n            self.value = null;\n        }\n        return self;\n    });\n})(function(node, optimizer) {\n    node.DEFMETHOD(\"optimize\", function(compressor) {\n        var self = this;\n        if (self._optimized) return self;\n        if (compressor.has_directive(\"use asm\")) return self;\n        var opt = optimizer(self, compressor);\n        opt._optimized = true;\n        return opt;\n    });\n});\n","\"use strict\";\n\nvar to_ascii, to_base64;\nif (typeof Buffer == \"undefined\") {\n    to_ascii = atob;\n    to_base64 = btoa;\n} else if (typeof Buffer.alloc == \"undefined\") {\n    to_ascii = function(b64) {\n        return new Buffer(b64, \"base64\").toString();\n    };\n    to_base64 = function(str) {\n        return new Buffer(str).toString(\"base64\");\n    };\n} else {\n    to_ascii = function(b64) {\n        return Buffer.from(b64, \"base64\").toString();\n    };\n    to_base64 = function(str) {\n        return Buffer.from(str).toString(\"base64\");\n    };\n}\n\nfunction read_source_map(name, toplevel) {\n    var comments = toplevel.end.comments_after;\n    for (var i = comments.length; --i >= 0;) {\n        var comment = comments[i];\n        if (comment.type != \"comment1\") break;\n        var match = /^# ([^\\s=]+)=(\\S+)\\s*$/.exec(comment.value);\n        if (!match) break;\n        if (match[1] == \"sourceMappingURL\") {\n            match = /^data:application\\/json(;.*?)?;base64,(\\S+)$/.exec(match[2]);\n            if (!match) break;\n            return to_ascii(match[2]);\n        }\n    }\n    AST_Node.warn(\"inline source map not found: {name}\", {\n        name: name,\n    });\n}\n\nfunction parse_source_map(content) {\n    try {\n        return JSON.parse(content);\n    } catch (ex) {\n        throw new Error(\"invalid input source map: \" + content);\n    }\n}\n\nfunction set_shorthand(name, options, keys) {\n    if (options[name]) {\n        keys.forEach(function(key) {\n            if (options[key]) {\n                if (typeof options[key] != \"object\") options[key] = {};\n                if (!(name in options[key])) options[key][name] = options[name];\n            }\n        });\n    }\n}\n\nfunction init_cache(cache) {\n    if (!cache) return;\n    if (!(\"props\" in cache)) {\n        cache.props = new Dictionary();\n    } else if (!(cache.props instanceof Dictionary)) {\n        cache.props = Dictionary.fromObject(cache.props);\n    }\n}\n\nfunction to_json(cache) {\n    return {\n        props: cache.props.toObject()\n    };\n}\n\nfunction minify(files, options) {\n    try {\n        options = defaults(options, {\n            compress: {},\n            enclose: false,\n            ie8: false,\n            keep_fnames: false,\n            mangle: {},\n            nameCache: null,\n            output: {},\n            parse: {},\n            rename: undefined,\n            sourceMap: false,\n            timings: false,\n            toplevel: false,\n            v8: false,\n            validate: false,\n            warnings: false,\n            webkit: false,\n            wrap: false,\n        }, true);\n        if (options.validate) AST_Node.enable_validation();\n        var timings = options.timings && {\n            start: Date.now()\n        };\n        if (options.rename === undefined) {\n            options.rename = options.compress && options.mangle;\n        }\n        set_shorthand(\"ie8\", options, [ \"compress\", \"mangle\", \"output\" ]);\n        set_shorthand(\"keep_fnames\", options, [ \"compress\", \"mangle\" ]);\n        set_shorthand(\"toplevel\", options, [ \"compress\", \"mangle\" ]);\n        set_shorthand(\"v8\", options, [ \"mangle\", \"output\" ]);\n        set_shorthand(\"webkit\", options, [ \"mangle\", \"output\" ]);\n        var quoted_props;\n        if (options.mangle) {\n            options.mangle = defaults(options.mangle, {\n                cache: options.nameCache && (options.nameCache.vars || {}),\n                eval: false,\n                ie8: false,\n                keep_fnames: false,\n                properties: false,\n                reserved: [],\n                toplevel: false,\n                v8: false,\n                webkit: false,\n            }, true);\n            if (options.mangle.properties) {\n                if (typeof options.mangle.properties != \"object\") {\n                    options.mangle.properties = {};\n                }\n                if (options.mangle.properties.keep_quoted) {\n                    quoted_props = options.mangle.properties.reserved;\n                    if (!Array.isArray(quoted_props)) quoted_props = [];\n                    options.mangle.properties.reserved = quoted_props;\n                }\n                if (options.nameCache && !(\"cache\" in options.mangle.properties)) {\n                    options.mangle.properties.cache = options.nameCache.props || {};\n                }\n            }\n            init_cache(options.mangle.cache);\n            init_cache(options.mangle.properties.cache);\n        }\n        if (options.sourceMap) {\n            options.sourceMap = defaults(options.sourceMap, {\n                content: null,\n                filename: null,\n                includeSources: false,\n                names: true,\n                root: null,\n                url: null,\n            }, true);\n        }\n        var warnings = [];\n        if (options.warnings) AST_Node.log_function(function(warning) {\n            warnings.push(warning);\n        }, options.warnings == \"verbose\");\n        if (timings) timings.parse = Date.now();\n        var toplevel;\n        if (files instanceof AST_Toplevel) {\n            toplevel = files;\n        } else {\n            if (typeof files == \"string\") {\n                files = [ files ];\n            }\n            options.parse = options.parse || {};\n            options.parse.toplevel = null;\n            var source_map_content = options.sourceMap && options.sourceMap.content;\n            if (typeof source_map_content == \"string\" && source_map_content != \"inline\") {\n                source_map_content = parse_source_map(source_map_content);\n            }\n            if (source_map_content) options.sourceMap.orig = Object.create(null);\n            for (var name in files) if (HOP(files, name)) {\n                options.parse.filename = name;\n                options.parse.toplevel = toplevel = parse(files[name], options.parse);\n                if (source_map_content == \"inline\") {\n                    var inlined_content = read_source_map(name, toplevel);\n                    if (inlined_content) {\n                        options.sourceMap.orig[name] = parse_source_map(inlined_content);\n                    }\n                } else if (source_map_content) {\n                    options.sourceMap.orig[name] = source_map_content;\n                }\n            }\n        }\n        if (quoted_props) {\n            reserve_quoted_keys(toplevel, quoted_props);\n        }\n        [ \"enclose\", \"wrap\" ].forEach(function(action) {\n            var option = options[action];\n            if (!option) return;\n            var orig = toplevel.print_to_string().slice(0, -1);\n            toplevel = toplevel[action](option);\n            files[toplevel.start.file] = toplevel.print_to_string().replace(orig, \"\");\n        });\n        if (options.validate) toplevel.validate_ast();\n        if (timings) timings.rename = Date.now();\n        if (options.rename) {\n            toplevel.figure_out_scope(options.mangle);\n            toplevel.expand_names(options.mangle);\n        }\n        if (timings) timings.compress = Date.now();\n        if (options.compress) {\n            toplevel = new Compressor(options.compress).compress(toplevel);\n            if (options.validate) toplevel.validate_ast();\n        }\n        if (timings) timings.scope = Date.now();\n        if (options.mangle) toplevel.figure_out_scope(options.mangle);\n        if (timings) timings.mangle = Date.now();\n        if (options.mangle) {\n            toplevel.compute_char_frequency(options.mangle);\n            toplevel.mangle_names(options.mangle);\n        }\n        if (timings) timings.properties = Date.now();\n        if (options.mangle && options.mangle.properties) mangle_properties(toplevel, options.mangle.properties);\n        if (timings) timings.output = Date.now();\n        var result = {};\n        if (options.output.ast) {\n            result.ast = toplevel;\n        }\n        if (!HOP(options.output, \"code\") || options.output.code) {\n            if (options.sourceMap) {\n                options.output.source_map = SourceMap(options.sourceMap);\n                if (options.sourceMap.includeSources) {\n                    if (files instanceof AST_Toplevel) {\n                        throw new Error(\"original source content unavailable\");\n                    } else for (var name in files) if (HOP(files, name)) {\n                        options.output.source_map.setSourceContent(name, files[name]);\n                    }\n                }\n            }\n            delete options.output.ast;\n            delete options.output.code;\n            var stream = OutputStream(options.output);\n            toplevel.print(stream);\n            result.code = stream.get();\n            if (options.sourceMap) {\n                result.map = options.output.source_map.toString();\n                var url = options.sourceMap.url;\n                if (url) {\n                    result.code = result.code.replace(/\\n\\/\\/# sourceMappingURL=\\S+\\s*$/, \"\");\n                    if (url == \"inline\") {\n                        result.code += \"\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,\" + to_base64(result.map);\n                    } else {\n                        result.code += \"\\n//# sourceMappingURL=\" + url;\n                    }\n                }\n            }\n        }\n        if (options.nameCache && options.mangle) {\n            if (options.mangle.cache) options.nameCache.vars = to_json(options.mangle.cache);\n            if (options.mangle.properties && options.mangle.properties.cache) {\n                options.nameCache.props = to_json(options.mangle.properties.cache);\n            }\n        }\n        if (timings) {\n            timings.end = Date.now();\n            result.timings = {\n                parse: 1e-3 * (timings.rename - timings.parse),\n                rename: 1e-3 * (timings.compress - timings.rename),\n                compress: 1e-3 * (timings.scope - timings.compress),\n                scope: 1e-3 * (timings.mangle - timings.scope),\n                mangle: 1e-3 * (timings.properties - timings.mangle),\n                properties: 1e-3 * (timings.output - timings.properties),\n                output: 1e-3 * (timings.end - timings.output),\n                total: 1e-3 * (timings.end - timings.start)\n            };\n        }\n        if (warnings.length) {\n            result.warnings = warnings;\n        }\n        return result;\n    } catch (ex) {\n        return { error: ex };\n    } finally {\n        AST_Node.log_function();\n        AST_Node.disable_validation();\n    }\n}\n","/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\n\"use strict\";\n\n(function() {\n    function normalize_directives(body) {\n        var in_directive = true;\n        for (var i = 0; i < body.length; i++) {\n            if (in_directive && body[i] instanceof AST_Statement && body[i].body instanceof AST_String) {\n                body[i] = new AST_Directive({\n                    start: body[i].start,\n                    end: body[i].end,\n                    value: body[i].body.value\n                });\n            } else if (in_directive && !(body[i] instanceof AST_Statement && body[i].body instanceof AST_String)) {\n                in_directive = false;\n            }\n        }\n        return body;\n    }\n\n    var MOZ_TO_ME = {\n        Program: function(M) {\n            return new AST_Toplevel({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                body: normalize_directives(M.body.map(from_moz))\n            });\n        },\n        FunctionDeclaration: function(M) {\n            return new AST_Defun({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                name: from_moz(M.id),\n                argnames: M.params.map(from_moz),\n                body: normalize_directives(from_moz(M.body).body)\n            });\n        },\n        FunctionExpression: function(M) {\n            return new AST_Function({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                name: from_moz(M.id),\n                argnames: M.params.map(from_moz),\n                body: normalize_directives(from_moz(M.body).body)\n            });\n        },\n        ExpressionStatement: function(M) {\n            return new AST_SimpleStatement({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                body: from_moz(M.expression)\n            });\n        },\n        TryStatement: function(M) {\n            var handlers = M.handlers || [M.handler];\n            if (handlers.length > 1 || M.guardedHandlers && M.guardedHandlers.length) {\n                throw new Error(\"Multiple catch clauses are not supported.\");\n            }\n            return new AST_Try({\n                start    : my_start_token(M),\n                end      : my_end_token(M),\n                body     : from_moz(M.block).body,\n                bcatch   : from_moz(handlers[0]),\n                bfinally : M.finalizer ? new AST_Finally(from_moz(M.finalizer)) : null\n            });\n        },\n        Property: function(M) {\n            var key = M.key;\n            var args = {\n                start    : my_start_token(key),\n                end      : my_end_token(M.value),\n                key      : \"\" + key[key.type == \"Identifier\" ? \"name\" : \"value\"],\n                value    : from_moz(M.value)\n            };\n            if (M.kind == \"init\") return new AST_ObjectKeyVal(args);\n            args.value = new AST_Accessor(args.value);\n            if (M.kind == \"get\") return new AST_ObjectGetter(args);\n            if (M.kind == \"set\") return new AST_ObjectSetter(args);\n        },\n        ArrayExpression: function(M) {\n            return new AST_Array({\n                start    : my_start_token(M),\n                end      : my_end_token(M),\n                elements : M.elements.map(function(elem) {\n                    return elem === null ? new AST_Hole() : from_moz(elem);\n                })\n            });\n        },\n        ObjectExpression: function(M) {\n            return new AST_Object({\n                start      : my_start_token(M),\n                end        : my_end_token(M),\n                properties : M.properties.map(function(prop) {\n                    prop.type = \"Property\";\n                    return from_moz(prop)\n                })\n            });\n        },\n        SequenceExpression: function(M) {\n            return new AST_Sequence({\n                start      : my_start_token(M),\n                end        : my_end_token(M),\n                expressions: M.expressions.map(from_moz)\n            });\n        },\n        MemberExpression: function(M) {\n            return new (M.computed ? AST_Sub : AST_Dot)({\n                start      : my_start_token(M),\n                end        : my_end_token(M),\n                property   : M.computed ? from_moz(M.property) : M.property.name,\n                expression : from_moz(M.object)\n            });\n        },\n        SwitchCase: function(M) {\n            return new (M.test ? AST_Case : AST_Default)({\n                start      : my_start_token(M),\n                end        : my_end_token(M),\n                expression : from_moz(M.test),\n                body       : M.consequent.map(from_moz)\n            });\n        },\n        VariableDeclaration: function(M) {\n            return new AST_Var({\n                start       : my_start_token(M),\n                end         : my_end_token(M),\n                definitions : M.declarations.map(from_moz)\n            });\n        },\n        Literal: function(M) {\n            var val = M.value, args = {\n                start  : my_start_token(M),\n                end    : my_end_token(M)\n            };\n            if (val === null) return new AST_Null(args);\n            var rx = M.regex;\n            if (rx && rx.pattern) {\n                // RegExpLiteral as per ESTree AST spec\n                args.value = new RegExp(rx.pattern, rx.flags);\n                args.value.raw_source = rx.pattern;\n                return new AST_RegExp(args);\n            } else if (rx) {\n                // support legacy RegExp\n                args.value = M.regex && M.raw ? M.raw : val;\n                return new AST_RegExp(args);\n            }\n            switch (typeof val) {\n              case \"string\":\n                args.value = val;\n                return new AST_String(args);\n              case \"number\":\n                args.value = val;\n                return new AST_Number(args);\n              case \"boolean\":\n                return new (val ? AST_True : AST_False)(args);\n            }\n        },\n        Identifier: function(M) {\n            var p = FROM_MOZ_STACK[FROM_MOZ_STACK.length - 2];\n            return new (  p.type == \"LabeledStatement\" ? AST_Label\n                        : p.type == \"VariableDeclarator\" && p.id === M ? AST_SymbolVar\n                        : p.type == \"FunctionExpression\" ? (p.id === M ? AST_SymbolLambda : AST_SymbolFunarg)\n                        : p.type == \"FunctionDeclaration\" ? (p.id === M ? AST_SymbolDefun : AST_SymbolFunarg)\n                        : p.type == \"CatchClause\" ? AST_SymbolCatch\n                        : p.type == \"BreakStatement\" || p.type == \"ContinueStatement\" ? AST_LabelRef\n                        : AST_SymbolRef)({\n                            start : my_start_token(M),\n                            end   : my_end_token(M),\n                            name  : M.name\n                        });\n        },\n        ThisExpression: function(M) {\n            return new AST_This({\n                start : my_start_token(M),\n                end   : my_end_token(M),\n                name  : \"this\",\n            });\n        },\n    };\n\n    MOZ_TO_ME.UpdateExpression =\n    MOZ_TO_ME.UnaryExpression = function To_Moz_Unary(M) {\n        var prefix = \"prefix\" in M ? M.prefix\n            : M.type == \"UnaryExpression\" ? true : false;\n        return new (prefix ? AST_UnaryPrefix : AST_UnaryPostfix)({\n            start      : my_start_token(M),\n            end        : my_end_token(M),\n            operator   : M.operator,\n            expression : from_moz(M.argument)\n        });\n    };\n\n    map(\"EmptyStatement\", AST_EmptyStatement);\n    map(\"BlockStatement\", AST_BlockStatement, \"body@body\");\n    map(\"IfStatement\", AST_If, \"test>condition, consequent>body, alternate>alternative\");\n    map(\"LabeledStatement\", AST_LabeledStatement, \"label>label, body>body\");\n    map(\"BreakStatement\", AST_Break, \"label>label\");\n    map(\"ContinueStatement\", AST_Continue, \"label>label\");\n    map(\"WithStatement\", AST_With, \"object>expression, body>body\");\n    map(\"SwitchStatement\", AST_Switch, \"discriminant>expression, cases@body\");\n    map(\"ReturnStatement\", AST_Return, \"argument>value\");\n    map(\"ThrowStatement\", AST_Throw, \"argument>value\");\n    map(\"WhileStatement\", AST_While, \"test>condition, body>body\");\n    map(\"DoWhileStatement\", AST_Do, \"test>condition, body>body\");\n    map(\"ForStatement\", AST_For, \"init>init, test>condition, update>step, body>body\");\n    map(\"ForInStatement\", AST_ForIn, \"left>init, right>object, body>body\");\n    map(\"DebuggerStatement\", AST_Debugger);\n    map(\"VariableDeclarator\", AST_VarDef, \"id>name, init>value\");\n    map(\"CatchClause\", AST_Catch, \"param>argname, body%body\");\n\n    map(\"BinaryExpression\", AST_Binary, \"operator=operator, left>left, right>right\");\n    map(\"LogicalExpression\", AST_Binary, \"operator=operator, left>left, right>right\");\n    map(\"AssignmentExpression\", AST_Assign, \"operator=operator, left>left, right>right\");\n    map(\"ConditionalExpression\", AST_Conditional, \"test>condition, consequent>consequent, alternate>alternative\");\n    map(\"NewExpression\", AST_New, \"callee>expression, arguments@args\");\n    map(\"CallExpression\", AST_Call, \"callee>expression, arguments@args\");\n\n    def_to_moz(AST_Toplevel, function To_Moz_Program(M) {\n        return to_moz_scope(\"Program\", M);\n    });\n\n    def_to_moz(AST_Defun, function To_Moz_FunctionDeclaration(M) {\n        return {\n            type: \"FunctionDeclaration\",\n            id: to_moz(M.name),\n            params: M.argnames.map(to_moz),\n            body: to_moz_scope(\"BlockStatement\", M)\n        }\n    });\n\n    def_to_moz(AST_Function, function To_Moz_FunctionExpression(M) {\n        return {\n            type: \"FunctionExpression\",\n            id: to_moz(M.name),\n            params: M.argnames.map(to_moz),\n            body: to_moz_scope(\"BlockStatement\", M)\n        }\n    });\n\n    def_to_moz(AST_Directive, function To_Moz_Directive(M) {\n        return {\n            type: \"ExpressionStatement\",\n            expression: {\n                type: \"Literal\",\n                value: M.value\n            }\n        };\n    });\n\n    def_to_moz(AST_SimpleStatement, function To_Moz_ExpressionStatement(M) {\n        return {\n            type: \"ExpressionStatement\",\n            expression: to_moz(M.body)\n        };\n    });\n\n    def_to_moz(AST_SwitchBranch, function To_Moz_SwitchCase(M) {\n        return {\n            type: \"SwitchCase\",\n            test: to_moz(M.expression),\n            consequent: M.body.map(to_moz)\n        };\n    });\n\n    def_to_moz(AST_Try, function To_Moz_TryStatement(M) {\n        return {\n            type: \"TryStatement\",\n            block: to_moz_block(M),\n            handler: to_moz(M.bcatch),\n            guardedHandlers: [],\n            finalizer: to_moz(M.bfinally)\n        };\n    });\n\n    def_to_moz(AST_Catch, function To_Moz_CatchClause(M) {\n        return {\n            type: \"CatchClause\",\n            param: to_moz(M.argname),\n            guard: null,\n            body: to_moz_block(M)\n        };\n    });\n\n    def_to_moz(AST_Definitions, function To_Moz_VariableDeclaration(M) {\n        return {\n            type: \"VariableDeclaration\",\n            kind: \"var\",\n            declarations: M.definitions.map(to_moz)\n        };\n    });\n\n    def_to_moz(AST_Sequence, function To_Moz_SequenceExpression(M) {\n        return {\n            type: \"SequenceExpression\",\n            expressions: M.expressions.map(to_moz)\n        };\n    });\n\n    def_to_moz(AST_PropAccess, function To_Moz_MemberExpression(M) {\n        var isComputed = M instanceof AST_Sub;\n        return {\n            type: \"MemberExpression\",\n            object: to_moz(M.expression),\n            computed: isComputed,\n            property: isComputed ? to_moz(M.property) : {type: \"Identifier\", name: M.property}\n        };\n    });\n\n    def_to_moz(AST_Unary, function To_Moz_Unary(M) {\n        return {\n            type: M.operator == \"++\" || M.operator == \"--\" ? \"UpdateExpression\" : \"UnaryExpression\",\n            operator: M.operator,\n            prefix: M instanceof AST_UnaryPrefix,\n            argument: to_moz(M.expression)\n        };\n    });\n\n    def_to_moz(AST_Binary, function To_Moz_BinaryExpression(M) {\n        return {\n            type: M.operator == \"&&\" || M.operator == \"||\" ? \"LogicalExpression\" : \"BinaryExpression\",\n            left: to_moz(M.left),\n            operator: M.operator,\n            right: to_moz(M.right)\n        };\n    });\n\n    def_to_moz(AST_Array, function To_Moz_ArrayExpression(M) {\n        return {\n            type: \"ArrayExpression\",\n            elements: M.elements.map(to_moz)\n        };\n    });\n\n    def_to_moz(AST_Object, function To_Moz_ObjectExpression(M) {\n        return {\n            type: \"ObjectExpression\",\n            properties: M.properties.map(to_moz)\n        };\n    });\n\n    def_to_moz(AST_ObjectProperty, function To_Moz_Property(M) {\n        var key = {\n            type: \"Literal\",\n            value: M.key\n        };\n        var kind;\n        if (M instanceof AST_ObjectKeyVal) {\n            kind = \"init\";\n        } else\n        if (M instanceof AST_ObjectGetter) {\n            kind = \"get\";\n        } else\n        if (M instanceof AST_ObjectSetter) {\n            kind = \"set\";\n        }\n        return {\n            type: \"Property\",\n            kind: kind,\n            key: key,\n            value: to_moz(M.value)\n        };\n    });\n\n    def_to_moz(AST_Symbol, function To_Moz_Identifier(M) {\n        var def = M.definition();\n        return {\n            type: \"Identifier\",\n            name: def && def.mangled_name || M.name\n        };\n    });\n\n    def_to_moz(AST_This, function To_Moz_ThisExpression() {\n        return { type: \"ThisExpression\" };\n    });\n\n    def_to_moz(AST_RegExp, function To_Moz_RegExpLiteral(M) {\n        var flags = M.value.toString().match(/[gimuy]*$/)[0];\n        var value = \"/\" + M.value.raw_source + \"/\" + flags;\n        return {\n            type: \"Literal\",\n            value: value,\n            raw: value,\n            regex: {\n                pattern: M.value.raw_source,\n                flags: flags\n            }\n        };\n    });\n\n    def_to_moz(AST_Constant, function To_Moz_Literal(M) {\n        var value = M.value;\n        if (typeof value === 'number' && (value < 0 || (value === 0 && 1 / value < 0))) {\n            return {\n                type: \"UnaryExpression\",\n                operator: \"-\",\n                prefix: true,\n                argument: {\n                    type: \"Literal\",\n                    value: -value,\n                    raw: M.start.raw\n                }\n            };\n        }\n        return {\n            type: \"Literal\",\n            value: value,\n            raw: M.start.raw\n        };\n    });\n\n    def_to_moz(AST_Atom, function To_Moz_Atom(M) {\n        return {\n            type: \"Identifier\",\n            name: String(M.value)\n        };\n    });\n\n    AST_Boolean.DEFMETHOD(\"to_mozilla_ast\", AST_Constant.prototype.to_mozilla_ast);\n    AST_Null.DEFMETHOD(\"to_mozilla_ast\", AST_Constant.prototype.to_mozilla_ast);\n    AST_Hole.DEFMETHOD(\"to_mozilla_ast\", function To_Moz_ArrayHole() { return null });\n\n    AST_Block.DEFMETHOD(\"to_mozilla_ast\", AST_BlockStatement.prototype.to_mozilla_ast);\n    AST_Lambda.DEFMETHOD(\"to_mozilla_ast\", AST_Function.prototype.to_mozilla_ast);\n\n    /* -----[ tools ]----- */\n\n    function raw_token(moznode) {\n        if (moznode.type == \"Literal\") {\n            return moznode.raw != null ? moznode.raw : moznode.value + \"\";\n        }\n    }\n\n    function my_start_token(moznode) {\n        var loc = moznode.loc, start = loc && loc.start;\n        var range = moznode.range;\n        return new AST_Token({\n            file    : loc && loc.source,\n            line    : start && start.line,\n            col     : start && start.column,\n            pos     : range ? range[0] : moznode.start,\n            endline : start && start.line,\n            endcol  : start && start.column,\n            endpos  : range ? range[0] : moznode.start,\n            raw     : raw_token(moznode),\n        });\n    }\n\n    function my_end_token(moznode) {\n        var loc = moznode.loc, end = loc && loc.end;\n        var range = moznode.range;\n        return new AST_Token({\n            file    : loc && loc.source,\n            line    : end && end.line,\n            col     : end && end.column,\n            pos     : range ? range[1] : moznode.end,\n            endline : end && end.line,\n            endcol  : end && end.column,\n            endpos  : range ? range[1] : moznode.end,\n            raw     : raw_token(moznode),\n        });\n    }\n\n    function map(moztype, mytype, propmap) {\n        var moz_to_me = \"function From_Moz_\" + moztype + \"(M){\\n\";\n        moz_to_me += \"return new U2.\" + mytype.name + \"({\\n\" +\n            \"start: my_start_token(M),\\n\" +\n            \"end: my_end_token(M)\";\n\n        var me_to_moz = \"function To_Moz_\" + moztype + \"(M){\\n\";\n        me_to_moz += \"return {\\n\" +\n            \"type: \" + JSON.stringify(moztype);\n\n        if (propmap) propmap.split(/\\s*,\\s*/).forEach(function(prop) {\n            var m = /([a-z0-9$_]+)(=|@|>|%)([a-z0-9$_]+)/i.exec(prop);\n            if (!m) throw new Error(\"Can't understand property map: \" + prop);\n            var moz = m[1], how = m[2], my = m[3];\n            moz_to_me += \",\\n\" + my + \": \";\n            me_to_moz += \",\\n\" + moz + \": \";\n            switch (how) {\n                case \"@\":\n                    moz_to_me += \"M.\" + moz + \".map(from_moz)\";\n                    me_to_moz += \"M.\" +  my + \".map(to_moz)\";\n                    break;\n                case \">\":\n                    moz_to_me += \"from_moz(M.\" + moz + \")\";\n                    me_to_moz += \"to_moz(M.\" + my + \")\";\n                    break;\n                case \"=\":\n                    moz_to_me += \"M.\" + moz;\n                    me_to_moz += \"M.\" + my;\n                    break;\n                case \"%\":\n                    moz_to_me += \"from_moz(M.\" + moz + \").body\";\n                    me_to_moz += \"to_moz_block(M)\";\n                    break;\n                default:\n                    throw new Error(\"Can't understand operator in propmap: \" + prop);\n            }\n        });\n\n        moz_to_me += \"\\n})\\n}\";\n        me_to_moz += \"\\n}\\n}\";\n\n        //moz_to_me = parse(moz_to_me).print_to_string({ beautify: true });\n        //me_to_moz = parse(me_to_moz).print_to_string({ beautify: true });\n        //console.log(moz_to_me);\n\n        moz_to_me = new Function(\"U2\", \"my_start_token\", \"my_end_token\", \"from_moz\", \"return(\" + moz_to_me + \")\")(\n            exports, my_start_token, my_end_token, from_moz\n        );\n        me_to_moz = new Function(\"to_moz\", \"to_moz_block\", \"to_moz_scope\", \"return(\" + me_to_moz + \")\")(\n            to_moz, to_moz_block, to_moz_scope\n        );\n        MOZ_TO_ME[moztype] = moz_to_me;\n        def_to_moz(mytype, me_to_moz);\n    }\n\n    var FROM_MOZ_STACK = null;\n\n    function from_moz(node) {\n        FROM_MOZ_STACK.push(node);\n        var ret = node != null ? MOZ_TO_ME[node.type](node) : null;\n        FROM_MOZ_STACK.pop();\n        return ret;\n    }\n\n    AST_Node.from_mozilla_ast = function(node) {\n        var save_stack = FROM_MOZ_STACK;\n        FROM_MOZ_STACK = [];\n        var ast = from_moz(node);\n        FROM_MOZ_STACK = save_stack;\n        ast.walk(new TreeWalker(function(node) {\n            if (node instanceof AST_LabelRef) {\n                for (var level = 0, parent; parent = this.parent(level); level++) {\n                    if (parent instanceof AST_Scope) break;\n                    if (parent instanceof AST_LabeledStatement && parent.label.name == node.name) {\n                        node.thedef = parent.label;\n                        break;\n                    }\n                }\n                if (!node.thedef) {\n                    var s = node.start;\n                    js_error(\"Undefined label \" + node.name, s.file, s.line, s.col, s.pos);\n                }\n            }\n        }));\n        return ast;\n    };\n\n    function set_moz_loc(mynode, moznode, myparent) {\n        var start = mynode.start;\n        var end = mynode.end;\n        if (start.pos != null && end.endpos != null) {\n            moznode.range = [start.pos, end.endpos];\n        }\n        if (start.line) {\n            moznode.loc = {\n                start: {line: start.line, column: start.col},\n                end: end.endline ? {line: end.endline, column: end.endcol} : null\n            };\n            if (start.file) {\n                moznode.loc.source = start.file;\n            }\n        }\n        return moznode;\n    }\n\n    function def_to_moz(mytype, handler) {\n        mytype.DEFMETHOD(\"to_mozilla_ast\", function() {\n            return set_moz_loc(this, handler(this));\n        });\n    }\n\n    function to_moz(node) {\n        return node != null ? node.to_mozilla_ast() : null;\n    }\n\n    function to_moz_block(node) {\n        return {\n            type: \"BlockStatement\",\n            body: node.body.map(to_moz)\n        };\n    }\n\n    function to_moz_scope(type, node) {\n        var body = node.body.map(to_moz);\n        if (node.body[0] instanceof AST_SimpleStatement && node.body[0].body instanceof AST_String) {\n            body.unshift(to_moz(new AST_EmptyStatement(node.body[0])));\n        }\n        return {\n            type: type,\n            body: body\n        };\n    }\n})();\n","/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\n\"use strict\";\n\nfunction is_some_comments(comment) {\n    // multiline comment\n    return comment.type == \"comment2\" && /@preserve|@license|@cc_on/i.test(comment.value);\n}\n\nfunction OutputStream(options) {\n\n    var readonly = !options;\n    options = defaults(options, {\n        ascii_only       : false,\n        beautify         : false,\n        braces           : false,\n        comments         : false,\n        galio            : false,\n        ie8              : false,\n        indent_level     : 4,\n        indent_start     : 0,\n        inline_script    : true,\n        keep_quoted_props: false,\n        max_line_len     : false,\n        preamble         : null,\n        preserve_line    : false,\n        quote_keys       : false,\n        quote_style      : 0,\n        semicolons       : true,\n        shebang          : true,\n        source_map       : null,\n        v8               : false,\n        webkit           : false,\n        width            : 80,\n        wrap_iife        : false,\n    }, true);\n\n    // Convert comment option to RegExp if neccessary and set up comments filter\n    var comment_filter = return_false; // Default case, throw all comments away\n    if (options.comments) {\n        var comments = options.comments;\n        if (typeof options.comments === \"string\" && /^\\/.*\\/[a-zA-Z]*$/.test(options.comments)) {\n            var regex_pos = options.comments.lastIndexOf(\"/\");\n            comments = new RegExp(\n                options.comments.substr(1, regex_pos - 1),\n                options.comments.substr(regex_pos + 1)\n            );\n        }\n        if (comments instanceof RegExp) {\n            comment_filter = function(comment) {\n                return comment.type != \"comment5\" && comments.test(comment.value);\n            };\n        } else if (typeof comments === \"function\") {\n            comment_filter = function(comment) {\n                return comment.type != \"comment5\" && comments(this, comment);\n            };\n        } else if (comments === \"some\") {\n            comment_filter = is_some_comments;\n        } else { // NOTE includes \"all\" option\n            comment_filter = return_true;\n        }\n    }\n\n    var indentation = options.indent_start;\n    var current_col = 0;\n    var current_line = 1;\n    var current_pos = 0;\n    var OUTPUT = \"\";\n\n    var to_utf8 = options.ascii_only ? function(str, identifier) {\n        if (identifier) str = str.replace(/[\\ud800-\\udbff][\\udc00-\\udfff]/g, function(ch) {\n            return \"\\\\u{\" + (ch.charCodeAt(0) - 0xd7c0 << 10 | ch.charCodeAt(1) - 0xdc00).toString(16) + \"}\";\n        });\n        return str.replace(/[\\u0000-\\u001f\\u007f-\\uffff]/g, function(ch) {\n            var code = ch.charCodeAt(0).toString(16);\n            if (code.length <= 2 && !identifier) {\n                while (code.length < 2) code = \"0\" + code;\n                return \"\\\\x\" + code;\n            } else {\n                while (code.length < 4) code = \"0\" + code;\n                return \"\\\\u\" + code;\n            }\n        });\n    } : function(str) {\n        var s = \"\";\n        for (var i = 0, j = 0; i < str.length; i++) {\n            var code = str.charCodeAt(i);\n            if (is_surrogate_pair_head(code)) {\n                if (is_surrogate_pair_tail(str.charCodeAt(i + 1))) {\n                    i++;\n                    continue;\n                }\n            } else if (!is_surrogate_pair_tail(code)) {\n                continue;\n            }\n            s += str.slice(j, i) + \"\\\\u\" + code.toString(16);\n            j = i + 1;\n        }\n        return j == 0 ? str : s + str.slice(j);\n    };\n\n    function make_string(str, quote) {\n        var dq = 0, sq = 0;\n        str = str.replace(/[\\\\\\b\\f\\n\\r\\v\\t\\x22\\x27\\u2028\\u2029\\0\\ufeff]/g, function(s, i) {\n            switch (s) {\n              case '\"': ++dq; return '\"';\n              case \"'\": ++sq; return \"'\";\n              case \"\\\\\": return \"\\\\\\\\\";\n              case \"\\n\": return \"\\\\n\";\n              case \"\\r\": return \"\\\\r\";\n              case \"\\t\": return \"\\\\t\";\n              case \"\\b\": return \"\\\\b\";\n              case \"\\f\": return \"\\\\f\";\n              case \"\\x0B\": return options.ie8 ? \"\\\\x0B\" : \"\\\\v\";\n              case \"\\u2028\": return \"\\\\u2028\";\n              case \"\\u2029\": return \"\\\\u2029\";\n              case \"\\ufeff\": return \"\\\\ufeff\";\n              case \"\\0\":\n                  return /[0-9]/.test(str.charAt(i+1)) ? \"\\\\x00\" : \"\\\\0\";\n            }\n            return s;\n        });\n        function quote_single() {\n            return \"'\" + str.replace(/\\x27/g, \"\\\\'\") + \"'\";\n        }\n        function quote_double() {\n            return '\"' + str.replace(/\\x22/g, '\\\\\"') + '\"';\n        }\n        str = to_utf8(str);\n        switch (options.quote_style) {\n          case 1:\n            return quote_single();\n          case 2:\n            return quote_double();\n          case 3:\n            return quote == \"'\" ? quote_single() : quote_double();\n          default:\n            return dq > sq ? quote_single() : quote_double();\n        }\n    }\n\n    function encode_string(str, quote) {\n        var ret = make_string(str, quote);\n        if (options.inline_script) {\n            ret = ret.replace(/<\\x2f(script)([>\\/\\t\\n\\f\\r ])/gi, \"<\\\\/$1$2\");\n            ret = ret.replace(/\\x3c!--/g, \"\\\\x3c!--\");\n            ret = ret.replace(/--\\x3e/g, \"--\\\\x3e\");\n        }\n        return ret;\n    }\n\n    function make_name(name) {\n        name = name.toString();\n        name = to_utf8(name, true);\n        return name;\n    }\n\n    /* -----[ beautification/minification ]----- */\n\n    var has_parens = false;\n    var line_end = 0;\n    var line_fixed = true;\n    var might_need_space = false;\n    var might_need_semicolon = false;\n    var need_newline_indented = false;\n    var need_space = false;\n    var newline_insert = -1;\n    var last = \"\";\n    var mapping_token, mapping_name, mappings = options.source_map && [];\n\n    var adjust_mappings = mappings ? function(line, col) {\n        mappings.forEach(function(mapping) {\n            mapping.line += line;\n            mapping.col += col;\n        });\n    } : noop;\n\n    var flush_mappings = mappings ? function() {\n        mappings.forEach(function(mapping) {\n            options.source_map.add(\n                mapping.token.file,\n                mapping.line, mapping.col,\n                mapping.token.line, mapping.token.col,\n                !mapping.name && mapping.token.type == \"name\" ? mapping.token.value : mapping.name\n            );\n        });\n        mappings = [];\n    } : noop;\n\n    function insert_newlines(count) {\n        var index = OUTPUT.lastIndexOf(\"\\n\");\n        if (line_end < index) line_end = index;\n        var left = OUTPUT.slice(0, line_end);\n        var right = OUTPUT.slice(line_end);\n        adjust_mappings(count, right.length - current_col);\n        current_line += count;\n        current_pos += count;\n        current_col = right.length;\n        OUTPUT = left;\n        while (count--) OUTPUT += \"\\n\";\n        OUTPUT += right;\n    }\n\n    var fix_line = options.max_line_len ? function() {\n        if (line_fixed) {\n            if (current_col > options.max_line_len) {\n                AST_Node.warn(\"Output exceeds {max_line_len} characters\", options);\n            }\n            return;\n        }\n        if (current_col > options.max_line_len) insert_newlines(1);\n        line_fixed = true;\n        flush_mappings();\n    } : noop;\n\n    var requireSemicolonChars = makePredicate(\"( [ + * / - , .\");\n\n    function print(str) {\n        str = String(str);\n        var ch = str.charAt(0);\n        if (need_newline_indented && ch) {\n            need_newline_indented = false;\n            if (ch != \"\\n\") {\n                print(\"\\n\");\n                indent();\n            }\n        }\n        if (need_space && ch) {\n            need_space = false;\n            if (!/[\\s;})]/.test(ch)) {\n                space();\n            }\n        }\n        newline_insert = -1;\n        var prev = last.slice(-1);\n        if (might_need_semicolon) {\n            might_need_semicolon = false;\n\n            if (prev == \":\" && ch == \"}\" || (!ch || \";}\".indexOf(ch) < 0) && prev != \";\") {\n                if (options.semicolons || requireSemicolonChars[ch]) {\n                    OUTPUT += \";\";\n                    current_col++;\n                    current_pos++;\n                } else {\n                    fix_line();\n                    OUTPUT += \"\\n\";\n                    current_pos++;\n                    current_line++;\n                    current_col = 0;\n\n                    if (/^\\s+$/.test(str)) {\n                        // reset the semicolon flag, since we didn't print one\n                        // now and might still have to later\n                        might_need_semicolon = true;\n                    }\n                }\n\n                if (!options.beautify)\n                    might_need_space = false;\n            }\n        }\n\n        if (might_need_space) {\n            if (is_identifier_char(prev) && (is_identifier_char(ch) || ch == \"\\\\\")\n                || (ch == \"/\" && ch == prev)\n                || ((ch == \"+\" || ch == \"-\") && ch == last)\n                || str == \"--\" && last == \"!\"\n                || str == \"in\" && prev == \"/\"\n                || last == \"--\" && ch == \">\") {\n                OUTPUT += \" \";\n                current_col++;\n                current_pos++;\n            }\n            if (prev != \"<\" || str != \"!\") might_need_space = false;\n        }\n\n        if (mapping_token) {\n            mappings.push({\n                token: mapping_token,\n                name: mapping_name,\n                line: current_line,\n                col: current_col\n            });\n            mapping_token = false;\n            if (line_fixed) flush_mappings();\n        }\n\n        OUTPUT += str;\n        has_parens = str.slice(-1) == \"(\";\n        current_pos += str.length;\n        var a = str.split(/\\r?\\n/), n = a.length - 1;\n        current_line += n;\n        current_col += a[0].length;\n        if (n > 0) {\n            fix_line();\n            current_col = a[n].length;\n        }\n        last = str;\n    }\n\n    var space = options.beautify ? function() {\n        print(\" \");\n    } : function() {\n        might_need_space = true;\n    };\n\n    var indent = options.beautify ? function(half) {\n        print(repeat_string(\" \", half ? indentation - (options.indent_level >> 1) : indentation));\n    } : noop;\n\n    var with_indent = options.beautify ? function(col, cont) {\n        if (col === true) col = next_indent();\n        var save_indentation = indentation;\n        indentation = col;\n        var ret = cont();\n        indentation = save_indentation;\n        return ret;\n    } : function(col, cont) { return cont() };\n\n    var may_add_newline = options.max_line_len || options.preserve_line ? function() {\n        fix_line();\n        line_end = OUTPUT.length;\n        line_fixed = false;\n    } : noop;\n\n    var newline = options.beautify ? function() {\n        if (newline_insert < 0) return print(\"\\n\");\n        if (OUTPUT[newline_insert] != \"\\n\") {\n            OUTPUT = OUTPUT.slice(0, newline_insert) + \"\\n\" + OUTPUT.slice(newline_insert);\n            current_pos++;\n            current_line++;\n        }\n        newline_insert++;\n    } : may_add_newline;\n\n    var semicolon = options.beautify ? function() {\n        print(\";\");\n    } : function() {\n        might_need_semicolon = true;\n    };\n\n    function force_semicolon() {\n        if (might_need_semicolon) print(\";\");\n        print(\";\");\n    }\n\n    function next_indent() {\n        return indentation + options.indent_level;\n    }\n\n    function with_block(cont) {\n        var ret;\n        print(\"{\");\n        newline();\n        with_indent(next_indent(), function() {\n            ret = cont();\n        });\n        indent();\n        print(\"}\");\n        return ret;\n    }\n\n    function with_parens(cont) {\n        print(\"(\");\n        may_add_newline();\n        //XXX: still nice to have that for argument lists\n        //var ret = with_indent(current_col, cont);\n        var ret = cont();\n        may_add_newline();\n        print(\")\");\n        return ret;\n    }\n\n    function with_square(cont) {\n        print(\"[\");\n        may_add_newline();\n        //var ret = with_indent(current_col, cont);\n        var ret = cont();\n        may_add_newline();\n        print(\"]\");\n        return ret;\n    }\n\n    function comma() {\n        may_add_newline();\n        print(\",\");\n        may_add_newline();\n        space();\n    }\n\n    function colon() {\n        print(\":\");\n        space();\n    }\n\n    var add_mapping = mappings ? function(token, name) {\n        mapping_token = token;\n        mapping_name = name;\n    } : noop;\n\n    function get() {\n        if (!line_fixed) fix_line();\n        return OUTPUT;\n    }\n\n    function has_nlb() {\n        var index = OUTPUT.lastIndexOf(\"\\n\");\n        return /^ *$/.test(OUTPUT.slice(index + 1));\n    }\n\n    function prepend_comments(node) {\n        var self = this;\n        var scan = node instanceof AST_Exit && node.value;\n        var comments = dump(node);\n        if (!comments) comments = [];\n\n        if (scan) {\n            var tw = new TreeWalker(function(node) {\n                var parent = tw.parent();\n                if (parent instanceof AST_Exit\n                    || parent instanceof AST_Binary && parent.left === node\n                    || parent.TYPE == \"Call\" && parent.expression === node\n                    || parent instanceof AST_Conditional && parent.condition === node\n                    || parent instanceof AST_Dot && parent.expression === node\n                    || parent instanceof AST_Sequence && parent.expressions[0] === node\n                    || parent instanceof AST_Sub && parent.expression === node\n                    || parent instanceof AST_UnaryPostfix) {\n                    var before = dump(node);\n                    if (before) comments = comments.concat(before);\n                } else {\n                    return true;\n                }\n            });\n            tw.push(node);\n            node.value.walk(tw);\n        }\n\n        if (current_pos == 0) {\n            if (comments.length > 0 && options.shebang && comments[0].type == \"comment5\") {\n                print(\"#!\" + comments.shift().value + \"\\n\");\n                indent();\n            }\n            var preamble = options.preamble;\n            if (preamble) {\n                print(preamble.replace(/\\r\\n?|[\\n\\u2028\\u2029]|\\s*$/g, \"\\n\"));\n            }\n        }\n\n        comments = comments.filter(comment_filter, node);\n        if (comments.length == 0) return;\n        var last_nlb = has_nlb();\n        comments.forEach(function(c, i) {\n            if (!last_nlb) {\n                if (c.nlb) {\n                    print(\"\\n\");\n                    indent();\n                    last_nlb = true;\n                } else if (i > 0) {\n                    space();\n                }\n            }\n            if (/comment[134]/.test(c.type)) {\n                print(\"//\" + c.value.replace(/[@#]__PURE__/g, \" \") + \"\\n\");\n                indent();\n                last_nlb = true;\n            } else if (c.type == \"comment2\") {\n                print(\"/*\" + c.value.replace(/[@#]__PURE__/g, \" \") + \"*/\");\n                last_nlb = false;\n            }\n        });\n        if (!last_nlb) {\n            if (node.start.nlb) {\n                print(\"\\n\");\n                indent();\n            } else {\n                space();\n            }\n        }\n\n        function dump(node) {\n            var token = node.start;\n            if (!token) {\n                if (!scan) return;\n                node.start = token = new AST_Token();\n            }\n            var comments = token.comments_before;\n            if (!comments) {\n                if (!scan) return;\n                token.comments_before = comments = [];\n            }\n            if (comments._dumped === self) return;\n            comments._dumped = self;\n            return comments;\n        }\n    }\n\n    function append_comments(node, tail) {\n        var self = this;\n        var token = node.end;\n        if (!token) return;\n        var comments = token[tail ? \"comments_before\" : \"comments_after\"];\n        if (!comments || comments._dumped === self) return;\n        if (!(node instanceof AST_Statement || all(comments, function(c) {\n            return !/comment[134]/.test(c.type);\n        }))) return;\n        comments._dumped = self;\n        var insert = OUTPUT.length;\n        comments.filter(comment_filter, node).forEach(function(c, i) {\n            need_space = false;\n            if (need_newline_indented) {\n                print(\"\\n\");\n                indent();\n                need_newline_indented = false;\n            } else if (c.nlb && (i > 0 || !has_nlb())) {\n                print(\"\\n\");\n                indent();\n            } else if (i > 0 || !tail) {\n                space();\n            }\n            if (/comment[134]/.test(c.type)) {\n                print(\"//\" + c.value.replace(/[@#]__PURE__/g, \" \"));\n                need_newline_indented = true;\n            } else if (c.type == \"comment2\") {\n                print(\"/*\" + c.value.replace(/[@#]__PURE__/g, \" \") + \"*/\");\n                need_space = true;\n            }\n        });\n        if (OUTPUT.length > insert) newline_insert = insert;\n    }\n\n    var stack = [];\n    return {\n        get             : get,\n        toString        : get,\n        indent          : indent,\n        should_break    : readonly ? noop : function() {\n            return options.width && current_col - indentation >= options.width;\n        },\n        has_parens      : function() { return has_parens },\n        newline         : newline,\n        print           : print,\n        space           : space,\n        comma           : comma,\n        colon           : colon,\n        last            : function() { return last },\n        semicolon       : semicolon,\n        force_semicolon : force_semicolon,\n        to_utf8         : to_utf8,\n        print_name      : function(name) { print(make_name(name)) },\n        print_string    : function(str, quote) { print(encode_string(str, quote)) },\n        next_indent     : next_indent,\n        with_indent     : with_indent,\n        with_block      : with_block,\n        with_parens     : with_parens,\n        with_square     : with_square,\n        add_mapping     : add_mapping,\n        option          : function(opt) { return options[opt] },\n        prepend_comments: readonly ? noop : prepend_comments,\n        append_comments : readonly || comment_filter === return_false ? noop : append_comments,\n        line            : function() { return current_line },\n        col             : function() { return current_col },\n        pos             : function() { return current_pos },\n        push_node       : function(node) { stack.push(node) },\n        pop_node        : options.preserve_line ? function() {\n            var node = stack.pop();\n            if (node.start && node.start.line > current_line) {\n                insert_newlines(node.start.line - current_line);\n            }\n        } : function() {\n            stack.pop();\n        },\n        parent          : function(n) {\n            return stack[stack.length - 2 - (n || 0)];\n        },\n    };\n}\n\n/* -----[ code generators ]----- */\n\n(function() {\n\n    /* -----[ utils ]----- */\n\n    function DEFPRINT(nodetype, generator) {\n        nodetype.DEFMETHOD(\"_codegen\", generator);\n    }\n\n    var use_asm = false;\n\n    AST_Node.DEFMETHOD(\"print\", function(stream, force_parens) {\n        var self = this;\n        stream.push_node(self);\n        if (force_parens || self.needs_parens(stream)) {\n            stream.with_parens(doit);\n        } else {\n            doit();\n        }\n        stream.pop_node();\n\n        function doit() {\n            stream.prepend_comments(self);\n            self.add_source_map(stream);\n            self._codegen(stream);\n            stream.append_comments(self);\n        }\n    });\n    AST_Node.DEFMETHOD(\"print_to_string\", function(options) {\n        var s = OutputStream(options);\n        this.print(s);\n        return s.get();\n    });\n\n    /* -----[ PARENTHESES ]----- */\n\n    function PARENS(nodetype, func) {\n        nodetype.DEFMETHOD(\"needs_parens\", func);\n    }\n\n    PARENS(AST_Node, return_false);\n\n    // a function expression needs parens around it when it's provably\n    // the first token to appear in a statement.\n    function needs_parens_function(output) {\n        if (!output.has_parens() && first_in_statement(output)) return true;\n        if (output.option(\"webkit\")) {\n            var p = output.parent();\n            if (p instanceof AST_PropAccess && p.expression === this) return true;\n        }\n        if (output.option(\"wrap_iife\")) {\n            var p = output.parent();\n            if (p instanceof AST_Call && p.expression === this) return true;\n        }\n    }\n    PARENS(AST_AsyncFunction, needs_parens_function);\n    PARENS(AST_Function, needs_parens_function);\n\n    // same goes for an object literal, because otherwise it would be\n    // interpreted as a block of code.\n    function needs_parens_obj(output) {\n        return !output.has_parens() && first_in_statement(output, true);\n    }\n    PARENS(AST_Object, needs_parens_obj);\n\n    PARENS(AST_Unary, function(output) {\n        var p = output.parent();\n        return (p instanceof AST_Call || p instanceof AST_PropAccess) && p.expression === this;\n    });\n\n    PARENS(AST_Sequence, function(output) {\n        var p = output.parent();\n            // [ 1, (2, 3), 4 ] ==> [ 1, 3, 4 ]\n        return p instanceof AST_Array\n            // () => (foo, bar)\n            || p instanceof AST_Arrow && p.value === this\n            // await (foo, bar)\n            || p instanceof AST_Await\n            // 1 + (2, 3) + 4 ==> 8\n            || p instanceof AST_Binary\n            // new (foo, bar) or foo(1, (2, 3), 4)\n            || p instanceof AST_Call\n            // (false, true) ? (a = 10, b = 20) : (c = 30)\n            // ==> 20 (side effect, set a := 10 and b := 20)\n            || p instanceof AST_Conditional\n            // [ a = (1, 2) ] = [] ==> a == 2\n            || p instanceof AST_DefaultValue\n            // { [(1, 2)]: 3 }[2] ==> 3\n            // { foo: (1, 2) }.foo ==> 2\n            || p instanceof AST_DestructuredKeyVal\n            || p instanceof AST_ObjectProperty\n            // (1, {foo:2}).foo or (1, {foo:2})[\"foo\"] ==> 2\n            || p instanceof AST_PropAccess && p.expression === this\n            // ...(foo, bar, baz)\n            || p instanceof AST_Spread\n            // !(foo, bar, baz)\n            || p instanceof AST_Unary\n            // var a = (1, 2), b = a + a; ==> b == 4\n            || p instanceof AST_VarDef;\n    });\n\n    PARENS(AST_Binary, function(output) {\n        var p = output.parent();\n        // await (foo && bar)\n        if (p instanceof AST_Await) return true;\n        // this deals with precedence: 3 * (2 + 1)\n        if (p instanceof AST_Binary) {\n            var po = p.operator, pp = PRECEDENCE[po];\n            var so = this.operator, sp = PRECEDENCE[so];\n            return pp > sp || (pp == sp && this === p.right);\n        }\n        // (foo && bar)()\n        if (p instanceof AST_Call) return p.expression === this;\n        // (foo && bar)[\"prop\"], (foo && bar).prop\n        if (p instanceof AST_PropAccess) return p.expression === this;\n        // typeof (foo && bar)\n        if (p instanceof AST_Unary) return true;\n    });\n\n    PARENS(AST_PropAccess, function(output) {\n        var node = this;\n        var p = output.parent();\n        if (p instanceof AST_New && p.expression === node) {\n            // i.e. new (foo().bar)\n            //\n            // if there's one call into this subtree, then we need\n            // parens around it too, otherwise the call will be\n            // interpreted as passing the arguments to the upper New\n            // expression.\n            do {\n                node = node.expression;\n            } while (node instanceof AST_PropAccess);\n            return node.TYPE == \"Call\";\n        }\n    });\n\n    PARENS(AST_Call, function(output) {\n        var p = output.parent();\n        if (p instanceof AST_New) return p.expression === this;\n        // https://bugs.webkit.org/show_bug.cgi?id=123506\n        if (output.option(\"webkit\")) {\n            var g = output.parent(1);\n            return this.expression instanceof AST_Function\n                && p instanceof AST_PropAccess\n                && p.expression === this\n                && g instanceof AST_Assign\n                && g.left === p;\n        }\n    });\n\n    PARENS(AST_New, function(output) {\n        if (need_constructor_parens(this, output)) return false;\n        var p = output.parent();\n        // (new foo)(bar)\n        if (p instanceof AST_Call) return p.expression === this;\n        // (new Date).getTime(), (new Date)[\"getTime\"]()\n        return p instanceof AST_PropAccess;\n    });\n\n    PARENS(AST_Number, function(output) {\n        var p = output.parent();\n        if (p instanceof AST_PropAccess && p.expression === this) {\n            var value = this.value;\n                // https://github.com/mishoo/UglifyJS/issues/115\n            return value < 0\n                // https://github.com/mishoo/UglifyJS/pull/1009\n                || output.option(\"galio\") && /^0/.test(make_num(value));\n        }\n    });\n\n    function needs_parens_assign_cond(self, output) {\n        var p = output.parent();\n        // await (a = foo)\n        if (p instanceof AST_Await) return true;\n        // 1 + (a = 2) + 3 → 6, side effect setting a = 2\n        if (p instanceof AST_Binary) return !(p instanceof AST_Assign);\n        // (a = func)() —or— new (a = Object)()\n        if (p instanceof AST_Call) return p.expression === self;\n        // (a = foo) ? bar : baz\n        if (p instanceof AST_Conditional) return p.condition === self;\n        // (a = foo)[\"prop\"] —or— (a = foo).prop\n        if (p instanceof AST_PropAccess) return p.expression === self;\n        // !(a = false) → true\n        if (p instanceof AST_Unary) return true;\n    }\n    PARENS(AST_Arrow, function(output) {\n        return needs_parens_assign_cond(this, output);\n    });\n    PARENS(AST_Assign, function(output) {\n        if (needs_parens_assign_cond(this, output)) return true;\n        //  v8 parser bug   =>     workaround\n        // f([1], [a] = []) => f([1], ([a] = []))\n        if (output.option(\"v8\")) return this.left instanceof AST_Destructured;\n        // ({ p: a } = o);\n        if (this.left instanceof AST_DestructuredObject) return needs_parens_obj(output);\n    });\n    PARENS(AST_Conditional, function(output) {\n        return needs_parens_assign_cond(this, output);\n    });\n\n    PARENS(AST_Await, function(output) {\n        var p = output.parent();\n        // new (await foo)\n        // (await foo)(bar)\n        if (p instanceof AST_Call) return p.expression === this;\n        // (await foo).prop\n        // (await foo)[\"prop\"]\n        if (p instanceof AST_PropAccess) return p.expression === this;\n    });\n\n    /* -----[ PRINTERS ]----- */\n\n    DEFPRINT(AST_Directive, function(output) {\n        var quote = this.quote;\n        var value = this.value;\n        switch (output.option(\"quote_style\")) {\n          case 0:\n          case 2:\n            if (value.indexOf('\"') == -1) quote = '\"';\n            break;\n          case 1:\n            if (value.indexOf(\"'\") == -1) quote = \"'\";\n            break;\n        }\n        output.print(quote + value + quote);\n        output.semicolon();\n    });\n    DEFPRINT(AST_Debugger, function(output) {\n        output.print(\"debugger\");\n        output.semicolon();\n    });\n\n    /* -----[ statements ]----- */\n\n    function display_body(body, is_toplevel, output, allow_directives) {\n        var last = body.length - 1;\n        var in_directive = allow_directives;\n        var was_asm = use_asm;\n        body.forEach(function(stmt, i) {\n            if (in_directive) {\n                if (stmt instanceof AST_Directive) {\n                    if (stmt.value == \"use asm\") use_asm = true;\n                } else if (!(stmt instanceof AST_EmptyStatement)) {\n                    if (stmt instanceof AST_SimpleStatement && stmt.body instanceof AST_String) {\n                        output.force_semicolon();\n                    }\n                    in_directive = false;\n                }\n            }\n            if (stmt instanceof AST_EmptyStatement) return;\n            output.indent();\n            stmt.print(output);\n            if (i == last && is_toplevel) return;\n            output.newline();\n            if (is_toplevel) output.newline();\n        });\n        use_asm = was_asm;\n    }\n\n    DEFPRINT(AST_Statement, function(output) {\n        this.body.print(output);\n        output.semicolon();\n    });\n    DEFPRINT(AST_Toplevel, function(output) {\n        display_body(this.body, true, output, true);\n        output.print(\"\");\n    });\n    DEFPRINT(AST_LabeledStatement, function(output) {\n        this.label.print(output);\n        output.colon();\n        this.body.print(output);\n    });\n    DEFPRINT(AST_SimpleStatement, function(output) {\n        this.body.print(output);\n        output.semicolon();\n    });\n    function print_braced_empty(self, output) {\n        output.print(\"{\");\n        output.with_indent(output.next_indent(), function() {\n            output.append_comments(self, true);\n        });\n        output.print(\"}\");\n    }\n    function print_braced(self, output, allow_directives) {\n        if (self.body.length > 0) {\n            output.with_block(function() {\n                display_body(self.body, false, output, allow_directives);\n            });\n        } else print_braced_empty(self, output);\n    }\n    DEFPRINT(AST_BlockStatement, function(output) {\n        print_braced(this, output);\n    });\n    DEFPRINT(AST_EmptyStatement, function(output) {\n        output.semicolon();\n    });\n    DEFPRINT(AST_Do, function(output) {\n        var self = this;\n        output.print(\"do\");\n        output.space();\n        make_block(self.body, output);\n        output.space();\n        output.print(\"while\");\n        output.space();\n        output.with_parens(function() {\n            self.condition.print(output);\n        });\n        output.semicolon();\n    });\n    DEFPRINT(AST_While, function(output) {\n        var self = this;\n        output.print(\"while\");\n        output.space();\n        output.with_parens(function() {\n            self.condition.print(output);\n        });\n        output.space();\n        force_statement(self.body, output);\n    });\n    DEFPRINT(AST_For, function(output) {\n        var self = this;\n        output.print(\"for\");\n        output.space();\n        output.with_parens(function() {\n            if (self.init) {\n                if (self.init instanceof AST_Definitions) {\n                    self.init.print(output);\n                } else {\n                    parenthesize_for_noin(self.init, output, true);\n                }\n                output.print(\";\");\n                output.space();\n            } else {\n                output.print(\";\");\n            }\n            if (self.condition) {\n                self.condition.print(output);\n                output.print(\";\");\n                output.space();\n            } else {\n                output.print(\";\");\n            }\n            if (self.step) {\n                self.step.print(output);\n            }\n        });\n        output.space();\n        force_statement(self.body, output);\n    });\n    DEFPRINT(AST_ForIn, function(output) {\n        var self = this;\n        output.print(\"for\");\n        output.space();\n        output.with_parens(function() {\n            self.init.print(output);\n            output.space();\n            output.print(\"in\");\n            output.space();\n            self.object.print(output);\n        });\n        output.space();\n        force_statement(self.body, output);\n    });\n    DEFPRINT(AST_With, function(output) {\n        var self = this;\n        output.print(\"with\");\n        output.space();\n        output.with_parens(function() {\n            self.expression.print(output);\n        });\n        output.space();\n        force_statement(self.body, output);\n    });\n\n    /* -----[ functions ]----- */\n    DEFPRINT(AST_Arrow, function(output) {\n        var self = this;\n        if (self.argnames.length == 1 && self.argnames[0] instanceof AST_SymbolFunarg) {\n            self.argnames[0].print(output);\n        } else output.with_parens(function() {\n            self.argnames.forEach(function(arg, i) {\n                if (i) output.comma();\n                arg.print(output);\n            });\n        });\n        output.space();\n        output.print(\"=>\");\n        output.space();\n        if (self.value) {\n            self.value.print(output);\n        } else {\n            print_braced(self, output, true);\n        }\n    });\n    function print_lambda(self, output) {\n        if (self.name) {\n            output.space();\n            self.name.print(output);\n        }\n        output.with_parens(function() {\n            self.argnames.forEach(function(arg, i) {\n                if (i) output.comma();\n                arg.print(output);\n            });\n        });\n        output.space();\n        print_braced(self, output, true);\n    }\n    DEFPRINT(AST_Lambda, function(output) {\n        output.print(\"function\");\n        print_lambda(this, output);\n    });\n    function print_async(output) {\n        output.print(\"async\");\n        output.space();\n        output.print(\"function\");\n        print_lambda(this, output);\n    }\n    DEFPRINT(AST_AsyncDefun, print_async);\n    DEFPRINT(AST_AsyncFunction, print_async);\n\n    /* -----[ jumps ]----- */\n    function print_jump(kind, prop) {\n        return function(output) {\n            output.print(kind);\n            var target = this[prop];\n            if (target) {\n                output.space();\n                target.print(output);\n            }\n            output.semicolon();\n        };\n    }\n    DEFPRINT(AST_Return, print_jump(\"return\", \"value\"));\n    DEFPRINT(AST_Throw, print_jump(\"throw\", \"value\"));\n    DEFPRINT(AST_Break, print_jump(\"break\", \"label\"));\n    DEFPRINT(AST_Continue, print_jump(\"continue\", \"label\"));\n\n    /* -----[ if ]----- */\n    function make_then(self, output) {\n        var b = self.body;\n        if (output.option(\"braces\") && !(b instanceof AST_Const || b instanceof AST_Let)\n            || output.option(\"ie8\") && b instanceof AST_Do)\n            return make_block(b, output);\n        // The squeezer replaces \"block\"-s that contain only a single\n        // statement with the statement itself; technically, the AST\n        // is correct, but this can create problems when we output an\n        // IF having an ELSE clause where the THEN clause ends in an\n        // IF *without* an ELSE block (then the outer ELSE would refer\n        // to the inner IF).  This function checks for this case and\n        // adds the block braces if needed.\n        if (!b) return output.force_semicolon();\n        while (true) {\n            if (b instanceof AST_If) {\n                if (!b.alternative) {\n                    make_block(self.body, output);\n                    return;\n                }\n                b = b.alternative;\n            } else if (b instanceof AST_StatementWithBody) {\n                b = b.body;\n            } else break;\n        }\n        force_statement(self.body, output);\n    }\n    DEFPRINT(AST_If, function(output) {\n        var self = this;\n        output.print(\"if\");\n        output.space();\n        output.with_parens(function() {\n            self.condition.print(output);\n        });\n        output.space();\n        if (self.alternative) {\n            make_then(self, output);\n            output.space();\n            output.print(\"else\");\n            output.space();\n            if (self.alternative instanceof AST_If)\n                self.alternative.print(output);\n            else\n                force_statement(self.alternative, output);\n        } else {\n            force_statement(self.body, output);\n        }\n    });\n\n    /* -----[ switch ]----- */\n    DEFPRINT(AST_Switch, function(output) {\n        var self = this;\n        output.print(\"switch\");\n        output.space();\n        output.with_parens(function() {\n            self.expression.print(output);\n        });\n        output.space();\n        var last = self.body.length - 1;\n        if (last < 0) print_braced_empty(self, output);\n        else output.with_block(function() {\n            self.body.forEach(function(branch, i) {\n                output.indent(true);\n                branch.print(output);\n                if (i < last && branch.body.length > 0)\n                    output.newline();\n            });\n        });\n    });\n    function print_branch_body(self, output) {\n        output.newline();\n        self.body.forEach(function(stmt) {\n            output.indent();\n            stmt.print(output);\n            output.newline();\n        });\n    }\n    DEFPRINT(AST_Default, function(output) {\n        output.print(\"default:\");\n        print_branch_body(this, output);\n    });\n    DEFPRINT(AST_Case, function(output) {\n        var self = this;\n        output.print(\"case\");\n        output.space();\n        self.expression.print(output);\n        output.print(\":\");\n        print_branch_body(self, output);\n    });\n\n    /* -----[ exceptions ]----- */\n    DEFPRINT(AST_Try, function(output) {\n        var self = this;\n        output.print(\"try\");\n        output.space();\n        print_braced(self, output);\n        if (self.bcatch) {\n            output.space();\n            self.bcatch.print(output);\n        }\n        if (self.bfinally) {\n            output.space();\n            self.bfinally.print(output);\n        }\n    });\n    DEFPRINT(AST_Catch, function(output) {\n        var self = this;\n        output.print(\"catch\");\n        if (self.argname) {\n            output.space();\n            output.with_parens(function() {\n                self.argname.print(output);\n            });\n        }\n        output.space();\n        print_braced(self, output);\n    });\n    DEFPRINT(AST_Finally, function(output) {\n        output.print(\"finally\");\n        output.space();\n        print_braced(this, output);\n    });\n\n    function print_definitinos(type) {\n        return function(output) {\n            var self = this;\n            output.print(type);\n            output.space();\n            self.definitions.forEach(function(def, i) {\n                if (i) output.comma();\n                def.print(output);\n            });\n            var p = output.parent();\n            if (p && p.init !== self || !(p instanceof AST_For || p instanceof AST_ForIn)) output.semicolon();\n        };\n    }\n    DEFPRINT(AST_Const, print_definitinos(\"const\"));\n    DEFPRINT(AST_Let, print_definitinos(\"let\"));\n    DEFPRINT(AST_Var, print_definitinos(\"var\"));\n\n    function parenthesize_for_noin(node, output, noin) {\n        var parens = false;\n        // need to take some precautions here:\n        //    https://github.com/mishoo/UglifyJS/issues/60\n        if (noin) node.walk(new TreeWalker(function(node) {\n            if (parens) return true;\n            if (node instanceof AST_Binary && node.operator == \"in\") return parens = true;\n            if (node instanceof AST_Scope && !(node instanceof AST_Arrow && node.value)) return true;\n        }));\n        node.print(output, parens);\n    }\n\n    DEFPRINT(AST_VarDef, function(output) {\n        var self = this;\n        self.name.print(output);\n        if (self.value) {\n            output.space();\n            output.print(\"=\");\n            output.space();\n            var p = output.parent(1);\n            var noin = p instanceof AST_For || p instanceof AST_ForIn;\n            parenthesize_for_noin(self.value, output, noin);\n        }\n    });\n\n    DEFPRINT(AST_DefaultValue, function(output) {\n        var self = this;\n        self.name.print(output);\n        output.space();\n        output.print(\"=\");\n        output.space();\n        self.value.print(output);\n    });\n\n    /* -----[ other expressions ]----- */\n    function print_call_args(self, output) {\n        if (self.expression instanceof AST_Call || self.expression instanceof AST_Lambda) {\n            output.add_mapping(self.start);\n        }\n        output.with_parens(function() {\n            self.args.forEach(function(expr, i) {\n                if (i) output.comma();\n                expr.print(output);\n            });\n        });\n    }\n    DEFPRINT(AST_Call, function(output) {\n        this.expression.print(output);\n        print_call_args(this, output);\n    });\n    DEFPRINT(AST_New, function(output) {\n        var self = this;\n        output.print(\"new\");\n        output.space();\n        self.expression.print(output);\n        if (need_constructor_parens(self, output)) print_call_args(self, output);\n    });\n    DEFPRINT(AST_Sequence, function(output) {\n        this.expressions.forEach(function(node, index) {\n            if (index > 0) {\n                output.comma();\n                if (output.should_break()) {\n                    output.newline();\n                    output.indent();\n                }\n            }\n            node.print(output);\n        });\n    });\n    DEFPRINT(AST_Dot, function(output) {\n        var self = this;\n        var expr = self.expression;\n        expr.print(output);\n        var prop = self.property;\n        if (output.option(\"ie8\") && RESERVED_WORDS[prop]) {\n            output.print(\"[\");\n            output.add_mapping(self.end);\n            output.print_string(prop);\n            output.print(\"]\");\n        } else {\n            if (expr instanceof AST_Number && expr.value >= 0) {\n                if (!/[xa-f.)]/i.test(output.last())) {\n                    output.print(\".\");\n                }\n            }\n            output.print(\".\");\n            // the name after dot would be mapped about here.\n            output.add_mapping(self.end);\n            output.print_name(prop);\n        }\n    });\n    DEFPRINT(AST_Sub, function(output) {\n        this.expression.print(output);\n        output.print(\"[\");\n        this.property.print(output);\n        output.print(\"]\");\n    });\n    DEFPRINT(AST_Spread, function(output) {\n        output.print(\"...\");\n        this.expression.print(output);\n    });\n    DEFPRINT(AST_UnaryPrefix, function(output) {\n        var op = this.operator;\n        var exp = this.expression;\n        output.print(op);\n        if (/^[a-z]/i.test(op)\n            || (/[+-]$/.test(op)\n                && exp instanceof AST_UnaryPrefix\n                && /^[+-]/.test(exp.operator))) {\n            output.space();\n        }\n        exp.print(output);\n    });\n    DEFPRINT(AST_UnaryPostfix, function(output) {\n        this.expression.print(output);\n        output.print(this.operator);\n    });\n    DEFPRINT(AST_Binary, function(output) {\n        var self = this;\n        self.left.print(output);\n        output.space();\n        output.print(self.operator);\n        output.space();\n        self.right.print(output);\n    });\n    DEFPRINT(AST_Conditional, function(output) {\n        var self = this;\n        self.condition.print(output);\n        output.space();\n        output.print(\"?\");\n        output.space();\n        self.consequent.print(output);\n        output.space();\n        output.colon();\n        self.alternative.print(output);\n    });\n    DEFPRINT(AST_Await, function(output) {\n        output.print(\"await\");\n        output.space();\n        this.expression.print(output);\n    });\n\n    /* -----[ literals ]----- */\n    DEFPRINT(AST_Array, function(output) {\n        var a = this.elements, len = a.length;\n        output.with_square(len > 0 ? function() {\n            output.space();\n            a.forEach(function(exp, i) {\n                if (i) output.comma();\n                exp.print(output);\n                // If the final element is a hole, we need to make sure it\n                // doesn't look like a trailing comma, by inserting an actual\n                // trailing comma.\n                if (i === len - 1 && exp instanceof AST_Hole)\n                  output.comma();\n            });\n            output.space();\n        } : noop);\n    });\n    DEFPRINT(AST_DestructuredArray, function(output) {\n        var a = this.elements, len = a.length;\n        output.with_square(len > 0 ? function() {\n            output.space();\n            a.forEach(function(exp, i) {\n                if (i) output.comma();\n                exp.print(output);\n                // If the final element is a hole, we need to make sure it\n                // doesn't look like a trailing comma, by inserting an actual\n                // trailing comma.\n                if (i === len - 1 && exp instanceof AST_Hole)\n                  output.comma();\n            });\n            output.space();\n        } : noop);\n    });\n    DEFPRINT(AST_DestructuredKeyVal, print_key_value);\n    DEFPRINT(AST_DestructuredObject, function(output) {\n        var props = this.properties;\n        if (props.length > 0) output.with_block(function() {\n            props.forEach(function(prop, i) {\n                if (i) {\n                    output.print(\",\");\n                    output.newline();\n                }\n                output.indent();\n                prop.print(output);\n            });\n            output.newline();\n        });\n        else print_braced_empty(this, output);\n    });\n    DEFPRINT(AST_Object, function(output) {\n        var props = this.properties;\n        if (props.length > 0) output.with_block(function() {\n            props.forEach(function(prop, i) {\n                if (i) {\n                    output.print(\",\");\n                    output.newline();\n                }\n                output.indent();\n                prop.print(output);\n            });\n            output.newline();\n        });\n        else print_braced_empty(this, output);\n    });\n\n    function print_property_key(self, output) {\n        var key = self.key;\n        if (key instanceof AST_Node) {\n            output.with_square(function() {\n                key.print(output);\n            });\n        } else if (output.option(\"quote_keys\")) {\n            output.print_string(key);\n        } else if (\"\" + +key == key && key >= 0) {\n            output.print(make_num(key));\n        } else {\n            var quote = self.start && self.start.quote;\n            if (RESERVED_WORDS[key] ? !output.option(\"ie8\") : is_identifier_string(key)) {\n                if (quote && output.option(\"keep_quoted_props\")) {\n                    output.print_string(key, quote);\n                } else {\n                    output.print_name(key);\n                }\n            } else {\n                output.print_string(key, quote);\n            }\n        }\n    }\n\n    function print_key_value(output) {\n        var self = this;\n        print_property_key(self, output);\n        output.colon();\n        self.value.print(output);\n    }\n    DEFPRINT(AST_ObjectKeyVal, print_key_value);\n    function print_accessor(type) {\n        return function(output) {\n            var self = this;\n            output.print(type);\n            output.space();\n            print_property_key(self, output);\n            print_lambda(self.value, output);\n        };\n    }\n    DEFPRINT(AST_ObjectGetter, print_accessor(\"get\"));\n    DEFPRINT(AST_ObjectSetter, print_accessor(\"set\"));\n    DEFPRINT(AST_Symbol, function(output) {\n        var def = this.definition();\n        output.print_name(def && def.mangled_name || this.name);\n    });\n    DEFPRINT(AST_Hole, noop);\n    DEFPRINT(AST_This, function(output) {\n        output.print(\"this\");\n    });\n    DEFPRINT(AST_Constant, function(output) {\n        output.print(this.value);\n    });\n    DEFPRINT(AST_String, function(output) {\n        output.print_string(this.value, this.quote);\n    });\n    DEFPRINT(AST_Number, function(output) {\n        var start = this.start;\n        if (use_asm && start && start.raw != null) {\n            output.print(start.raw);\n        } else {\n            output.print(make_num(this.value));\n        }\n    });\n\n    DEFPRINT(AST_RegExp, function(output) {\n        var regexp = this.value;\n        var str = regexp.toString();\n        var end = str.lastIndexOf(\"/\");\n        if (regexp.raw_source) {\n            str = \"/\" + regexp.raw_source + str.slice(end);\n        } else if (end == 1) {\n            str = \"/(?:)\" + str.slice(end);\n        } else if (str.indexOf(\"/\", 1) < end) {\n            str = \"/\" + str.slice(1, end).replace(/\\\\\\\\|[^/]?\\//g, function(match) {\n                return match[0] == \"\\\\\" ? match : match.slice(0, -1) + \"\\\\/\";\n            }) + str.slice(end);\n        }\n        output.print(output.to_utf8(str).replace(/\\\\(?:\\0(?![0-9])|[^\\0])/g, function(match) {\n            switch (match[1]) {\n              case \"\\n\": return \"\\\\n\";\n              case \"\\r\": return \"\\\\r\";\n              case \"\\t\": return \"\\t\";\n              case \"\\b\": return \"\\b\";\n              case \"\\f\": return \"\\f\";\n              case \"\\0\": return \"\\0\";\n              case \"\\x0B\": return \"\\v\";\n              case \"\\u2028\": return \"\\\\u2028\";\n              case \"\\u2029\": return \"\\\\u2029\";\n              default: return match;\n            }\n        }).replace(/[\\n\\r\\u2028\\u2029]/g, function(c) {\n            switch (c) {\n              case \"\\n\": return \"\\\\n\";\n              case \"\\r\": return \"\\\\r\";\n              case \"\\u2028\": return \"\\\\u2028\";\n              case \"\\u2029\": return \"\\\\u2029\";\n            }\n        }));\n        var p = output.parent();\n        if (p instanceof AST_Binary && /^in/.test(p.operator) && p.left === this)\n            output.print(\" \");\n    });\n\n    function force_statement(stat, output) {\n        if (output.option(\"braces\") && !(stat instanceof AST_Const || stat instanceof AST_Let)) {\n            make_block(stat, output);\n        } else if (!stat || stat instanceof AST_EmptyStatement) {\n            output.force_semicolon();\n        } else {\n            stat.print(output);\n        }\n    }\n\n    // self should be AST_New.  decide if we want to show parens or not.\n    function need_constructor_parens(self, output) {\n        // Always print parentheses with arguments\n        if (self.args.length > 0) return true;\n\n        return output.option(\"beautify\");\n    }\n\n    function best_of(a) {\n        var best = a[0], len = best.length;\n        for (var i = 1; i < a.length; ++i) {\n            if (a[i].length < len) {\n                best = a[i];\n                len = best.length;\n            }\n        }\n        return best;\n    }\n\n    function make_num(num) {\n        var str = num.toString(10).replace(/^0\\./, \".\").replace(\"e+\", \"e\");\n        var candidates = [ str ];\n        if (Math.floor(num) === num) {\n            if (num < 0) {\n                candidates.push(\"-0x\" + (-num).toString(16).toLowerCase());\n            } else {\n                candidates.push(\"0x\" + num.toString(16).toLowerCase());\n            }\n        }\n        var match, len, digits;\n        if (match = /^\\.0+/.exec(str)) {\n            len = match[0].length;\n            digits = str.slice(len);\n            candidates.push(digits + \"e-\" + (digits.length + len - 1));\n        } else if (match = /0+$/.exec(str)) {\n            len = match[0].length;\n            candidates.push(str.slice(0, -len) + \"e\" + len);\n        } else if (match = /^(\\d)\\.(\\d+)e(-?\\d+)$/.exec(str)) {\n            candidates.push(match[1] + match[2] + \"e\" + (match[3] - match[2].length));\n        }\n        return best_of(candidates);\n    }\n\n    function make_block(stmt, output) {\n        if (!stmt || stmt instanceof AST_EmptyStatement)\n            output.print(\"{}\");\n        else if (stmt instanceof AST_BlockStatement)\n            stmt.print(output);\n        else output.with_block(function() {\n            output.indent();\n            stmt.print(output);\n            output.newline();\n        });\n    }\n\n    /* -----[ source map generators ]----- */\n\n    function DEFMAP(nodetype, generator) {\n        nodetype.forEach(function(nodetype) {\n            nodetype.DEFMETHOD(\"add_source_map\", generator);\n        });\n    }\n\n    DEFMAP([\n        // We could easily add info for ALL nodes, but it seems to me that\n        // would be quite wasteful, hence this noop in the base class.\n        AST_Node,\n        // since the label symbol will mark it\n        AST_LabeledStatement,\n    ], noop);\n\n    // XXX: I'm not exactly sure if we need it for all of these nodes,\n    // or if we should add even more.\n    DEFMAP([\n        AST_Array,\n        AST_BlockStatement,\n        AST_Catch,\n        AST_Constant,\n        AST_Debugger,\n        AST_Definitions,\n        AST_Destructured,\n        AST_Finally,\n        AST_Jump,\n        AST_Lambda,\n        AST_New,\n        AST_Object,\n        AST_StatementWithBody,\n        AST_Symbol,\n        AST_Switch,\n        AST_SwitchBranch,\n        AST_Try,\n    ], function(output) {\n        output.add_mapping(this.start);\n    });\n\n    DEFMAP([ AST_DestructuredKeyVal, AST_ObjectProperty ], function(output) {\n        if (typeof this.key == \"string\") output.add_mapping(this.start, this.key);\n    });\n})();\n","/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n    Parser based on parse-js (http://marijn.haverbeke.nl/parse-js/).\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\n\"use strict\";\n\nvar KEYWORDS = \"break case catch const continue debugger default delete do else finally for function if in instanceof let new return switch throw try typeof var void while with\";\nvar KEYWORDS_ATOM = \"false null true\";\nvar RESERVED_WORDS = [\n    \"await abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized this throws transient volatile yield\",\n    KEYWORDS_ATOM,\n    KEYWORDS,\n].join(\" \");\nvar KEYWORDS_BEFORE_EXPRESSION = \"return new delete throw else case\";\n\nKEYWORDS = makePredicate(KEYWORDS);\nRESERVED_WORDS = makePredicate(RESERVED_WORDS);\nKEYWORDS_BEFORE_EXPRESSION = makePredicate(KEYWORDS_BEFORE_EXPRESSION);\nKEYWORDS_ATOM = makePredicate(KEYWORDS_ATOM);\n\nvar RE_BIN_NUMBER = /^0b([01]+)$/i;\nvar RE_HEX_NUMBER = /^0x([0-9a-f]+)$/i;\nvar RE_OCT_NUMBER = /^0o?([0-7]+)$/i;\n\nvar OPERATORS = makePredicate([\n    \"in\",\n    \"instanceof\",\n    \"typeof\",\n    \"new\",\n    \"void\",\n    \"delete\",\n    \"++\",\n    \"--\",\n    \"+\",\n    \"-\",\n    \"!\",\n    \"~\",\n    \"&\",\n    \"|\",\n    \"^\",\n    \"*\",\n    \"/\",\n    \"%\",\n    \">>\",\n    \"<<\",\n    \">>>\",\n    \"<\",\n    \">\",\n    \"<=\",\n    \">=\",\n    \"==\",\n    \"===\",\n    \"!=\",\n    \"!==\",\n    \"?\",\n    \"=\",\n    \"+=\",\n    \"-=\",\n    \"/=\",\n    \"*=\",\n    \"%=\",\n    \">>=\",\n    \"<<=\",\n    \">>>=\",\n    \"|=\",\n    \"^=\",\n    \"&=\",\n    \"&&\",\n    \"||\"\n]);\n\nvar NEWLINE_CHARS = \"\\n\\r\\u2028\\u2029\";\nvar OPERATOR_CHARS = \"+-*&%=<>!?|~^\";\nvar PUNC_BEFORE_EXPRESSION = \"[{(,;:\";\nvar PUNC_CHARS = PUNC_BEFORE_EXPRESSION + \")}]\";\nvar WHITESPACE_CHARS = NEWLINE_CHARS + \" \\u00a0\\t\\f\\u000b\\u200b\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\uFEFF\";\nvar NON_IDENTIFIER_CHARS = makePredicate(characters(\"./'\\\"\" + OPERATOR_CHARS + PUNC_CHARS + WHITESPACE_CHARS));\n\nNEWLINE_CHARS = makePredicate(characters(NEWLINE_CHARS));\nOPERATOR_CHARS = makePredicate(characters(OPERATOR_CHARS));\nPUNC_BEFORE_EXPRESSION = makePredicate(characters(PUNC_BEFORE_EXPRESSION));\nPUNC_CHARS = makePredicate(characters(PUNC_CHARS));\nWHITESPACE_CHARS = makePredicate(characters(WHITESPACE_CHARS));\n\n/* -----[ Tokenizer ]----- */\n\nfunction is_surrogate_pair_head(code) {\n    return code >= 0xd800 && code <= 0xdbff;\n}\n\nfunction is_surrogate_pair_tail(code) {\n    return code >= 0xdc00 && code <= 0xdfff;\n}\n\nfunction is_digit(code) {\n    return code >= 48 && code <= 57;\n}\n\nfunction is_identifier_char(ch) {\n    return !NON_IDENTIFIER_CHARS[ch];\n}\n\nfunction is_identifier_string(str) {\n    return /^[a-z_$][a-z0-9_$]*$/i.test(str);\n}\n\nfunction parse_js_number(num) {\n    var match;\n    if (match = RE_BIN_NUMBER.exec(num)) return parseInt(match[1], 2);\n    if (match = RE_HEX_NUMBER.exec(num)) return parseInt(match[1], 16);\n    if (match = RE_OCT_NUMBER.exec(num)) return parseInt(match[1], 8);\n    var val = parseFloat(num);\n    if (val == num) return val;\n}\n\nfunction JS_Parse_Error(message, filename, line, col, pos) {\n    this.message = message;\n    this.filename = filename;\n    this.line = line;\n    this.col = col;\n    this.pos = pos;\n}\nJS_Parse_Error.prototype = Object.create(Error.prototype);\nJS_Parse_Error.prototype.constructor = JS_Parse_Error;\nJS_Parse_Error.prototype.name = \"SyntaxError\";\nconfigure_error_stack(JS_Parse_Error);\n\nfunction js_error(message, filename, line, col, pos) {\n    throw new JS_Parse_Error(message, filename, line, col, pos);\n}\n\nfunction is_token(token, type, val) {\n    return token.type == type && (val == null || token.value == val);\n}\n\nvar EX_EOF = {};\n\nfunction tokenizer($TEXT, filename, html5_comments, shebang) {\n\n    var S = {\n        text            : $TEXT,\n        filename        : filename,\n        pos             : 0,\n        tokpos          : 0,\n        line            : 1,\n        tokline         : 0,\n        col             : 0,\n        tokcol          : 0,\n        newline_before  : false,\n        regex_allowed   : false,\n        comments_before : [],\n        directives      : {},\n        directive_stack : []\n    };\n    var prev_was_dot = false;\n\n    function peek() {\n        return S.text.charAt(S.pos);\n    }\n\n    function next(signal_eof, in_string) {\n        var ch = S.text.charAt(S.pos++);\n        if (signal_eof && !ch)\n            throw EX_EOF;\n        if (NEWLINE_CHARS[ch]) {\n            S.col = 0;\n            S.line++;\n            if (!in_string) S.newline_before = true;\n            if (ch == \"\\r\" && peek() == \"\\n\") {\n                // treat `\\r\\n` as `\\n`\n                S.pos++;\n                ch = \"\\n\";\n            }\n        } else {\n            S.col++;\n        }\n        return ch;\n    }\n\n    function forward(i) {\n        while (i-- > 0) next();\n    }\n\n    function looking_at(str) {\n        return S.text.substr(S.pos, str.length) == str;\n    }\n\n    function find_eol() {\n        var text = S.text;\n        for (var i = S.pos; i < S.text.length; ++i) {\n            if (NEWLINE_CHARS[text[i]]) return i;\n        }\n        return -1;\n    }\n\n    function find(what, signal_eof) {\n        var pos = S.text.indexOf(what, S.pos);\n        if (signal_eof && pos == -1) throw EX_EOF;\n        return pos;\n    }\n\n    function start_token() {\n        S.tokline = S.line;\n        S.tokcol = S.col;\n        S.tokpos = S.pos;\n    }\n\n    function token(type, value, is_comment) {\n        S.regex_allowed = type == \"operator\" && !UNARY_POSTFIX[value]\n            || type == \"keyword\" && KEYWORDS_BEFORE_EXPRESSION[value]\n            || type == \"punc\" && PUNC_BEFORE_EXPRESSION[value];\n        if (type == \"punc\" && value == \".\") prev_was_dot = true;\n        else if (!is_comment) prev_was_dot = false;\n        var ret = {\n            type    : type,\n            value   : value,\n            line    : S.tokline,\n            col     : S.tokcol,\n            pos     : S.tokpos,\n            endline : S.line,\n            endcol  : S.col,\n            endpos  : S.pos,\n            nlb     : S.newline_before,\n            file    : filename\n        };\n        if (/^(?:num|string|regexp)$/i.test(type)) {\n            ret.raw = $TEXT.substring(ret.pos, ret.endpos);\n        }\n        if (!is_comment) {\n            ret.comments_before = S.comments_before;\n            ret.comments_after = S.comments_before = [];\n        }\n        S.newline_before = false;\n        return new AST_Token(ret);\n    }\n\n    function skip_whitespace() {\n        while (WHITESPACE_CHARS[peek()])\n            next();\n    }\n\n    function read_while(pred) {\n        var ret = \"\", ch, i = 0;\n        while ((ch = peek()) && pred(ch, i++))\n            ret += next();\n        return ret;\n    }\n\n    function parse_error(err) {\n        js_error(err, filename, S.tokline, S.tokcol, S.tokpos);\n    }\n\n    function read_num(prefix) {\n        var has_e = false, after_e = false, has_x = false, has_dot = prefix == \".\";\n        var num = read_while(function(ch, i) {\n            var code = ch.charCodeAt(0);\n            switch (code) {\n              case 120: case 88: // xX\n                return has_x ? false : (has_x = true);\n              case 101: case 69: // eE\n                return has_x ? true : has_e ? false : (has_e = after_e = true);\n              case 45: // -\n                return after_e || (i == 0 && !prefix);\n              case 43: // +\n                return after_e;\n              case (after_e = false, 46): // .\n                return (!has_dot && !has_x && !has_e) ? (has_dot = true) : false;\n            }\n            return is_digit(code) || /[_0-9a-fo]/i.test(ch);\n        });\n        if (prefix) num = prefix + num;\n        if (/^0[0-7_]+$/.test(num)) {\n            if (next_token.has_directive(\"use strict\")) parse_error(\"Legacy octal literals are not allowed in strict mode\");\n        } else {\n            num = num.replace(has_x ? /([1-9a-f]|.0)_(?=[0-9a-f])/gi : /([1-9]|.0)_(?=[0-9])/gi, \"$1\");\n        }\n        var valid = parse_js_number(num);\n        if (!isNaN(valid)) return token(\"num\", valid);\n        parse_error(\"Invalid syntax: \" + num);\n    }\n\n    function read_escaped_char(in_string) {\n        var ch = next(true, in_string);\n        switch (ch.charCodeAt(0)) {\n          case 110: return \"\\n\";\n          case 114: return \"\\r\";\n          case 116: return \"\\t\";\n          case 98:  return \"\\b\";\n          case 118: return \"\\u000b\";                            // \\v\n          case 102: return \"\\f\";\n          case 120: return String.fromCharCode(hex_bytes(2));   // \\x\n          case 117:                                             // \\u\n            if (peek() != \"{\") return String.fromCharCode(hex_bytes(4));\n            next();\n            var num = 0;\n            do {\n                var digit = parseInt(next(true), 16);\n                if (isNaN(digit)) parse_error(\"Invalid hex-character pattern in string\");\n                num = num * 16 + digit;\n            } while (peek() != \"}\");\n            next();\n            if (num < 0x10000) return String.fromCharCode(num);\n            if (num > 0x10ffff) parse_error(\"Invalid character code: \" + num);\n            return String.fromCharCode((num >> 10) + 0xd7c0) + String.fromCharCode((num & 0x03ff) + 0xdc00);\n          case 13:                                              // \\r\n            // DOS newline\n            if (peek() == \"\\n\") next(true, in_string);\n          case 10:  return \"\";                                  // \\n\n        }\n        if (ch >= \"0\" && ch <= \"7\")\n            return read_octal_escape_sequence(ch);\n        return ch;\n    }\n\n    function read_octal_escape_sequence(ch) {\n        // Read\n        var p = peek();\n        if (p >= \"0\" && p <= \"7\") {\n            ch += next(true);\n            if (ch[0] <= \"3\" && (p = peek()) >= \"0\" && p <= \"7\")\n                ch += next(true);\n        }\n\n        // Parse\n        if (ch === \"0\") return \"\\0\";\n        if (ch.length > 0 && next_token.has_directive(\"use strict\"))\n            parse_error(\"Legacy octal escape sequences are not allowed in strict mode\");\n        return String.fromCharCode(parseInt(ch, 8));\n    }\n\n    function hex_bytes(n) {\n        var num = 0;\n        for (; n > 0; --n) {\n            var digit = parseInt(next(true), 16);\n            if (isNaN(digit))\n                parse_error(\"Invalid hex-character pattern in string\");\n            num = (num << 4) | digit;\n        }\n        return num;\n    }\n\n    var read_string = with_eof_error(\"Unterminated string constant\", function(quote_char) {\n        var quote = next(), ret = \"\";\n        for (;;) {\n            var ch = next(true, true);\n            if (ch == \"\\\\\") ch = read_escaped_char(true);\n            else if (NEWLINE_CHARS[ch]) parse_error(\"Unterminated string constant\");\n            else if (ch == quote) break;\n            ret += ch;\n        }\n        var tok = token(\"string\", ret);\n        tok.quote = quote_char;\n        return tok;\n    });\n\n    function skip_line_comment(type) {\n        var regex_allowed = S.regex_allowed;\n        var i = find_eol(), ret;\n        if (i == -1) {\n            ret = S.text.substr(S.pos);\n            S.pos = S.text.length;\n        } else {\n            ret = S.text.substring(S.pos, i);\n            S.pos = i;\n        }\n        S.col = S.tokcol + (S.pos - S.tokpos);\n        S.comments_before.push(token(type, ret, true));\n        S.regex_allowed = regex_allowed;\n        return next_token;\n    }\n\n    var skip_multiline_comment = with_eof_error(\"Unterminated multiline comment\", function() {\n        var regex_allowed = S.regex_allowed;\n        var i = find(\"*/\", true);\n        var text = S.text.substring(S.pos, i).replace(/\\r\\n|\\r|\\u2028|\\u2029/g, \"\\n\");\n        // update stream position\n        forward(text.length /* doesn't count \\r\\n as 2 char while S.pos - i does */ + 2);\n        S.comments_before.push(token(\"comment2\", text, true));\n        S.regex_allowed = regex_allowed;\n        return next_token;\n    });\n\n    function read_name() {\n        var backslash = false, name = \"\", ch, escaped = false, hex;\n        while (ch = peek()) {\n            if (!backslash) {\n                if (ch == \"\\\\\") escaped = backslash = true, next();\n                else if (is_identifier_char(ch)) name += next();\n                else break;\n            } else {\n                if (ch != \"u\") parse_error(\"Expecting UnicodeEscapeSequence -- uXXXX\");\n                ch = read_escaped_char();\n                if (!is_identifier_char(ch)) parse_error(\"Unicode char: \" + ch.charCodeAt(0) + \" is not valid in identifier\");\n                name += ch;\n                backslash = false;\n            }\n        }\n        if (KEYWORDS[name] && escaped) {\n            hex = name.charCodeAt(0).toString(16).toUpperCase();\n            name = \"\\\\u\" + \"0000\".substr(hex.length) + hex + name.slice(1);\n        }\n        return name;\n    }\n\n    var read_regexp = with_eof_error(\"Unterminated regular expression\", function(source) {\n        var prev_backslash = false, ch, in_class = false;\n        while ((ch = next(true))) if (NEWLINE_CHARS[ch]) {\n            parse_error(\"Unexpected line terminator\");\n        } else if (prev_backslash) {\n            source += \"\\\\\" + ch;\n            prev_backslash = false;\n        } else if (ch == \"[\") {\n            in_class = true;\n            source += ch;\n        } else if (ch == \"]\" && in_class) {\n            in_class = false;\n            source += ch;\n        } else if (ch == \"/\" && !in_class) {\n            break;\n        } else if (ch == \"\\\\\") {\n            prev_backslash = true;\n        } else {\n            source += ch;\n        }\n        var mods = read_name();\n        try {\n            var regexp = new RegExp(source, mods);\n            regexp.raw_source = source;\n            return token(\"regexp\", regexp);\n        } catch (e) {\n            parse_error(e.message);\n        }\n    });\n\n    function read_operator(prefix) {\n        function grow(op) {\n            if (!peek()) return op;\n            var bigger = op + peek();\n            if (OPERATORS[bigger]) {\n                next();\n                return grow(bigger);\n            } else {\n                return op;\n            }\n        }\n        return token(\"operator\", grow(prefix || next()));\n    }\n\n    function handle_slash() {\n        next();\n        switch (peek()) {\n          case \"/\":\n            next();\n            return skip_line_comment(\"comment1\");\n          case \"*\":\n            next();\n            return skip_multiline_comment();\n        }\n        return S.regex_allowed ? read_regexp(\"\") : read_operator(\"/\");\n    }\n\n    function handle_dot() {\n        next();\n        var ch = peek();\n        if (ch == \".\") {\n            var op = \".\";\n            do {\n                op += \".\";\n                next();\n            } while (peek() == \".\");\n            return token(\"operator\", op);\n        }\n        return is_digit(ch.charCodeAt(0)) ? read_num(\".\") : token(\"punc\", \".\");\n    }\n\n    function read_word() {\n        var word = read_name();\n        if (prev_was_dot) return token(\"name\", word);\n        return KEYWORDS_ATOM[word] ? token(\"atom\", word)\n            : !KEYWORDS[word] ? token(\"name\", word)\n            : OPERATORS[word] ? token(\"operator\", word)\n            : token(\"keyword\", word);\n    }\n\n    function with_eof_error(eof_error, cont) {\n        return function(x) {\n            try {\n                return cont(x);\n            } catch (ex) {\n                if (ex === EX_EOF) parse_error(eof_error);\n                else throw ex;\n            }\n        };\n    }\n\n    function next_token(force_regexp) {\n        if (force_regexp != null)\n            return read_regexp(force_regexp);\n        if (shebang && S.pos == 0 && looking_at(\"#!\")) {\n            start_token();\n            forward(2);\n            skip_line_comment(\"comment5\");\n        }\n        for (;;) {\n            skip_whitespace();\n            start_token();\n            if (html5_comments) {\n                if (looking_at(\"<!--\")) {\n                    forward(4);\n                    skip_line_comment(\"comment3\");\n                    continue;\n                }\n                if (looking_at(\"-->\") && S.newline_before) {\n                    forward(3);\n                    skip_line_comment(\"comment4\");\n                    continue;\n                }\n            }\n            var ch = peek();\n            if (!ch) return token(\"eof\");\n            var code = ch.charCodeAt(0);\n            switch (code) {\n              case 34: case 39: return read_string(ch);\n              case 46: return handle_dot();\n              case 47:\n                var tok = handle_slash();\n                if (tok === next_token) continue;\n                return tok;\n            }\n            if (is_digit(code)) return read_num();\n            if (PUNC_CHARS[ch]) return token(\"punc\", next());\n            if (looking_at(\"=>\")) return token(\"punc\", next() + next());\n            if (OPERATOR_CHARS[ch]) return read_operator();\n            if (code == 92 || !NON_IDENTIFIER_CHARS[ch]) return read_word();\n            break;\n        }\n        parse_error(\"Unexpected character '\" + ch + \"'\");\n    }\n\n    next_token.context = function(nc) {\n        if (nc) S = nc;\n        return S;\n    };\n\n    next_token.add_directive = function(directive) {\n        S.directive_stack[S.directive_stack.length - 1].push(directive);\n        if (S.directives[directive]) S.directives[directive]++;\n        else S.directives[directive] = 1;\n    }\n\n    next_token.push_directives_stack = function() {\n        S.directive_stack.push([]);\n    }\n\n    next_token.pop_directives_stack = function() {\n        var directives = S.directive_stack.pop();\n        for (var i = directives.length; --i >= 0;) {\n            S.directives[directives[i]]--;\n        }\n    }\n\n    next_token.has_directive = function(directive) {\n        return S.directives[directive] > 0;\n    }\n\n    return next_token;\n}\n\n/* -----[ Parser (constants) ]----- */\n\nvar UNARY_PREFIX = makePredicate(\"typeof void delete -- ++ ! ~ - +\");\n\nvar UNARY_POSTFIX = makePredicate(\"-- ++\");\n\nvar ASSIGNMENT = makePredicate(\"= += -= /= *= %= >>= <<= >>>= |= ^= &=\");\n\nvar PRECEDENCE = function(a, ret) {\n    for (var i = 0; i < a.length;) {\n        var b = a[i++];\n        for (var j = 0; j < b.length; j++) {\n            ret[b[j]] = i;\n        }\n    }\n    return ret;\n}([\n    [\"||\"],\n    [\"&&\"],\n    [\"|\"],\n    [\"^\"],\n    [\"&\"],\n    [\"==\", \"===\", \"!=\", \"!==\"],\n    [\"<\", \">\", \"<=\", \">=\", \"in\", \"instanceof\"],\n    [\">>\", \"<<\", \">>>\"],\n    [\"+\", \"-\"],\n    [\"*\", \"/\", \"%\"]\n], {});\n\nvar ATOMIC_START_TOKEN = makePredicate(\"atom num regexp string\");\n\n/* -----[ Parser ]----- */\n\nfunction parse($TEXT, options) {\n    options = defaults(options, {\n        bare_returns   : false,\n        expression     : false,\n        filename       : null,\n        html5_comments : true,\n        shebang        : true,\n        strict         : false,\n        toplevel       : null,\n    }, true);\n\n    var S = {\n        input         : typeof $TEXT == \"string\"\n                        ? tokenizer($TEXT, options.filename, options.html5_comments, options.shebang)\n                        : $TEXT,\n        in_async      : false,\n        in_directives : true,\n        in_funarg     : -1,\n        in_function   : 0,\n        in_loop       : 0,\n        labels        : [],\n        peeked        : null,\n        prev          : null,\n        token         : null,\n    };\n\n    S.token = next();\n\n    function is(type, value) {\n        return is_token(S.token, type, value);\n    }\n\n    function peek() {\n        return S.peeked || (S.peeked = S.input());\n    }\n\n    function next() {\n        S.prev = S.token;\n        if (S.peeked) {\n            S.token = S.peeked;\n            S.peeked = null;\n        } else {\n            S.token = S.input();\n        }\n        S.in_directives = S.in_directives && (\n            S.token.type == \"string\" || is(\"punc\", \";\")\n        );\n        return S.token;\n    }\n\n    function prev() {\n        return S.prev;\n    }\n\n    function croak(msg, line, col, pos) {\n        var ctx = S.input.context();\n        js_error(msg,\n                 ctx.filename,\n                 line != null ? line : ctx.tokline,\n                 col != null ? col : ctx.tokcol,\n                 pos != null ? pos : ctx.tokpos);\n    }\n\n    function token_error(token, msg) {\n        croak(msg, token.line, token.col);\n    }\n\n    function token_to_string(type, value) {\n        return type + (value === undefined ? \"\" : \" «\" + value + \"»\");\n    }\n\n    function unexpected(token) {\n        if (token == null) token = S.token;\n        token_error(token, \"Unexpected token: \" + token_to_string(token.type, token.value));\n    }\n\n    function expect_token(type, val) {\n        if (is(type, val)) return next();\n        token_error(S.token, \"Unexpected token: \" + token_to_string(S.token.type, S.token.value) + \", expected: \" + token_to_string(type, val));\n    }\n\n    function expect(punc) {\n        return expect_token(\"punc\", punc);\n    }\n\n    function has_newline_before(token) {\n        return token.nlb || !all(token.comments_before, function(comment) {\n            return !comment.nlb;\n        });\n    }\n\n    function can_insert_semicolon() {\n        return !options.strict\n            && (is(\"eof\") || is(\"punc\", \"}\") || has_newline_before(S.token));\n    }\n\n    function semicolon(optional) {\n        if (is(\"punc\", \";\")) next();\n        else if (!optional && !can_insert_semicolon()) expect(\";\");\n    }\n\n    function parenthesised() {\n        expect(\"(\");\n        var exp = expression();\n        expect(\")\");\n        return exp;\n    }\n\n    function embed_tokens(parser) {\n        return function() {\n            var start = S.token;\n            var expr = parser.apply(null, arguments);\n            var end = prev();\n            expr.start = start;\n            expr.end = end;\n            return expr;\n        };\n    }\n\n    function handle_regexp() {\n        if (is(\"operator\", \"/\") || is(\"operator\", \"/=\")) {\n            S.peeked = null;\n            S.token = S.input(S.token.value.substr(1)); // force regexp\n        }\n    }\n\n    var statement = embed_tokens(function() {\n        handle_regexp();\n        switch (S.token.type) {\n          case \"string\":\n            var dir = S.in_directives;\n            var body = expression();\n            if (dir) {\n                if (body instanceof AST_String) {\n                    var value = body.start.raw.slice(1, -1);\n                    S.input.add_directive(value);\n                    body.value = value;\n                } else {\n                    S.in_directives = dir = false;\n                }\n            }\n            semicolon();\n            return dir ? new AST_Directive(body) : new AST_SimpleStatement({ body: body });\n          case \"num\":\n          case \"regexp\":\n          case \"operator\":\n          case \"atom\":\n            return simple_statement();\n\n          case \"name\":\n            switch (S.token.value) {\n              case \"async\":\n                if (is_token(peek(), \"keyword\", \"function\")) {\n                    next();\n                    next();\n                    return function_(AST_AsyncDefun);\n                }\n              case \"await\":\n                if (S.in_async) return simple_statement();\n              default:\n                return is_token(peek(), \"punc\", \":\")\n                    ? labeled_statement()\n                    : simple_statement();\n            }\n\n          case \"punc\":\n            switch (S.token.value) {\n              case \"{\":\n                return new AST_BlockStatement({\n                    start : S.token,\n                    body  : block_(),\n                    end   : prev()\n                });\n              case \"[\":\n              case \"(\":\n                return simple_statement();\n              case \";\":\n                S.in_directives = false;\n                next();\n                return new AST_EmptyStatement();\n              default:\n                unexpected();\n            }\n\n          case \"keyword\":\n            switch (S.token.value) {\n              case \"break\":\n                next();\n                return break_cont(AST_Break);\n\n              case \"const\":\n                next();\n                var node = const_();\n                semicolon();\n                return node;\n\n              case \"continue\":\n                next();\n                return break_cont(AST_Continue);\n\n              case \"debugger\":\n                next();\n                semicolon();\n                return new AST_Debugger();\n\n              case \"do\":\n                next();\n                var body = in_loop(statement);\n                expect_token(\"keyword\", \"while\");\n                var condition = parenthesised();\n                semicolon(true);\n                return new AST_Do({\n                    body      : body,\n                    condition : condition\n                });\n\n              case \"while\":\n                next();\n                return new AST_While({\n                    condition : parenthesised(),\n                    body      : in_loop(statement)\n                });\n\n              case \"for\":\n                next();\n                return for_();\n\n              case \"function\":\n                next();\n                return function_(AST_Defun);\n\n              case \"if\":\n                next();\n                return if_();\n\n              case \"let\":\n                next();\n                var node = let_();\n                semicolon();\n                return node;\n\n              case \"return\":\n                if (S.in_function == 0 && !options.bare_returns)\n                    croak(\"'return' outside of function\");\n                next();\n                var value = null;\n                if (is(\"punc\", \";\")) {\n                    next();\n                } else if (!can_insert_semicolon()) {\n                    value = expression();\n                    semicolon();\n                }\n                return new AST_Return({\n                    value: value\n                });\n\n              case \"switch\":\n                next();\n                return new AST_Switch({\n                    expression : parenthesised(),\n                    body       : in_loop(switch_body_)\n                });\n\n              case \"throw\":\n                next();\n                if (has_newline_before(S.token))\n                    croak(\"Illegal newline after 'throw'\");\n                var value = expression();\n                semicolon();\n                return new AST_Throw({\n                    value: value\n                });\n\n              case \"try\":\n                next();\n                return try_();\n\n              case \"var\":\n                next();\n                var node = var_();\n                semicolon();\n                return node;\n\n              case \"with\":\n                if (S.input.has_directive(\"use strict\")) {\n                    croak(\"Strict mode may not include a with statement\");\n                }\n                next();\n                return new AST_With({\n                    expression : parenthesised(),\n                    body       : statement()\n                });\n            }\n        }\n        unexpected();\n    });\n\n    function labeled_statement() {\n        var label = as_symbol(AST_Label);\n        if (!all(S.labels, function(l) {\n            return l.name != label.name;\n        })) {\n            // ECMA-262, 12.12: An ECMAScript program is considered\n            // syntactically incorrect if it contains a\n            // LabelledStatement that is enclosed by a\n            // LabelledStatement with the same Identifier as label.\n            croak(\"Label \" + label.name + \" defined twice\");\n        }\n        expect(\":\");\n        S.labels.push(label);\n        var stat = statement();\n        S.labels.pop();\n        if (!(stat instanceof AST_IterationStatement)) {\n            // check for `continue` that refers to this label.\n            // those should be reported as syntax errors.\n            // https://github.com/mishoo/UglifyJS/issues/287\n            label.references.forEach(function(ref) {\n                if (ref instanceof AST_Continue) {\n                    token_error(ref.label.start, \"Continue label `\" + label.name + \"` must refer to IterationStatement\");\n                }\n            });\n        }\n        return new AST_LabeledStatement({ body: stat, label: label });\n    }\n\n    function simple_statement() {\n        var body = expression();\n        semicolon();\n        return new AST_SimpleStatement({ body: body });\n    }\n\n    function break_cont(type) {\n        var label = null, ldef;\n        if (!can_insert_semicolon()) {\n            label = as_symbol(AST_LabelRef, true);\n        }\n        if (label != null) {\n            ldef = find_if(function(l) {\n                return l.name == label.name;\n            }, S.labels);\n            if (!ldef) token_error(label.start, \"Undefined label \" + label.name);\n            label.thedef = ldef;\n        } else if (S.in_loop == 0) croak(type.TYPE + \" not inside a loop or switch\");\n        semicolon();\n        var stat = new type({ label: label });\n        if (ldef) ldef.references.push(stat);\n        return stat;\n    }\n\n    function for_() {\n        expect(\"(\");\n        var init = null;\n        if (!is(\"punc\", \";\")) {\n            init = is(\"keyword\", \"const\")\n                ? (next(), const_(true))\n                : is(\"keyword\", \"let\")\n                ? (next(), let_(true))\n                : is(\"keyword\", \"var\")\n                ? (next(), var_(true))\n                : expression(true);\n            if (is(\"operator\", \"in\")) {\n                if (init instanceof AST_Definitions) {\n                    if (init.definitions.length > 1) {\n                        token_error(init.start, \"Only one variable declaration allowed in for..in loop\");\n                    }\n                } else if (!(is_assignable(init) || (init = to_destructured(init)) instanceof AST_Destructured)) {\n                    token_error(init.start, \"Invalid left-hand side in for..in loop\");\n                }\n                next();\n                return for_in(init);\n            }\n        }\n        return regular_for(init);\n    }\n\n    function regular_for(init) {\n        expect(\";\");\n        var test = is(\"punc\", \";\") ? null : expression();\n        expect(\";\");\n        var step = is(\"punc\", \")\") ? null : expression();\n        expect(\")\");\n        return new AST_For({\n            init      : init,\n            condition : test,\n            step      : step,\n            body      : in_loop(statement)\n        });\n    }\n\n    function for_in(init) {\n        var obj = expression();\n        expect(\")\");\n        return new AST_ForIn({\n            init   : init,\n            object : obj,\n            body   : in_loop(statement)\n        });\n    }\n\n    function to_funarg(node) {\n        if (node instanceof AST_Array) return new AST_DestructuredArray({\n            start: node.start,\n            elements: node.elements.map(to_funarg),\n            end: node.end,\n        });\n        if (node instanceof AST_Assign) return new AST_DefaultValue({\n            start: node.start,\n            name: to_funarg(node.left),\n            value: node.right,\n            end: node.end,\n        });\n        if (node instanceof AST_DefaultValue) {\n            node.name = to_funarg(node.name);\n            return node;\n        }\n        if (node instanceof AST_DestructuredArray) {\n            node.elements = node.elements.map(to_funarg);\n            return node;\n        }\n        if (node instanceof AST_DestructuredObject) {\n            node.properties.forEach(function(prop) {\n                prop.value = to_funarg(prop.value);\n            });\n            return node;\n        }\n        if (node instanceof AST_Hole) return node;\n        if (node instanceof AST_Object) return new AST_DestructuredObject({\n            start: node.start,\n            properties: node.properties.map(function(prop) {\n                if (!(prop instanceof AST_ObjectKeyVal)) token_error(prop.start, \"Invalid destructuring assignment\");\n                return new AST_DestructuredKeyVal({\n                    start: prop.start,\n                    key: prop.key,\n                    value: to_funarg(prop.value),\n                    end: prop.end,\n                });\n            }),\n            end: node.end,\n        });\n        if (node instanceof AST_SymbolRef) return new AST_SymbolFunarg(node);\n        token_error(node.start, \"Invalid arrow parameter\");\n    }\n\n    function arrow(exprs, start) {\n        var was_async = S.in_async;\n        S.in_async = false;\n        var was_funarg = S.in_funarg;\n        S.in_funarg = S.in_function;\n        var argnames = exprs.map(to_funarg);\n        S.in_funarg = was_funarg;\n        expect(\"=>\");\n        var body, value;\n        var loop = S.in_loop;\n        var labels = S.labels;\n        ++S.in_function;\n        S.in_directives = true;\n        S.input.push_directives_stack();\n        S.in_loop = 0;\n        S.labels = [];\n        if (is(\"punc\", \"{\")) {\n            body = block_();\n            value = null;\n            if (S.input.has_directive(\"use strict\")) {\n                argnames.forEach(strict_verify_symbol);\n            }\n        } else {\n            body = [];\n            value = maybe_assign();\n        }\n        S.input.pop_directives_stack();\n        --S.in_function;\n        S.in_loop = loop;\n        S.labels = labels;\n        S.in_async = was_async;\n        return new AST_Arrow({\n            start: start,\n            argnames: argnames,\n            body: body,\n            value: value,\n            end: prev(),\n        });\n    }\n\n    var function_ = function(ctor) {\n        var was_async = S.in_async;\n        var name;\n        if (ctor === AST_AsyncDefun) {\n            name = as_symbol(AST_SymbolDefun);\n            S.in_async = true;\n        } else if (ctor === AST_Defun) {\n            name = as_symbol(AST_SymbolDefun);\n            S.in_async = false;\n        } else {\n            S.in_async = ctor === AST_AsyncFunction;\n            name = as_symbol(AST_SymbolLambda, true);\n        }\n        if (name && ctor !== AST_Accessor && !(name instanceof AST_SymbolDeclaration))\n            unexpected(prev());\n        expect(\"(\");\n        var was_funarg = S.in_funarg;\n        S.in_funarg = S.in_function;\n        var argnames = expr_list(\")\", !options.strict, false, function() {\n            return maybe_default(AST_SymbolFunarg);\n        });\n        S.in_funarg = was_funarg;\n        var loop = S.in_loop;\n        var labels = S.labels;\n        ++S.in_function;\n        S.in_directives = true;\n        S.input.push_directives_stack();\n        S.in_loop = 0;\n        S.labels = [];\n        var body = block_();\n        if (S.input.has_directive(\"use strict\")) {\n            if (name) strict_verify_symbol(name);\n            argnames.forEach(strict_verify_symbol);\n        }\n        S.input.pop_directives_stack();\n        --S.in_function;\n        S.in_loop = loop;\n        S.labels = labels;\n        S.in_async = was_async;\n        return new ctor({\n            name: name,\n            argnames: argnames,\n            body: body\n        });\n    };\n\n    function if_() {\n        var cond = parenthesised(), body = statement(), belse = null;\n        if (is(\"keyword\", \"else\")) {\n            next();\n            belse = statement();\n        }\n        return new AST_If({\n            condition   : cond,\n            body        : body,\n            alternative : belse\n        });\n    }\n\n    function block_() {\n        expect(\"{\");\n        var a = [];\n        while (!is(\"punc\", \"}\")) {\n            if (is(\"eof\")) expect(\"}\");\n            a.push(statement());\n        }\n        next();\n        return a;\n    }\n\n    function switch_body_() {\n        expect(\"{\");\n        var a = [], branch, cur, default_branch, tmp;\n        while (!is(\"punc\", \"}\")) {\n            if (is(\"eof\")) expect(\"}\");\n            if (is(\"keyword\", \"case\")) {\n                if (branch) branch.end = prev();\n                cur = [];\n                branch = new AST_Case({\n                    start      : (tmp = S.token, next(), tmp),\n                    expression : expression(),\n                    body       : cur\n                });\n                a.push(branch);\n                expect(\":\");\n            } else if (is(\"keyword\", \"default\")) {\n                if (branch) branch.end = prev();\n                if (default_branch) croak(\"More than one default clause in switch statement\");\n                cur = [];\n                branch = new AST_Default({\n                    start : (tmp = S.token, next(), expect(\":\"), tmp),\n                    body  : cur\n                });\n                a.push(branch);\n                default_branch = branch;\n            } else {\n                if (!cur) unexpected();\n                cur.push(statement());\n            }\n        }\n        if (branch) branch.end = prev();\n        next();\n        return a;\n    }\n\n    function try_() {\n        var body = block_(), bcatch = null, bfinally = null;\n        if (is(\"keyword\", \"catch\")) {\n            var start = S.token;\n            next();\n            var name = null;\n            if (is(\"punc\", \"(\")) {\n                next();\n                name = maybe_destructured(AST_SymbolCatch);\n                expect(\")\");\n            }\n            bcatch = new AST_Catch({\n                start   : start,\n                argname : name,\n                body    : block_(),\n                end     : prev()\n            });\n        }\n        if (is(\"keyword\", \"finally\")) {\n            var start = S.token;\n            next();\n            bfinally = new AST_Finally({\n                start : start,\n                body  : block_(),\n                end   : prev()\n            });\n        }\n        if (!bcatch && !bfinally)\n            croak(\"Missing catch/finally blocks\");\n        return new AST_Try({\n            body     : body,\n            bcatch   : bcatch,\n            bfinally : bfinally\n        });\n    }\n\n    function vardefs(type, no_in) {\n        var a = [];\n        for (;;) {\n            var start = S.token;\n            var name = maybe_destructured(type);\n            var value = null;\n            if (is(\"operator\", \"=\")) {\n                next();\n                value = maybe_assign(no_in);\n            } else if (!no_in && (type === AST_SymbolConst || name instanceof AST_Destructured)) {\n                croak(\"Missing initializer in declaration\");\n            }\n            a.push(new AST_VarDef({\n                start : start,\n                name  : name,\n                value : value,\n                end   : prev()\n            }));\n            if (!is(\"punc\", \",\"))\n                break;\n            next();\n        }\n        return a;\n    }\n\n    var const_ = function(no_in) {\n        return new AST_Const({\n            start       : prev(),\n            definitions : vardefs(AST_SymbolConst, no_in),\n            end         : prev()\n        });\n    };\n\n    var let_ = function(no_in) {\n        return new AST_Let({\n            start       : prev(),\n            definitions : vardefs(AST_SymbolLet, no_in),\n            end         : prev()\n        });\n    };\n\n    var var_ = function(no_in) {\n        return new AST_Var({\n            start       : prev(),\n            definitions : vardefs(AST_SymbolVar, no_in),\n            end         : prev()\n        });\n    };\n\n    var new_ = function(allow_calls) {\n        var start = S.token;\n        expect_token(\"operator\", \"new\");\n        var newexp = expr_atom(false), args;\n        if (is(\"punc\", \"(\")) {\n            next();\n            args = expr_list(\")\", !options.strict);\n        } else {\n            args = [];\n        }\n        var call = new AST_New({\n            start      : start,\n            expression : newexp,\n            args       : args,\n            end        : prev()\n        });\n        mark_pure(call);\n        return subscripts(call, allow_calls);\n    };\n\n    function as_atom_node() {\n        var tok = S.token, ret;\n        switch (tok.type) {\n          case \"num\":\n            ret = new AST_Number({ start: tok, end: tok, value: tok.value });\n            break;\n          case \"string\":\n            ret = new AST_String({\n                start : tok,\n                end   : tok,\n                value : tok.value,\n                quote : tok.quote\n            });\n            break;\n          case \"regexp\":\n            ret = new AST_RegExp({ start: tok, end: tok, value: tok.value });\n            break;\n          case \"atom\":\n            switch (tok.value) {\n              case \"false\":\n                ret = new AST_False({ start: tok, end: tok });\n                break;\n              case \"true\":\n                ret = new AST_True({ start: tok, end: tok });\n                break;\n              case \"null\":\n                ret = new AST_Null({ start: tok, end: tok });\n                break;\n            }\n            break;\n        }\n        next();\n        return ret;\n    }\n\n    var expr_atom = function(allow_calls) {\n        if (is(\"operator\", \"new\")) {\n            return new_(allow_calls);\n        }\n        var start = S.token;\n        if (is(\"punc\")) {\n            switch (start.value) {\n              case \"(\":\n                next();\n                if (is(\"punc\", \")\")) {\n                    next();\n                    return arrow([], start);\n                }\n                var ex = expression(false, true);\n                var len = start.comments_before.length;\n                [].unshift.apply(ex.start.comments_before, start.comments_before);\n                start.comments_before.length = 0;\n                start.comments_before = ex.start.comments_before;\n                start.comments_before_length = len;\n                if (len == 0 && start.comments_before.length > 0) {\n                    var comment = start.comments_before[0];\n                    if (!comment.nlb) {\n                        comment.nlb = start.nlb;\n                        start.nlb = false;\n                    }\n                }\n                start.comments_after = ex.start.comments_after;\n                ex.start = start;\n                expect(\")\");\n                var end = prev();\n                end.comments_before = ex.end.comments_before;\n                [].push.apply(ex.end.comments_after, end.comments_after);\n                end.comments_after.length = 0;\n                end.comments_after = ex.end.comments_after;\n                ex.end = end;\n                if (ex instanceof AST_Call) mark_pure(ex);\n                if (is(\"punc\", \"=>\")) return arrow(ex instanceof AST_Sequence ? ex.expressions : [ ex ], start);\n                return subscripts(ex, allow_calls);\n              case \"[\":\n                return subscripts(array_(), allow_calls);\n              case \"{\":\n                return subscripts(object_(), allow_calls);\n            }\n            unexpected();\n        }\n        var ctor;\n        if (is(\"name\", \"async\") && is_token(peek(), \"keyword\", \"function\")) {\n            next();\n            ctor = AST_AsyncFunction;\n        } else if (is(\"keyword\", \"function\")) {\n            ctor = AST_Function;\n        }\n        if (ctor) {\n            next();\n            var func = function_(ctor);\n            func.start = start;\n            func.end = prev();\n            return subscripts(func, allow_calls);\n        }\n        if (is(\"name\")) {\n            var sym = _make_symbol(AST_SymbolRef, start);\n            next();\n            return is(\"punc\", \"=>\") ? arrow([ sym ], start) : subscripts(sym, allow_calls);\n        }\n        if (ATOMIC_START_TOKEN[S.token.type]) {\n            return subscripts(as_atom_node(), allow_calls);\n        }\n        unexpected();\n    };\n\n    function expr_list(closing, allow_trailing_comma, allow_empty, parser) {\n        if (!parser) parser = maybe_assign;\n        var first = true, a = [];\n        while (!is(\"punc\", closing)) {\n            if (first) first = false; else expect(\",\");\n            if (allow_trailing_comma && is(\"punc\", closing)) break;\n            if (allow_empty && is(\"punc\", \",\")) {\n                a.push(new AST_Hole({ start: S.token, end: S.token }));\n            } else if (parser === maybe_assign && is(\"operator\", \"...\")) {\n                a.push(new AST_Spread({\n                    start: S.token,\n                    expression: (next(), parser()),\n                    end: prev(),\n                }));\n            } else {\n                a.push(parser());\n            }\n        }\n        next();\n        return a;\n    }\n\n    var array_ = embed_tokens(function() {\n        expect(\"[\");\n        return new AST_Array({\n            elements: expr_list(\"]\", !options.strict, true)\n        });\n    });\n\n    var create_accessor = embed_tokens(function() {\n        return function_(AST_Accessor);\n    });\n\n    var object_ = embed_tokens(function() {\n        expect(\"{\");\n        var first = true, a = [];\n        while (!is(\"punc\", \"}\")) {\n            if (first) first = false; else expect(\",\");\n            // allow trailing comma\n            if (!options.strict && is(\"punc\", \"}\")) break;\n            var start = S.token;\n            if (is(\"operator\", \"...\")) {\n                next();\n                a.push(new AST_Spread({\n                    start: start,\n                    expression: maybe_assign(),\n                    end: prev(),\n                }));\n                continue;\n            }\n            if (is_token(peek(), \"operator\", \"=\")) {\n                var name = as_symbol(AST_SymbolRef);\n                next();\n                a.push(new AST_ObjectKeyVal({\n                    start: start,\n                    key: start.value,\n                    value: new AST_Assign({\n                        start: start,\n                        left: name,\n                        operator: \"=\",\n                        right: maybe_assign(),\n                        end: prev(),\n                    }),\n                    end: prev(),\n                }));\n                continue;\n            }\n            if (is_token(peek(), \"punc\", \",\") || is_token(peek(), \"punc\", \"}\")) {\n                a.push(new AST_ObjectKeyVal({\n                    start: start,\n                    key: start.value,\n                    value: as_symbol(AST_SymbolRef),\n                    end: prev(),\n                }));\n                continue;\n            }\n            var key = as_property_key();\n            if (is(\"punc\", \"(\")) {\n                var func_start = S.token;\n                var func = function_(AST_Function);\n                func.start = func_start;\n                func.end = prev();\n                a.push(new AST_ObjectKeyVal({\n                    start: start,\n                    key: key,\n                    value: func,\n                    end: prev(),\n                }));\n                continue;\n            }\n            if (is(\"punc\", \":\")) {\n                next();\n                a.push(new AST_ObjectKeyVal({\n                    start: start,\n                    key: key,\n                    value: maybe_assign(),\n                    end: prev(),\n                }));\n                continue;\n            }\n            if (start.type == \"name\") switch (key) {\n              case \"async\":\n                key = as_property_key();\n                var func_start = S.token;\n                var func = function_(AST_AsyncFunction);\n                func.start = func_start;\n                func.end = prev();\n                a.push(new AST_ObjectKeyVal({\n                    start: start,\n                    key: key,\n                    value: func,\n                    end: prev(),\n                }));\n                continue;\n              case \"get\":\n                a.push(new AST_ObjectGetter({\n                    start: start,\n                    key: as_property_key(),\n                    value: create_accessor(),\n                    end: prev(),\n                }));\n                continue;\n              case \"set\":\n                a.push(new AST_ObjectSetter({\n                    start: start,\n                    key: as_property_key(),\n                    value: create_accessor(),\n                    end: prev(),\n                }));\n                continue;\n            }\n            unexpected();\n        }\n        next();\n        return new AST_Object({ properties: a });\n    });\n\n    function as_property_key() {\n        var tmp = S.token;\n        switch (tmp.type) {\n          case \"operator\":\n            if (!KEYWORDS[tmp.value]) unexpected();\n          case \"num\":\n          case \"string\":\n          case \"name\":\n          case \"keyword\":\n          case \"atom\":\n            next();\n            return \"\" + tmp.value;\n          case \"punc\":\n            expect(\"[\");\n            var key = maybe_assign();\n            expect(\"]\");\n            return key;\n          default:\n            unexpected();\n        }\n    }\n\n    function as_name() {\n        var name = S.token.value;\n        expect_token(\"name\");\n        return name;\n    }\n\n    function _make_symbol(type, token) {\n        var name = token.value;\n        if (name === \"await\" && S.in_async) unexpected(token);\n        return new (name === \"this\" ? AST_This : type)({\n            name: \"\" + name,\n            start: token,\n            end: token,\n        });\n    }\n\n    function strict_verify_symbol(sym) {\n        if (sym.name == \"arguments\" || sym.name == \"eval\")\n            token_error(sym.start, \"Unexpected \" + sym.name + \" in strict mode\");\n    }\n\n    function as_symbol(type, noerror) {\n        if (!is(\"name\")) {\n            if (!noerror) croak(\"Name expected\");\n            return null;\n        }\n        var sym = _make_symbol(type, S.token);\n        if (S.input.has_directive(\"use strict\") && sym instanceof AST_SymbolDeclaration) {\n            strict_verify_symbol(sym);\n        }\n        next();\n        return sym;\n    }\n\n    function maybe_destructured(type) {\n        var start = S.token;\n        if (is(\"punc\", \"[\")) {\n            next();\n            return new AST_DestructuredArray({\n                start: start,\n                elements: expr_list(\"]\", !options.strict, true, function() {\n                    return maybe_default(type);\n                }),\n                end: prev(),\n            });\n        }\n        if (is(\"punc\", \"{\")) {\n            next();\n            var first = true, a = [];\n            while (!is(\"punc\", \"}\")) {\n                if (first) first = false; else expect(\",\");\n                // allow trailing comma\n                if (!options.strict && is(\"punc\", \"}\")) break;\n                var key_start = S.token;\n                if (is(\"punc\", \"[\") || is_token(peek(), \"punc\", \":\")) {\n                    var key = as_property_key();\n                    expect(\":\");\n                    a.push(new AST_DestructuredKeyVal({\n                        start: key_start,\n                        key: key,\n                        value: maybe_default(type),\n                        end: prev(),\n                    }));\n                    continue;\n                }\n                var name = as_symbol(type);\n                if (is(\"operator\", \"=\")) {\n                    next();\n                    name = new AST_DefaultValue({\n                        start: name.start,\n                        name: name,\n                        value: maybe_assign(),\n                        end: prev(),\n                    });\n                }\n                a.push(new AST_DestructuredKeyVal({\n                    start: key_start,\n                    key: key_start.value,\n                    value: name,\n                    end: prev(),\n                }));\n            }\n            next();\n            return new AST_DestructuredObject({\n                start: start,\n                properties: a,\n                end: prev(),\n            });\n        }\n        return as_symbol(type);\n    }\n\n    function maybe_default(type) {\n        var start = S.token;\n        var name = maybe_destructured(type);\n        if (!is(\"operator\", \"=\")) return name;\n        next();\n        return new AST_DefaultValue({\n            start: start,\n            name: name,\n            value: maybe_assign(),\n            end: prev(),\n        });\n    }\n\n    function mark_pure(call) {\n        var start = call.start;\n        var comments = start.comments_before;\n        var i = HOP(start, \"comments_before_length\") ? start.comments_before_length : comments.length;\n        while (--i >= 0) {\n            var comment = comments[i];\n            if (/[@#]__PURE__/.test(comment.value)) {\n                call.pure = comment;\n                break;\n            }\n        }\n    }\n\n    var subscripts = function(expr, allow_calls) {\n        var start = expr.start;\n        if (is(\"punc\", \".\")) {\n            next();\n            return subscripts(new AST_Dot({\n                start      : start,\n                expression : expr,\n                property   : as_name(),\n                end        : prev()\n            }), allow_calls);\n        }\n        if (is(\"punc\", \"[\")) {\n            next();\n            var prop = expression();\n            expect(\"]\");\n            return subscripts(new AST_Sub({\n                start      : start,\n                expression : expr,\n                property   : prop,\n                end        : prev()\n            }), allow_calls);\n        }\n        if (allow_calls && is(\"punc\", \"(\")) {\n            next();\n            var call = new AST_Call({\n                start      : start,\n                expression : expr,\n                args       : expr_list(\")\", !options.strict),\n                end        : prev()\n            });\n            mark_pure(call);\n            return subscripts(call, true);\n        }\n        return expr;\n    };\n\n    function maybe_unary() {\n        var start = S.token;\n        if (is(\"operator\") && UNARY_PREFIX[start.value]) {\n            next();\n            handle_regexp();\n            var ex = make_unary(AST_UnaryPrefix, start, maybe_await());\n            ex.start = start;\n            ex.end = prev();\n            return ex;\n        }\n        var val = expr_atom(true);\n        while (is(\"operator\") && UNARY_POSTFIX[S.token.value] && !has_newline_before(S.token)) {\n            val = make_unary(AST_UnaryPostfix, S.token, val);\n            val.start = start;\n            val.end = S.token;\n            next();\n        }\n        return val;\n    }\n\n    function make_unary(ctor, token, expr) {\n        var op = token.value;\n        switch (op) {\n          case \"++\":\n          case \"--\":\n            if (!is_assignable(expr))\n                token_error(token, \"Invalid use of \" + op + \" operator\");\n            break;\n          case \"delete\":\n            if (expr instanceof AST_SymbolRef && S.input.has_directive(\"use strict\"))\n                token_error(expr.start, \"Calling delete on expression not allowed in strict mode\");\n            break;\n        }\n        return new ctor({ operator: op, expression: expr });\n    }\n\n    function maybe_await() {\n        var start = S.token;\n        if (!(S.in_async && is(\"name\", \"await\"))) return maybe_unary();\n        if (S.in_funarg === S.in_function) croak(\"Invalid use of await in function argument\");\n        S.input.context().regex_allowed = true;\n        next();\n        return new AST_Await({\n            start: start,\n            expression: maybe_await(),\n            end: prev(),\n        });\n    }\n\n    var expr_op = function(left, min_prec, no_in) {\n        var op = is(\"operator\") ? S.token.value : null;\n        if (op == \"in\" && no_in) op = null;\n        var prec = op != null ? PRECEDENCE[op] : null;\n        if (prec != null && prec > min_prec) {\n            next();\n            var right = expr_op(maybe_await(), prec, no_in);\n            return expr_op(new AST_Binary({\n                start    : left.start,\n                left     : left,\n                operator : op,\n                right    : right,\n                end      : right.end\n            }), min_prec, no_in);\n        }\n        return left;\n    };\n\n    function expr_ops(no_in) {\n        return expr_op(maybe_await(), 0, no_in);\n    }\n\n    var maybe_conditional = function(no_in) {\n        var start = S.token;\n        var expr = expr_ops(no_in);\n        if (is(\"operator\", \"?\")) {\n            next();\n            var yes = maybe_assign();\n            expect(\":\");\n            return new AST_Conditional({\n                start       : start,\n                condition   : expr,\n                consequent  : yes,\n                alternative : maybe_assign(no_in),\n                end         : prev()\n            });\n        }\n        return expr;\n    };\n\n    function is_assignable(expr) {\n        return expr instanceof AST_PropAccess || expr instanceof AST_SymbolRef;\n    }\n\n    function to_destructured(node) {\n        if (node instanceof AST_Array) {\n            var elements = node.elements.map(to_destructured);\n            return all(elements, function(node) {\n                return node instanceof AST_DefaultValue\n                    || node instanceof AST_Destructured\n                    || node instanceof AST_Hole\n                    || is_assignable(node);\n            }) ? new AST_DestructuredArray({\n                start: node.start,\n                elements: elements,\n                end: node.end,\n            }) : node;\n        }\n        if (node instanceof AST_Assign) {\n            var name = to_destructured(node.left);\n            return name instanceof AST_Destructured || is_assignable(name) ? new AST_DefaultValue({\n                start: node.start,\n                name: name,\n                value: node.right,\n                end: node.end,\n            }) : node;\n        }\n        if (!(node instanceof AST_Object)) return node;\n        var props = [];\n        for (var i = 0; i < node.properties.length; i++) {\n            var prop = node.properties[i];\n            if (!(prop instanceof AST_ObjectKeyVal)) return node;\n            var value = to_destructured(prop.value);\n            if (!(value instanceof AST_DefaultValue || value instanceof AST_Destructured || is_assignable(value))) {\n                return node;\n            }\n            props.push(new AST_DestructuredKeyVal({\n                start: prop.start,\n                key: prop.key,\n                value: value,\n                end: prop.end,\n            }));\n        }\n        return new AST_DestructuredObject({\n            start: node.start,\n            properties: props,\n            end: node.end,\n        });\n    }\n\n    function maybe_assign(no_in) {\n        var start = S.token;\n        var left = maybe_conditional(no_in), val = S.token.value;\n        if (is(\"operator\") && ASSIGNMENT[val]) {\n            if (is_assignable(left) || val == \"=\" && (left = to_destructured(left)) instanceof AST_Destructured) {\n                next();\n                return new AST_Assign({\n                    start    : start,\n                    left     : left,\n                    operator : val,\n                    right    : maybe_assign(no_in),\n                    end      : prev()\n                });\n            }\n            croak(\"Invalid assignment\");\n        }\n        return left;\n    }\n\n    function expression(no_in, maybe_arrow) {\n        var start = S.token;\n        var exprs = [];\n        while (true) {\n            exprs.push(maybe_assign(no_in));\n            if (!is(\"punc\", \",\")) break;\n            next();\n            if (maybe_arrow && is(\"punc\", \")\") && is_token(peek(), \"punc\", \"=>\")) break;\n        }\n        return exprs.length == 1 ? exprs[0] : new AST_Sequence({\n            start       : start,\n            expressions : exprs,\n            end         : prev()\n        });\n    }\n\n    function in_loop(cont) {\n        ++S.in_loop;\n        var ret = cont();\n        --S.in_loop;\n        return ret;\n    }\n\n    if (options.expression) {\n        handle_regexp();\n        var exp = expression();\n        expect_token(\"eof\");\n        return exp;\n    }\n\n    return function() {\n        var start = S.token;\n        var body = [];\n        S.input.push_directives_stack();\n        while (!is(\"eof\"))\n            body.push(statement());\n        S.input.pop_directives_stack();\n        var end = prev();\n        var toplevel = options.toplevel;\n        if (toplevel) {\n            toplevel.body = toplevel.body.concat(body);\n            toplevel.end = end;\n        } else {\n            toplevel = new AST_Toplevel({ start: start, body: body, end: end });\n        }\n        return toplevel;\n    }();\n}\n","/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\n\"use strict\";\n\nvar builtins = function() {\n    var names = [];\n    // NaN will be included due to Number.NaN\n    [\n        \"null\",\n        \"true\",\n        \"false\",\n        \"Infinity\",\n        \"-Infinity\",\n        \"undefined\",\n    ].forEach(add);\n    [\n        Array,\n        Boolean,\n        Date,\n        Error,\n        Function,\n        Math,\n        Number,\n        Object,\n        RegExp,\n        String,\n    ].forEach(function(ctor) {\n        Object.getOwnPropertyNames(ctor).map(add);\n        if (ctor.prototype) {\n            Object.getOwnPropertyNames(new ctor()).map(add);\n            Object.getOwnPropertyNames(ctor.prototype).map(add);\n        }\n    });\n    return makePredicate(names);\n\n    function add(name) {\n        names.push(name);\n    }\n}();\n\nfunction reserve_quoted_keys(ast, reserved) {\n    ast.walk(new TreeWalker(function(node) {\n        if (node instanceof AST_ObjectProperty) {\n            if (node.start && node.start.quote) add(node.key);\n        } else if (node instanceof AST_Sub) {\n            addStrings(node.property, add);\n        }\n    }));\n\n    function add(name) {\n        push_uniq(reserved, name);\n    }\n}\n\nfunction addStrings(node, add) {\n    if (node instanceof AST_Conditional) {\n        addStrings(node.consequent, add);\n        addStrings(node.alternative, add);\n    } else if (node instanceof AST_Sequence) {\n        addStrings(node.tail_node(), add);\n    } else if (node instanceof AST_String) {\n        add(node.value);\n    }\n}\n\nfunction mangle_properties(ast, options) {\n    options = defaults(options, {\n        builtins: false,\n        cache: null,\n        debug: false,\n        keep_quoted: false,\n        regex: null,\n        reserved: null,\n    }, true);\n\n    var reserved = Object.create(options.builtins ? null : builtins);\n    if (Array.isArray(options.reserved)) options.reserved.forEach(function(name) {\n        reserved[name] = true;\n    });\n\n    var cname = -1;\n    var cache;\n    if (options.cache) {\n        cache = options.cache.props;\n        cache.each(function(name) {\n            reserved[name] = true;\n        });\n    } else {\n        cache = new Dictionary();\n    }\n\n    var regex = options.regex;\n\n    // note debug is either false (disabled), or a string of the debug suffix to use (enabled).\n    // note debug may be enabled as an empty string, which is falsey. Also treat passing 'true'\n    // the same as passing an empty string.\n    var debug = options.debug !== false;\n    var debug_suffix;\n    if (debug) debug_suffix = options.debug === true ? \"\" : options.debug;\n\n    var names_to_mangle = Object.create(null);\n    var unmangleable = Object.create(reserved);\n\n    // step 1: find candidates to mangle\n    ast.walk(new TreeWalker(function(node) {\n        if (node instanceof AST_Binary) {\n            if (node.operator == \"in\") addStrings(node.left, add);\n        } else if (node.TYPE == \"Call\") {\n            var exp = node.expression;\n            if (exp instanceof AST_Dot) switch (exp.property) {\n              case \"defineProperty\":\n              case \"getOwnPropertyDescriptor\":\n                if (node.args.length < 2) break;\n                exp = exp.expression;\n                if (!(exp instanceof AST_SymbolRef)) break;\n                if (exp.name != \"Object\") break;\n                if (!exp.definition().undeclared) break;\n                addStrings(node.args[1], add);\n                break;\n              case \"hasOwnProperty\":\n                if (node.args.length < 1) break;\n                addStrings(node.args[0], add);\n                break;\n            }\n        } else if (node instanceof AST_Dot) {\n            add(node.property);\n        } else if (node instanceof AST_ObjectProperty) {\n            if (typeof node.key == \"string\") add(node.key);\n        } else if (node instanceof AST_Sub) {\n            addStrings(node.property, add);\n        }\n    }));\n\n    // step 2: renaming properties\n    ast.walk(new TreeWalker(function(node) {\n        if (node instanceof AST_Binary) {\n            if (node.operator == \"in\") mangleStrings(node.left);\n        } else if (node.TYPE == \"Call\") {\n            var exp = node.expression;\n            if (exp instanceof AST_Dot) switch (exp.property) {\n              case \"defineProperty\":\n              case \"getOwnPropertyDescriptor\":\n                if (node.args.length < 2) break;\n                exp = exp.expression;\n                if (!(exp instanceof AST_SymbolRef)) break;\n                if (exp.name != \"Object\") break;\n                if (!exp.definition().undeclared) break;\n                mangleStrings(node.args[1]);\n                break;\n              case \"hasOwnProperty\":\n                if (node.args.length < 1) break;\n                mangleStrings(node.args[0]);\n                break;\n            }\n        } else if (node instanceof AST_Dot) {\n            node.property = mangle(node.property);\n        } else if (node instanceof AST_ObjectProperty) {\n            if (typeof node.key == \"string\") node.key = mangle(node.key);\n        } else if (node instanceof AST_Sub) {\n            if (!options.keep_quoted) mangleStrings(node.property);\n        }\n    }));\n\n    // only function declarations after this line\n\n    function can_mangle(name) {\n        if (unmangleable[name]) return false;\n        if (/^-?[0-9]+(\\.[0-9]+)?(e[+-][0-9]+)?$/.test(name)) return false;\n        return true;\n    }\n\n    function should_mangle(name) {\n        if (reserved[name]) return false;\n        if (regex && !regex.test(name)) return false;\n        return cache.has(name) || names_to_mangle[name];\n    }\n\n    function add(name) {\n        if (can_mangle(name)) names_to_mangle[name] = true;\n        if (!should_mangle(name)) unmangleable[name] = true;\n    }\n\n    function mangle(name) {\n        if (!should_mangle(name)) {\n            return name;\n        }\n        var mangled = cache.get(name);\n        if (!mangled) {\n            if (debug) {\n                // debug mode: use a prefix and suffix to preserve readability, e.g. o.foo -> o._$foo$NNN_.\n                var debug_mangled = \"_$\" + name + \"$\" + debug_suffix + \"_\";\n                if (can_mangle(debug_mangled)) mangled = debug_mangled;\n            }\n            // either debug mode is off, or it is on and we could not use the mangled name\n            if (!mangled) do {\n                mangled = base54(++cname);\n            } while (!can_mangle(mangled));\n            cache.set(name, mangled);\n        }\n        return mangled;\n    }\n\n    function mangleStrings(node) {\n        if (node instanceof AST_Sequence) {\n            mangleStrings(node.expressions.tail_node());\n        } else if (node instanceof AST_String) {\n            node.value = mangle(node.value);\n        } else if (node instanceof AST_Conditional) {\n            mangleStrings(node.consequent);\n            mangleStrings(node.alternative);\n        }\n    }\n}\n","/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\n\"use strict\";\n\nfunction SymbolDef(id, scope, orig, init) {\n    this.eliminated = 0;\n    this.global = false;\n    this.id = id;\n    this.init = init;\n    this.lambda = orig instanceof AST_SymbolLambda;\n    this.mangled_name = null;\n    this.name = orig.name;\n    this.orig = [ orig ];\n    this.references = [];\n    this.replaced = 0;\n    this.scope = scope;\n    this.undeclared = false;\n}\n\nSymbolDef.prototype = {\n    forEach: function(fn) {\n        this.orig.forEach(fn);\n        this.references.forEach(fn);\n    },\n    mangle: function(options) {\n        var cache = options.cache && options.cache.props;\n        if (this.global && cache && cache.has(this.name)) {\n            this.mangled_name = cache.get(this.name);\n        } else if (!this.mangled_name && !this.unmangleable(options)) {\n            var def = this.redefined();\n            if (def) {\n                this.mangled_name = def.mangled_name || def.name;\n            } else {\n                this.mangled_name = next_mangled_name(this, options);\n            }\n            if (this.global && cache) {\n                cache.set(this.name, this.mangled_name);\n            }\n        }\n    },\n    redefined: function() {\n        var scope = this.defun;\n        if (!scope) return;\n        var name = this.name;\n        var def = scope.variables.get(name)\n            || scope instanceof AST_Toplevel && scope.globals.get(name)\n            || this.orig[0] instanceof AST_SymbolConst && find_if(function(def) {\n                return def.name == name;\n            }, scope.enclosed);\n        if (def && def !== this) return def.redefined() || def;\n    },\n    unmangleable: function(options) {\n        return this.global && !options.toplevel\n            || this.undeclared\n            || !options.eval && this.scope.pinned()\n            || options.keep_fnames\n                && (this.orig[0] instanceof AST_SymbolLambda\n                    || this.orig[0] instanceof AST_SymbolDefun);\n    },\n};\n\nvar unary_side_effects = makePredicate(\"delete ++ --\");\n\nAST_Toplevel.DEFMETHOD(\"figure_out_scope\", function(options) {\n    options = defaults(options, {\n        cache: null,\n        ie8: false,\n    });\n\n    // pass 1: setup scope chaining and handle definitions\n    var self = this;\n    var defun = null;\n    var next_def_id = 0;\n    var scope = self.parent_scope = null;\n    var tw = new TreeWalker(function(node, descend) {\n        if (is_defun(node)) {\n            node.name.walk(tw);\n            walk_scope(function() {\n                node.argnames.forEach(function(argname) {\n                    argname.walk(tw);\n                });\n                walk_body(node, tw);\n            });\n            return true;\n        }\n        if (node instanceof AST_SwitchBranch) {\n            node.init_vars(scope);\n            descend();\n            return true;\n        }\n        if (node instanceof AST_Try) {\n            walk_scope(function() {\n                walk_body(node, tw);\n            });\n            if (node.bcatch) node.bcatch.walk(tw);\n            if (node.bfinally) node.bfinally.walk(tw);\n            return true;\n        }\n        if (node instanceof AST_With) {\n            var s = scope;\n            do {\n                s = s.resolve();\n                if (s.uses_with) break;\n                s.uses_with = true;\n            } while (s = s.parent_scope);\n            walk_scope(descend);\n            return true;\n        }\n        if (node instanceof AST_BlockScope) {\n            walk_scope(descend);\n            return true;\n        }\n        if (node instanceof AST_Symbol) {\n            node.scope = scope;\n        }\n        if (node instanceof AST_Label) {\n            node.thedef = node;\n            node.references = [];\n        }\n        if (node instanceof AST_SymbolCatch) {\n            scope.def_variable(node).defun = defun;\n        } else if (node instanceof AST_SymbolConst) {\n            scope.def_variable(node).defun = defun;\n        } else if (node instanceof AST_SymbolDefun) {\n            defun.def_function(node, tw.parent());\n            entangle(defun, scope);\n        } else if (node instanceof AST_SymbolFunarg) {\n            defun.def_variable(node);\n            entangle(defun, scope);\n        } else if (node instanceof AST_SymbolLambda) {\n            var def = defun.def_function(node, node.name == \"arguments\" ? undefined : defun);\n            if (options.ie8) def.defun = defun.parent_scope.resolve();\n        } else if (node instanceof AST_SymbolLet) {\n            scope.def_variable(node);\n        } else if (node instanceof AST_SymbolVar) {\n            defun.def_variable(node, null);\n            entangle(defun, scope);\n        }\n\n        function walk_scope(descend) {\n            node.init_vars(scope);\n            var save_defun = defun;\n            var save_scope = scope;\n            if (node instanceof AST_Scope) defun = node;\n            scope = node;\n            descend();\n            scope = save_scope;\n            defun = save_defun;\n        }\n\n        function entangle(defun, scope) {\n            if (defun === scope) return;\n            node.mark_enclosed(options);\n            var def = scope.find_variable(node.name);\n            if (node.thedef === def) return;\n            node.thedef = def;\n            def.orig.push(node);\n            node.mark_enclosed(options);\n        }\n    });\n    self.make_def = function(orig, init) {\n        return new SymbolDef(++next_def_id, this, orig, init);\n    };\n    self.walk(tw);\n\n    // pass 2: find back references and eval\n    self.globals = new Dictionary();\n    var in_arg = [];\n    var tw = new TreeWalker(function(node) {\n        if (node instanceof AST_Catch) {\n            if (!(node.argname instanceof AST_Destructured)) return;\n            in_arg.push(node);\n            node.argname.walk(tw);\n            in_arg.pop();\n            walk_body(node, tw);\n            return true;\n        }\n        if (node instanceof AST_Lambda) {\n            in_arg.push(node);\n            node.argnames.forEach(function(argname) {\n                argname.walk(tw);\n            });\n            in_arg.pop();\n            if (node instanceof AST_Arrow && node.value) {\n                node.value.walk(tw);\n            } else {\n                walk_body(node, tw);\n            }\n            return true;\n        }\n        if (node instanceof AST_LoopControl) {\n            if (node.label) node.label.thedef.references.push(node);\n            return true;\n        }\n        // ensure mangling works if `catch` reuses a scope variable\n        if (node instanceof AST_SymbolCatch) {\n            var def = node.definition().redefined();\n            if (def) for (var s = node.scope; s; s = s.parent_scope) {\n                push_uniq(s.enclosed, def);\n                if (s === def.scope) break;\n            }\n            return true;\n        }\n        // ensure compression works if `const` reuses a scope variable\n        if (node instanceof AST_SymbolConst) {\n            var redef = node.definition().redefined();\n            if (redef) redef.const_redefs = true;\n            return true;\n        }\n        if (node instanceof AST_SymbolRef) {\n            var name = node.name;\n            var sym = node.scope.find_variable(name);\n            for (var i = in_arg.length; i > 0 && sym;) {\n                i = in_arg.lastIndexOf(sym.scope, i - 1);\n                if (i < 0) break;\n                var decl = sym.orig[0];\n                if (decl instanceof AST_SymbolCatch\n                    || decl instanceof AST_SymbolFunarg\n                    || decl instanceof AST_SymbolLambda) {\n                    node.in_arg = true;\n                    break;\n                }\n                sym = sym.scope.parent_scope.find_variable(name);\n            }\n            if (!sym) {\n                sym = self.def_global(node);\n            } else if (name == \"arguments\" && is_arguments(sym)) {\n                var parent = tw.parent();\n                if (parent instanceof AST_Assign && parent.left === node\n                    || parent instanceof AST_Unary && unary_side_effects[parent.operator]) {\n                    sym.scope.uses_arguments = 3;\n                } else if (sym.scope.uses_arguments < 2\n                    && !(parent instanceof AST_PropAccess && parent.expression === node)) {\n                    sym.scope.uses_arguments = 2;\n                } else if (!sym.scope.uses_arguments) {\n                    sym.scope.uses_arguments = true;\n                }\n            }\n            if (name == \"eval\") {\n                var parent = tw.parent();\n                if (parent.TYPE == \"Call\" && parent.expression === node) {\n                    var s = node.scope;\n                    do {\n                        s = s.resolve();\n                        if (s.uses_eval) break;\n                        s.uses_eval = true;\n                    } while (s = s.parent_scope);\n                } else if (sym.undeclared) {\n                    self.uses_eval = true;\n                }\n            }\n            node.thedef = sym;\n            node.reference(options);\n            return true;\n        }\n        if (node instanceof AST_VarDef) {\n            if (node.value && node.name.name == \"arguments\") {\n                var sym = node.name.scope.resolve().find_variable(\"arguments\");\n                if (sym && is_arguments(sym)) sym.scope.uses_arguments = 3;\n            }\n            return;\n        }\n    });\n    self.walk(tw);\n\n    // pass 3: fix up any scoping issue with IE8\n    if (options.ie8) self.walk(new TreeWalker(function(node) {\n        if (node instanceof AST_SymbolCatch) {\n            var scope = node.thedef.defun;\n            if (scope.name instanceof AST_SymbolLambda && scope.name.name == node.name) {\n                scope = scope.parent_scope.resolve();\n            }\n            redefine(node, scope);\n            return true;\n        }\n        if (node instanceof AST_SymbolLambda) {\n            var def = node.thedef;\n            redefine(node, node.scope.parent_scope.resolve());\n            if (typeof node.thedef.init !== \"undefined\") {\n                node.thedef.init = false;\n            } else if (def.init) {\n                node.thedef.init = def.init;\n            }\n            return true;\n        }\n    }));\n\n    function is_arguments(sym) {\n        return sym.orig[0] instanceof AST_SymbolFunarg\n            && !(sym.orig[1] instanceof AST_SymbolFunarg || sym.orig[2] instanceof AST_SymbolFunarg)\n            && !(sym.scope instanceof AST_Arrow);\n    }\n\n    function redefine(node, scope) {\n        var name = node.name;\n        var old_def = node.thedef;\n        if (!all(old_def.orig, function(sym) {\n            return !(sym instanceof AST_SymbolConst || sym instanceof AST_SymbolLet);\n        })) return;\n        var new_def = scope.find_variable(name);\n        if (new_def) {\n            var redef = new_def.redefined();\n            if (redef) new_def = redef;\n        } else {\n            new_def = self.globals.get(name);\n        }\n        if (new_def) {\n            new_def.orig.push(node);\n        } else {\n            new_def = scope.def_variable(node);\n        }\n        old_def.defun = new_def.scope;\n        old_def.forEach(function(node) {\n            node.redef = true;\n            node.thedef = new_def;\n            node.reference(options);\n        });\n        if (old_def.lambda) new_def.lambda = true;\n        if (new_def.undeclared) self.variables.set(name, new_def);\n    }\n});\n\nAST_Toplevel.DEFMETHOD(\"def_global\", function(node) {\n    var globals = this.globals, name = node.name;\n    if (globals.has(name)) {\n        return globals.get(name);\n    } else {\n        var g = this.make_def(node);\n        g.undeclared = true;\n        g.global = true;\n        globals.set(name, g);\n        return g;\n    }\n});\n\nfunction init_block_vars(scope, parent) {\n    scope.enclosed = [];                            // variables from this or outer scope(s) that are referenced from this or inner scopes\n    scope.parent_scope = parent;                    // the parent scope (null if this is the top level)\n    scope.functions = new Dictionary();             // map name to AST_SymbolDefun (functions defined in this scope)\n    scope.variables = new Dictionary();             // map name to AST_SymbolVar (variables defined in this scope; includes functions)\n    if (parent) scope.make_def = parent.make_def;   // top-level tracking of SymbolDef instances\n}\n\nfunction init_scope_vars(scope, parent) {\n    init_block_vars(scope, parent);\n    scope.uses_eval = false;                        // will be set to true if this or nested scope uses the global `eval`\n    scope.uses_with = false;                        // will be set to true if this or some nested scope uses the `with` statement\n}\n\nAST_BlockScope.DEFMETHOD(\"init_vars\", function(parent_scope) {\n    init_block_vars(this, parent_scope);\n});\nAST_Scope.DEFMETHOD(\"init_vars\", function(parent_scope) {\n    init_scope_vars(this, parent_scope);\n});\nAST_Arrow.DEFMETHOD(\"init_vars\", function(parent_scope) {\n    init_scope_vars(this, parent_scope);\n});\nAST_Lambda.DEFMETHOD(\"init_vars\", function(parent_scope) {\n    init_scope_vars(this, parent_scope);\n    this.uses_arguments = false;\n    this.def_variable(new AST_SymbolFunarg({\n        name: \"arguments\",\n        start: this.start,\n        end: this.end,\n    }));\n    return this;\n});\n\nAST_Symbol.DEFMETHOD(\"mark_enclosed\", function(options) {\n    var def = this.definition();\n    for (var s = this.scope; s; s = s.parent_scope) {\n        push_uniq(s.enclosed, def);\n        if (options.keep_fnames) {\n            s.functions.each(function(d) {\n                push_uniq(def.scope.enclosed, d);\n            });\n        }\n        if (s === def.scope) break;\n    }\n});\n\nAST_Symbol.DEFMETHOD(\"reference\", function(options) {\n    this.definition().references.push(this);\n    this.mark_enclosed(options);\n});\n\nAST_BlockScope.DEFMETHOD(\"find_variable\", function(name) {\n    return this.variables.get(name)\n        || this.parent_scope && this.parent_scope.find_variable(name);\n});\n\nAST_BlockScope.DEFMETHOD(\"def_function\", function(symbol, init) {\n    var def = this.def_variable(symbol, init);\n    if (!def.init || is_defun(def.init)) def.init = init;\n    this.functions.set(symbol.name, def);\n    return def;\n});\n\nAST_BlockScope.DEFMETHOD(\"def_variable\", function(symbol, init) {\n    var def = this.variables.get(symbol.name);\n    if (def) {\n        def.orig.push(symbol);\n        if (is_function(def.init)) def.init = init;\n    } else {\n        def = this.make_def(symbol, init);\n        this.variables.set(symbol.name, def);\n        def.global = !this.parent_scope;\n    }\n    return symbol.thedef = def;\n});\n\nfunction names_in_use(scope, options) {\n    var names = scope.names_in_use;\n    if (!names) {\n        scope.cname = -1;\n        scope.cname_holes = [];\n        scope.names_in_use = names = Object.create(null);\n        var cache = options.cache && options.cache.props;\n        scope.enclosed.forEach(function(def) {\n            if (def.unmangleable(options)) names[def.name] = true;\n            if (def.global && cache && cache.has(def.name)) {\n                names[cache.get(def.name)] = true;\n            }\n        });\n    }\n    return names;\n}\n\nfunction next_mangled_name(def, options) {\n    var scope = def.scope;\n    var in_use = names_in_use(scope, options);\n    var holes = scope.cname_holes;\n    var names = Object.create(null);\n    var scopes = [ scope ];\n    def.forEach(function(sym) {\n        var scope = sym.scope;\n        do {\n            if (scopes.indexOf(scope) < 0) {\n                for (var name in names_in_use(scope, options)) {\n                    names[name] = true;\n                }\n                scopes.push(scope);\n            } else break;\n        } while (scope = scope.parent_scope);\n    });\n    var name;\n    for (var i = 0; i < holes.length; i++) {\n        name = base54(holes[i]);\n        if (names[name]) continue;\n        holes.splice(i, 1);\n        in_use[name] = true;\n        return name;\n    }\n    while (true) {\n        name = base54(++scope.cname);\n        if (in_use[name] || RESERVED_WORDS[name] || options.reserved.has[name]) continue;\n        if (!names[name]) break;\n        holes.push(scope.cname);\n    }\n    in_use[name] = true;\n    return name;\n}\n\nAST_Symbol.DEFMETHOD(\"unmangleable\", function(options) {\n    var def = this.definition();\n    return !def || def.unmangleable(options);\n});\n\n// labels are always mangleable\nAST_Label.DEFMETHOD(\"unmangleable\", return_false);\n\nAST_Symbol.DEFMETHOD(\"definition\", function() {\n    return this.thedef;\n});\n\nfunction _default_mangler_options(options) {\n    options = defaults(options, {\n        eval        : false,\n        ie8         : false,\n        keep_fnames : false,\n        reserved    : [],\n        toplevel    : false,\n        v8          : false,\n        webkit      : false,\n    });\n    if (!Array.isArray(options.reserved)) options.reserved = [];\n    // Never mangle arguments\n    push_uniq(options.reserved, \"arguments\");\n    options.reserved.has = makePredicate(options.reserved);\n    return options;\n}\n\nAST_Toplevel.DEFMETHOD(\"mangle_names\", function(options) {\n    options = _default_mangler_options(options);\n\n    // We only need to mangle declaration nodes.  Special logic wired\n    // into the code generator will display the mangled name if it's\n    // present (and for AST_SymbolRef-s it'll use the mangled name of\n    // the AST_SymbolDeclaration that it points to).\n    var lname = -1;\n\n    if (options.cache && options.cache.props) {\n        var mangled_names = names_in_use(this, options);\n        options.cache.props.each(function(mangled_name) {\n            mangled_names[mangled_name] = true;\n        });\n    }\n\n    var redefined = [];\n    var tw = new TreeWalker(function(node, descend) {\n        if (node instanceof AST_LabeledStatement) {\n            // lname is incremented when we get to the AST_Label\n            var save_nesting = lname;\n            descend();\n            if (!options.v8 || !in_label(tw)) lname = save_nesting;\n            return true;\n        }\n        if (node instanceof AST_BlockScope) {\n            if (options.webkit && node instanceof AST_IterationStatement && node.init instanceof AST_Let) {\n                node.init.definitions.forEach(function(defn) {\n                    defn.name.match_symbol(function(sym) {\n                        if (!(sym instanceof AST_SymbolLet)) return;\n                        var def = sym.definition();\n                        var scope = sym.scope.parent_scope;\n                        var redef = scope.def_variable(sym);\n                        sym.thedef = def;\n                        scope.to_mangle.push(redef);\n                        def.redefined = function() {\n                            return redef;\n                        };\n                    });\n                }, true);\n            }\n            node.to_mangle = [];\n            node.variables.each(function(def) {\n                if (!defer_redef(def)) node.to_mangle.push(def);\n            });\n            descend();\n            if (options.cache && node instanceof AST_Toplevel) {\n                node.globals.each(mangle);\n            }\n            if (node instanceof AST_Defun && tw.has_directive(\"use asm\")) {\n                var sym = new AST_SymbolRef(node.name);\n                sym.scope = node;\n                sym.reference(options);\n            }\n            node.to_mangle.forEach(mangle);\n            return true;\n        }\n        if (node instanceof AST_Label) {\n            var name;\n            do {\n                name = base54(++lname);\n            } while (RESERVED_WORDS[name]);\n            node.mangled_name = name;\n            return true;\n        }\n    });\n    this.walk(tw);\n    redefined.forEach(mangle);\n\n    function mangle(def) {\n        if (options.reserved.has[def.name]) return;\n        def.mangle(options);\n    }\n\n    function defer_redef(def) {\n        var sym = def.orig[0];\n        var redef = def.redefined();\n        if (!redef) {\n            if (!(sym instanceof AST_SymbolConst)) return false;\n            var scope = def.scope.resolve();\n            if (def.scope === scope) return false;\n            redef = scope.def_variable(sym);\n            scope.to_mangle.push(redef);\n        }\n        redefined.push(def);\n        def.references.forEach(reference);\n        if (sym instanceof AST_SymbolCatch || sym instanceof AST_SymbolConst) reference(sym);\n        return true;\n\n        function reference(sym) {\n            sym.thedef = redef;\n            sym.reference(options);\n            sym.thedef = def;\n        }\n    }\n\n    function in_label(tw) {\n        var level = 0, parent;\n        while (parent = tw.parent(level++)) {\n            if (parent instanceof AST_Block) return parent instanceof AST_Toplevel && !options.toplevel;\n            if (parent instanceof AST_LabeledStatement) return true;\n        }\n    }\n});\n\nAST_Toplevel.DEFMETHOD(\"find_colliding_names\", function(options) {\n    var cache = options.cache && options.cache.props;\n    var avoid = Object.create(RESERVED_WORDS);\n    options.reserved.forEach(to_avoid);\n    this.globals.each(add_def);\n    this.walk(new TreeWalker(function(node) {\n        if (node instanceof AST_BlockScope) node.variables.each(add_def);\n    }));\n    return avoid;\n\n    function to_avoid(name) {\n        avoid[name] = true;\n    }\n\n    function add_def(def) {\n        var name = def.name;\n        if (def.global && cache && cache.has(name)) name = cache.get(name);\n        else if (!def.unmangleable(options)) return;\n        to_avoid(name);\n    }\n});\n\nAST_Toplevel.DEFMETHOD(\"expand_names\", function(options) {\n    base54.reset();\n    base54.sort();\n    options = _default_mangler_options(options);\n    var avoid = this.find_colliding_names(options);\n    var cname = 0;\n    this.globals.each(rename);\n    this.walk(new TreeWalker(function(node) {\n        if (node instanceof AST_BlockScope) node.variables.each(rename);\n    }));\n\n    function next_name() {\n        var name;\n        do {\n            name = base54(cname++);\n        } while (avoid[name]);\n        return name;\n    }\n\n    function rename(def) {\n        if (def.global && options.cache) return;\n        if (def.unmangleable(options)) return;\n        if (options.reserved.has[def.name]) return;\n        var redef = def.redefined();\n        var name = redef ? redef.rename || redef.name : next_name();\n        def.rename = name;\n        def.forEach(function(sym) {\n            if (sym.definition() === def) sym.name = name;\n        });\n    }\n});\n\nAST_Node.DEFMETHOD(\"tail_node\", return_this);\nAST_Sequence.DEFMETHOD(\"tail_node\", function() {\n    return this.expressions[this.expressions.length - 1];\n});\n\nAST_Toplevel.DEFMETHOD(\"compute_char_frequency\", function(options) {\n    options = _default_mangler_options(options);\n    base54.reset();\n    var fn = AST_Symbol.prototype.add_source_map;\n    try {\n        AST_Symbol.prototype.add_source_map = function() {\n            if (!this.unmangleable(options)) base54.consider(this.name, -1);\n        };\n        if (options.properties) {\n            AST_Dot.prototype.add_source_map = function() {\n                base54.consider(this.property, -1);\n            };\n            AST_Sub.prototype.add_source_map = function() {\n                skip_string(this.property);\n            };\n        }\n        base54.consider(this.print_to_string(), 1);\n    } finally {\n        AST_Symbol.prototype.add_source_map = fn;\n        delete AST_Dot.prototype.add_source_map;\n        delete AST_Sub.prototype.add_source_map;\n    }\n    base54.sort();\n\n    function skip_string(node) {\n        if (node instanceof AST_String) {\n            base54.consider(node.value, -1);\n        } else if (node instanceof AST_Conditional) {\n            skip_string(node.consequent);\n            skip_string(node.alternative);\n        } else if (node instanceof AST_Sequence) {\n            skip_string(node.tail_node());\n        }\n    }\n});\n\nvar base54 = (function() {\n    var freq = Object.create(null);\n    function init(chars) {\n        var array = [];\n        for (var i = 0; i < chars.length; i++) {\n            var ch = chars[i];\n            array.push(ch);\n            freq[ch] = -1e-2 * i;\n        }\n        return array;\n    }\n    var digits = init(\"0123456789\");\n    var leading = init(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_\");\n    var chars, frequency;\n    function reset() {\n        frequency = Object.create(freq);\n    }\n    base54.consider = function(str, delta) {\n        for (var i = str.length; --i >= 0;) {\n            frequency[str[i]] += delta;\n        }\n    };\n    function compare(a, b) {\n        return frequency[b] - frequency[a];\n    }\n    base54.sort = function() {\n        chars = leading.sort(compare).concat(digits.sort(compare));\n    };\n    base54.reset = reset;\n    reset();\n    function base54(num) {\n        var ret = \"\", base = 54;\n        num++;\n        do {\n            num--;\n            ret += chars[num % base];\n            num = Math.floor(num / base);\n            base = 64;\n        } while (num > 0);\n        return ret;\n    }\n    return base54;\n})();\n","/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\n\"use strict\";\n\nvar vlq_char = characters(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\");\nvar vlq_bits = vlq_char.reduce(function(map, ch, bits) {\n    map[ch] = bits;\n    return map;\n}, Object.create(null));\n\nfunction vlq_decode(indices, str) {\n    var value = 0;\n    var shift = 0;\n    for (var i = 0, j = 0; i < str.length; i++) {\n        var bits = vlq_bits[str[i]];\n        value += (bits & 31) << shift;\n        if (bits & 32) {\n            shift += 5;\n        } else {\n            indices[j++] += value & 1 ? 0x80000000 | -(value >> 1) : value >> 1;\n            value = shift = 0;\n        }\n    }\n    return j;\n}\n\nfunction vlq_encode(num) {\n    var result = \"\";\n    num = Math.abs(num) << 1 | num >>> 31;\n    do {\n        var bits = num & 31;\n        if (num >>>= 5) bits |= 32;\n        result += vlq_char[bits];\n    } while (num);\n    return result;\n}\n\nfunction create_array_map() {\n    var map = Object.create(null);\n    var array = [];\n    array.index = function(name) {\n        if (!HOP(map, name)) {\n            map[name] = array.length;\n            array.push(name);\n        }\n        return map[name];\n    };\n    return array;\n}\n\nfunction SourceMap(options) {\n    var sources = create_array_map();\n    var sources_content = options.includeSources && Object.create(null);\n    var names = create_array_map();\n    var mappings = \"\";\n    if (options.orig) Object.keys(options.orig).forEach(function(name) {\n        var map = options.orig[name];\n        var indices = [ 0, 0, 1, 0, 0 ];\n        options.orig[name] = {\n            names: map.names,\n            mappings: map.mappings.split(/;/).map(function(line) {\n                indices[0] = 0;\n                return line.split(/,/).map(function(segment) {\n                    return indices.slice(0, vlq_decode(indices, segment));\n                });\n            }),\n            sources: map.sources,\n        };\n        if (!sources_content || !map.sourcesContent) return;\n        for (var i = 0; i < map.sources.length; i++) {\n            var content = map.sourcesContent[i];\n            if (content) sources_content[map.sources[i]] = content;\n        }\n    });\n    var prev_source;\n    var generated_line = 1;\n    var generated_column = 0;\n    var source_index = 0;\n    var original_line = 1;\n    var original_column = 0;\n    var name_index = 0;\n    return {\n        add: options.orig ? function(source, gen_line, gen_col, orig_line, orig_col, name) {\n            var map = options.orig[source];\n            if (map) {\n                var segments = map.mappings[orig_line - 1];\n                if (!segments) return;\n                var indices;\n                for (var i = 0; i < segments.length; i++) {\n                    var col = segments[i][0];\n                    if (orig_col >= col) indices = segments[i];\n                    if (orig_col <= col) break;\n                }\n                if (!indices || indices.length < 4) {\n                    source = null;\n                } else {\n                    source = map.sources[indices[1]];\n                    orig_line = indices[2];\n                    orig_col = indices[3];\n                    if (indices.length > 4) name = map.names[indices[4]];\n                }\n            }\n            add(source, gen_line, gen_col, orig_line, orig_col, name);\n        } : add,\n        setSourceContent: sources_content ? function(source, content) {\n            sources_content[source] = content;\n        } : noop,\n        toString: function() {\n            return JSON.stringify({\n                version: 3,\n                file: options.filename || undefined,\n                sourceRoot: options.root || undefined,\n                sources: sources,\n                sourcesContent: sources_content ? sources.map(function(source) {\n                    return sources_content[source] || null;\n                }) : undefined,\n                names: names,\n                mappings: mappings,\n            });\n        }\n    };\n\n    function add(source, gen_line, gen_col, orig_line, orig_col, name) {\n        if (prev_source == null && source == null) return;\n        prev_source = source;\n        if (generated_line < gen_line) {\n            generated_column = 0;\n            do {\n                mappings += \";\";\n            } while (++generated_line < gen_line);\n        } else if (mappings) {\n            mappings += \",\";\n        }\n        mappings += vlq_encode(gen_col - generated_column);\n        generated_column = gen_col;\n        if (source == null) return;\n        var src_idx = sources.index(source);\n        mappings += vlq_encode(src_idx - source_index);\n        source_index = src_idx;\n        mappings += vlq_encode(orig_line - original_line);\n        original_line = orig_line;\n        mappings += vlq_encode(orig_col - original_column);\n        original_column = orig_col;\n        if (options.names && name != null) {\n            var name_idx = names.index(name);\n            mappings += vlq_encode(name_idx - name_index);\n            name_index = name_idx;\n        }\n    }\n}\n","/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\n\"use strict\";\n\nfunction TreeTransformer(before, after) {\n    TreeWalker.call(this);\n    this.before = before;\n    this.after = after;\n}\nTreeTransformer.prototype = new TreeWalker;\n\n(function(DEF) {\n    function do_list(list, tw) {\n        return List(list, function(node) {\n            return node.transform(tw, true);\n        });\n    }\n\n    DEF(AST_Node, noop);\n    DEF(AST_LabeledStatement, function(self, tw) {\n        self.label = self.label.transform(tw);\n        self.body = self.body.transform(tw);\n    });\n    DEF(AST_SimpleStatement, function(self, tw) {\n        self.body = self.body.transform(tw);\n    });\n    DEF(AST_Block, function(self, tw) {\n        self.body = do_list(self.body, tw);\n    });\n    DEF(AST_Do, function(self, tw) {\n        self.body = self.body.transform(tw);\n        self.condition = self.condition.transform(tw);\n    });\n    DEF(AST_While, function(self, tw) {\n        self.condition = self.condition.transform(tw);\n        self.body = self.body.transform(tw);\n    });\n    DEF(AST_For, function(self, tw) {\n        if (self.init) self.init = self.init.transform(tw);\n        if (self.condition) self.condition = self.condition.transform(tw);\n        if (self.step) self.step = self.step.transform(tw);\n        self.body = self.body.transform(tw);\n    });\n    DEF(AST_ForIn, function(self, tw) {\n        self.init = self.init.transform(tw);\n        self.object = self.object.transform(tw);\n        self.body = self.body.transform(tw);\n    });\n    DEF(AST_With, function(self, tw) {\n        self.expression = self.expression.transform(tw);\n        self.body = self.body.transform(tw);\n    });\n    DEF(AST_Exit, function(self, tw) {\n        if (self.value) self.value = self.value.transform(tw);\n    });\n    DEF(AST_LoopControl, function(self, tw) {\n        if (self.label) self.label = self.label.transform(tw);\n    });\n    DEF(AST_If, function(self, tw) {\n        self.condition = self.condition.transform(tw);\n        self.body = self.body.transform(tw);\n        if (self.alternative) self.alternative = self.alternative.transform(tw);\n    });\n    DEF(AST_Switch, function(self, tw) {\n        self.expression = self.expression.transform(tw);\n        self.body = do_list(self.body, tw);\n    });\n    DEF(AST_Case, function(self, tw) {\n        self.expression = self.expression.transform(tw);\n        self.body = do_list(self.body, tw);\n    });\n    DEF(AST_Try, function(self, tw) {\n        self.body = do_list(self.body, tw);\n        if (self.bcatch) self.bcatch = self.bcatch.transform(tw);\n        if (self.bfinally) self.bfinally = self.bfinally.transform(tw);\n    });\n    DEF(AST_Catch, function(self, tw) {\n        if (self.argname) self.argname = self.argname.transform(tw);\n        self.body = do_list(self.body, tw);\n    });\n    DEF(AST_Definitions, function(self, tw) {\n        self.definitions = do_list(self.definitions, tw);\n    });\n    DEF(AST_VarDef, function(self, tw) {\n        self.name = self.name.transform(tw);\n        if (self.value) self.value = self.value.transform(tw);\n    });\n    DEF(AST_DefaultValue, function(self, tw) {\n        self.name = self.name.transform(tw);\n        self.value = self.value.transform(tw);\n    });\n    DEF(AST_Lambda, function(self, tw) {\n        if (self.name) self.name = self.name.transform(tw);\n        self.argnames = do_list(self.argnames, tw);\n        self.body = do_list(self.body, tw);\n    });\n    DEF(AST_Arrow, function(self, tw) {\n        self.argnames = do_list(self.argnames, tw);\n        if (self.value) {\n            self.value = self.value.transform(tw);\n        } else {\n            self.body = do_list(self.body, tw);\n        }\n    });\n    DEF(AST_Call, function(self, tw) {\n        self.expression = self.expression.transform(tw);\n        self.args = do_list(self.args, tw);\n    });\n    DEF(AST_Sequence, function(self, tw) {\n        self.expressions = do_list(self.expressions, tw);\n    });\n    DEF(AST_Await, function(self, tw) {\n        self.expression = self.expression.transform(tw);\n    });\n    DEF(AST_Dot, function(self, tw) {\n        self.expression = self.expression.transform(tw);\n    });\n    DEF(AST_Sub, function(self, tw) {\n        self.expression = self.expression.transform(tw);\n        self.property = self.property.transform(tw);\n    });\n    DEF(AST_Spread, function(self, tw) {\n        self.expression = self.expression.transform(tw);\n    });\n    DEF(AST_Unary, function(self, tw) {\n        self.expression = self.expression.transform(tw);\n    });\n    DEF(AST_Binary, function(self, tw) {\n        self.left = self.left.transform(tw);\n        self.right = self.right.transform(tw);\n    });\n    DEF(AST_Conditional, function(self, tw) {\n        self.condition = self.condition.transform(tw);\n        self.consequent = self.consequent.transform(tw);\n        self.alternative = self.alternative.transform(tw);\n    });\n    DEF(AST_Array, function(self, tw) {\n        self.elements = do_list(self.elements, tw);\n    });\n    DEF(AST_DestructuredArray, function(self, tw) {\n        self.elements = do_list(self.elements, tw);\n    });\n    DEF(AST_DestructuredKeyVal, function(self, tw) {\n        if (self.key instanceof AST_Node) self.key = self.key.transform(tw);\n        self.value = self.value.transform(tw);\n    });\n    DEF(AST_DestructuredObject, function(self, tw) {\n        self.properties = do_list(self.properties, tw);\n    });\n    DEF(AST_Object, function(self, tw) {\n        self.properties = do_list(self.properties, tw);\n    });\n    DEF(AST_ObjectProperty, function(self, tw) {\n        if (self.key instanceof AST_Node) self.key = self.key.transform(tw);\n        self.value = self.value.transform(tw);\n    });\n})(function(node, descend) {\n    node.DEFMETHOD(\"transform\", function(tw, in_list) {\n        var x, y;\n        tw.push(this);\n        if (tw.before) x = tw.before(this, descend, in_list);\n        if (typeof x === \"undefined\") {\n            x = this;\n            descend(x, tw);\n            if (tw.after) {\n                y = tw.after(x, in_list);\n                if (typeof y !== \"undefined\") x = y;\n            }\n        }\n        tw.pop();\n        return x;\n    });\n});\n","/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\n\"use strict\";\n\nfunction characters(str) {\n    return str.split(\"\");\n}\n\nfunction member(name, array) {\n    return array.indexOf(name) >= 0;\n}\n\nfunction find_if(func, array) {\n    for (var i = array.length; --i >= 0;) if (func(array[i])) return array[i];\n}\n\nfunction repeat_string(str, i) {\n    if (i <= 0) return \"\";\n    if (i == 1) return str;\n    var d = repeat_string(str, i >> 1);\n    d += d;\n    return i & 1 ? d + str : d;\n}\n\nfunction configure_error_stack(fn) {\n    Object.defineProperty(fn.prototype, \"stack\", {\n        get: function() {\n            var err = new Error(this.message);\n            err.name = this.name;\n            try {\n                throw err;\n            } catch (e) {\n                return e.stack;\n            }\n        }\n    });\n}\n\nfunction DefaultsError(msg, defs) {\n    this.message = msg;\n    this.defs = defs;\n}\nDefaultsError.prototype = Object.create(Error.prototype);\nDefaultsError.prototype.constructor = DefaultsError;\nDefaultsError.prototype.name = \"DefaultsError\";\nconfigure_error_stack(DefaultsError);\n\nfunction defaults(args, defs, croak) {\n    if (croak) for (var i in args) {\n        if (HOP(args, i) && !HOP(defs, i)) throw new DefaultsError(\"`\" + i + \"` is not a supported option\", defs);\n    }\n    for (var i in args) {\n        if (HOP(args, i)) defs[i] = args[i];\n    }\n    return defs;\n}\n\nfunction merge(obj, ext) {\n    var count = 0;\n    for (var i in ext) if (HOP(ext, i)) {\n        obj[i] = ext[i];\n        count++;\n    }\n    return count;\n}\n\nfunction noop() {}\nfunction return_false() { return false; }\nfunction return_true() { return true; }\nfunction return_this() { return this; }\nfunction return_null() { return null; }\n\nvar List = (function() {\n    function List(a, f) {\n        var ret = [];\n        for (var i = 0; i < a.length; i++) {\n            var val = f(a[i], i);\n            if (val === skip) continue;\n            if (val instanceof Splice) {\n                ret.push.apply(ret, val.v);\n            } else {\n                ret.push(val);\n            }\n        }\n        return ret;\n    }\n    List.is_op = function(val) {\n        return val === skip || val instanceof Splice;\n    };\n    List.splice = function(val) {\n        return new Splice(val);\n    };\n    var skip = List.skip = {};\n    function Splice(val) {\n        this.v = val;\n    }\n    return List;\n})();\n\nfunction push_uniq(array, el) {\n    if (array.indexOf(el) < 0) return array.push(el);\n}\n\nfunction string_template(text, props) {\n    return text.replace(/\\{([^}]+)\\}/g, function(str, p) {\n        var value = props[p];\n        return value instanceof AST_Node ? value.print_to_string() : value;\n    });\n}\n\nfunction remove(array, el) {\n    var index = array.indexOf(el);\n    if (index >= 0) array.splice(index, 1);\n}\n\nfunction makePredicate(words) {\n    if (!Array.isArray(words)) words = words.split(\" \");\n    var map = Object.create(null);\n    words.forEach(function(word) {\n        map[word] = true;\n    });\n    return map;\n}\n\nfunction all(array, predicate) {\n    for (var i = array.length; --i >= 0;)\n        if (!predicate(array[i], i))\n            return false;\n    return true;\n}\n\nfunction Dictionary() {\n    this._values = Object.create(null);\n    this._size = 0;\n}\nDictionary.prototype = {\n    set: function(key, val) {\n        if (!this.has(key)) ++this._size;\n        this._values[\"$\" + key] = val;\n        return this;\n    },\n    add: function(key, val) {\n        if (this.has(key)) {\n            this.get(key).push(val);\n        } else {\n            this.set(key, [ val ]);\n        }\n        return this;\n    },\n    get: function(key) { return this._values[\"$\" + key] },\n    del: function(key) {\n        if (this.has(key)) {\n            --this._size;\n            delete this._values[\"$\" + key];\n        }\n        return this;\n    },\n    has: function(key) { return (\"$\" + key) in this._values },\n    all: function(predicate) {\n        for (var i in this._values)\n            if (!predicate(this._values[i], i.substr(1)))\n                return false;\n        return true;\n    },\n    each: function(f) {\n        for (var i in this._values)\n            f(this._values[i], i.substr(1));\n    },\n    size: function() {\n        return this._size;\n    },\n    map: function(f) {\n        var ret = [];\n        for (var i in this._values)\n            ret.push(f(this._values[i], i.substr(1)));\n        return ret;\n    },\n    clone: function() {\n        var ret = new Dictionary();\n        for (var i in this._values)\n            ret._values[i] = this._values[i];\n        ret._size = this._size;\n        return ret;\n    },\n    toObject: function() { return this._values }\n};\nDictionary.fromObject = function(obj) {\n    var dict = new Dictionary();\n    dict._size = merge(dict._values, obj);\n    return dict;\n};\n\nfunction HOP(obj, prop) {\n    return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\n// return true if the node at the top of the stack (that means the\n// innermost node in the current output) is lexically the first in\n// a statement.\nfunction first_in_statement(stack, arrow) {\n    var node = stack.parent(-1);\n    for (var i = 0, p; p = stack.parent(i++); node = p) {\n        if (p instanceof AST_Arrow) {\n            return arrow && p.value === node;\n        } else if (p instanceof AST_Binary) {\n            if (p.left === node) continue;\n        } else if (p.TYPE == \"Call\") {\n            if (p.expression === node) continue;\n        } else if (p instanceof AST_Conditional) {\n            if (p.condition === node) continue;\n        } else if (p instanceof AST_PropAccess) {\n            if (p.expression === node) continue;\n        } else if (p instanceof AST_Sequence) {\n            if (p.expressions[0] === node) continue;\n        } else if (p instanceof AST_Statement) {\n            return p.body === node;\n        } else if (p instanceof AST_UnaryPostfix) {\n            if (p.expression === node) continue;\n        }\n        return false;\n    }\n}\n","exports[\"Dictionary\"] = Dictionary;\nexports[\"List\"] = List;\nexports[\"minify\"] = minify;\nexports[\"parse\"] = parse;\nexports[\"push_uniq\"] = push_uniq;\nexports[\"TreeTransformer\"] = TreeTransformer;\nexports[\"TreeWalker\"] = TreeWalker;\n","var fs = require(\"fs\");\n\nexports.FILES = [\n    require.resolve(\"../lib/utils.js\"),\n    require.resolve(\"../lib/ast.js\"),\n    require.resolve(\"../lib/parse.js\"),\n    require.resolve(\"../lib/transform.js\"),\n    require.resolve(\"../lib/scope.js\"),\n    require.resolve(\"../lib/output.js\"),\n    require.resolve(\"../lib/compress.js\"),\n    require.resolve(\"../lib/sourcemap.js\"),\n    require.resolve(\"../lib/mozilla-ast.js\"),\n    require.resolve(\"../lib/propmangle.js\"),\n    require.resolve(\"../lib/minify.js\"),\n    require.resolve(\"./exports.js\"),\n];\n\nnew Function(\"exports\", function() {\n    var code = exports.FILES.map(function(file) {\n        return fs.readFileSync(file, \"utf8\");\n    });\n    code.push(\"exports.describe_ast = \" + describe_ast.toString());\n    return code.join(\"\\n\\n\");\n}())(exports);\n\nfunction describe_ast() {\n    var out = OutputStream({ beautify: true });\n    function doitem(ctor) {\n        out.print(\"AST_\" + ctor.TYPE);\n        var props = ctor.SELF_PROPS.filter(function(prop) {\n            return !/^\\$/.test(prop);\n        });\n        if (props.length > 0) {\n            out.space();\n            out.with_parens(function() {\n                props.forEach(function(prop, i) {\n                    if (i) out.space();\n                    out.print(prop);\n                });\n            });\n        }\n        if (ctor.documentation) {\n            out.space();\n            out.print_string(ctor.documentation);\n        }\n        if (ctor.SUBCLASSES.length > 0) {\n            out.space();\n            out.with_block(function() {\n                ctor.SUBCLASSES.sort(function(a, b) {\n                    return a.TYPE < b.TYPE ? -1 : 1;\n                }).forEach(function(ctor, i) {\n                    out.indent();\n                    doitem(ctor);\n                    out.newline();\n                });\n            });\n        }\n    };\n    doitem(AST_Node);\n    return out + \"\\n\";\n}\n\nfunction infer_options(options) {\n    var result = exports.minify(\"\", options);\n    return result.error && result.error.defs;\n}\n\nexports.default_options = function() {\n    var defs = infer_options({ 0: 0 });\n    Object.keys(defs).forEach(function(component) {\n        var options = {};\n        options[component] = { 0: 0 };\n        if (options = infer_options(options)) {\n            defs[component] = options;\n        }\n    });\n    return defs;\n};\n","'use strict'\n\nexports.fromCallback = function (fn) {\n  return Object.defineProperty(function (...args) {\n    if (typeof args[args.length - 1] === 'function') fn.apply(this, args)\n    else {\n      return new Promise((resolve, reject) => {\n        fn.apply(\n          this,\n          args.concat([(err, res) => err ? reject(err) : resolve(res)])\n        )\n      })\n    }\n  }, 'name', { value: fn.name })\n}\n\nexports.fromPromise = function (fn) {\n  return Object.defineProperty(function (...args) {\n    const cb = args[args.length - 1]\n    if (typeof cb !== 'function') return fn.apply(this, args)\n    else fn.apply(this, args.slice(0, -1)).then(r => cb(null, r), cb)\n  }, 'name', { value: fn.name })\n}\n","module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n","// Returns a wrapper function that returns a wrapped callback\n// The wrapper function should do some stuff, and return a\n// presumably different callback function.\n// This makes sure that own properties are retained, so that\n// decorations and such are not lost along the way.\nmodule.exports = wrappy\nfunction wrappy (fn, cb) {\n  if (fn && cb) return wrappy(fn)(cb)\n\n  if (typeof fn !== 'function')\n    throw new TypeError('need wrapper function')\n\n  Object.keys(fn).forEach(function (k) {\n    wrapper[k] = fn[k]\n  })\n\n  return wrapper\n\n  function wrapper() {\n    var args = new Array(arguments.length)\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i]\n    }\n    var ret = fn.apply(this, args)\n    var cb = args[args.length-1]\n    if (typeof ret === 'function' && ret !== cb) {\n      Object.keys(cb).forEach(function (k) {\n        ret[k] = cb[k]\n      })\n    }\n    return ret\n  }\n}\n","module.exports = require('./src/wxml2json');\n","\r\n/**\r\n * \r\n * wxmlParser改造自: https://github.com/blowsie/Pure-JavaScript-HTML5-Parser\r\n * \r\n * author: Kali-Hac(好葱)\r\n * organization: SCUT\r\n * \r\n * github地址: https://github.com/Kali-Hac\r\n * \r\n * for: 微信小程序wxml解析\r\n * detail : wxmlParser库是基于htmlParser库写的，保留原作者的注释\r\n */\r\n/*\r\n * HTML5 Parser By Sam Blowes\r\n *\r\n * Designed for HTML5 documents\r\n *\r\n * Original code by John Resig (ejohn.org)\r\n * http://ejohn.org/blog/pure-javascript-html-parser/\r\n * Original code by Erik Arvidsson, Mozilla Public License\r\n * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js\r\n *\r\n * ----------------------------------------------------------------------------\r\n * License\r\n * ----------------------------------------------------------------------------\r\n *\r\n * This code is triple licensed using Apache Software License 2.0,\r\n * Mozilla Public License or GNU Public License\r\n * \r\n * ////////////////////////////////////////////////////////////////////////////\r\n * \r\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\r\n * use this file except in compliance with the License.  You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n * \r\n * ////////////////////////////////////////////////////////////////////////////\r\n * \r\n * The contents of this file are subject to the Mozilla Public License\r\n * Version 1.1 (the \"License\"); you may not use this file except in\r\n * compliance with the License. You may obtain a copy of the License at\r\n * http://www.mozilla.org/MPL/\r\n * \r\n * Software distributed under the License is distributed on an \"AS IS\"\r\n * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing rights and limitations\r\n * under the License.\r\n * \r\n * The Original Code is Simple HTML Parser.\r\n * \r\n * The Initial Developer of the Original Code is Erik Arvidsson.\r\n * Portions created by Erik Arvidssson are Copyright (C) 2004. All Rights\r\n * Reserved.\r\n * \r\n * ////////////////////////////////////////////////////////////////////////////\r\n * \r\n * This program is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU General Public License\r\n * as published by the Free Software Foundation; either version 2\r\n * of the License, or (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\r\n *\r\n * ----------------------------------------------------------------------------\r\n * Usage\r\n * ----------------------------------------------------------------------------\r\n *\r\n * // Use like so:\r\n * HTMLParser(htmlString, {\r\n *     start: function(tag, attrs, unary) {},\r\n *     end: function(tag) {},\r\n *     chars: function(text) {},\r\n *     comment: function(text) {}\r\n * });\r\n *\r\n * // or to get an XML string:\r\n * HTMLtoXML(htmlString);\r\n *\r\n * // or to get an XML DOM Document\r\n * HTMLtoDOM(htmlString);\r\n *\r\n * // or to inject into an existing document/DOM node\r\n * HTMLtoDOM(htmlString, document);\r\n * HTMLtoDOM(htmlString, document.body);\r\n *\r\n */\r\n\r\n(function () {\r\n\t\r\n\t//Crucial Change\r\n\t// Regular Expressions for parsing tags and attributes\r\n\t//这里的startTag和attr不需要改，在2sjon文件里改就可以了\r\n\tvar startTag = /^<([-A-Za-z0-9_]+)((?:\\s+[a-zA-Z_:][-a-zA-Z0-9_:.]*(?:\\s*=\\s*(?:(?:\"[^\"]*\")|(?:'[^']*')|[^>\\s]+))?)*)\\s*(\\/?)>/,\r\n\t\tendTag = /^<\\/([-A-Za-z0-9_]+)[^>]*>/,\r\n\t\tattr = /([a-zA-Z_:][-a-zA-Z0-9_:.]*)(?:\\s*=\\s*(?:(?:\"((?:\\\\.|[^\"])*)\")|(?:'((?:\\\\.|[^'])*)')|([^>\\s]+)))?/g;\r\n\r\n\t//Crucial Change\r\n\t// Empty Elements - HTML 5\r\n\tvar empty = makeMap(\"input,image,map\");\r\n\t// empty = makeMap(\"view,scrollview,swiper,icon,text,progress,button,action-sheet,form,modal,input,progress,checkbox,toast,radio,picker,slider,navigator,switch,label,audio,map,image,video,canvas\");\r\n\t// Block Elements - HTML 5\r\n\tvar block = makeMap(\"block,view,scrollview,swiper,icon,text,progress,button,action-sheet,form,modal,input,progress,checkbox,toast,radio,picker,slider,navigator,switch,label,audio,map,image,video,canvas\");\r\n\r\n\t// Inline Elements - HTML 5\r\n\tvar inline = makeMap(\"icon,progress,button,input,image,map\");\r\n\t// inline = makeMap(\"view,scrollview,swiper,icon,text,progress,button,action-sheet,form,modal,input,progress,checkbox,toast,radio,picker,slider,navigator,switch,label,audio,map,image,video,canvas\");\r\n\t// Elements that you can, intentionally, leave open\r\n\t// (and which close themselves)\r\n\t//微信小程序里没有可以不闭合的标签\r\n\tvar closeSelf = makeMap(\"\");\r\n\r\n\t// Attributes that have their values filled in disabled=\"disabled\"\r\n\t//填充的属性可以后面再解析出来\r\n\tvar fillAttrs = makeMap(\"\");\r\n\r\n\t// Special Elements (can contain anything)\r\n\tvar special = makeMap(\"wxxxcode-style,script,style\");\r\n\r\n\tvar HTMLParser = this.HTMLParser = function (html, handler) {\r\n\t\tvar index, chars, match, stack = [], last = html;\r\n\t\tstack.last = function () {\r\n\t\t\treturn this[this.length - 1];\r\n\t\t};\r\n\r\n\t\twhile (html) {\r\n\t\t\tchars = true;\r\n\r\n\t\t\t// Make sure we're not in a script or style element\r\n\t\t\tif (!stack.last() || !special[stack.last()]) {\r\n\r\n\t\t\t\t// Comment\r\n\t\t\t\tif (html.indexOf(\"<!--\") == 0) {\r\n\t\t\t\t\tindex = html.indexOf(\"-->\");\r\n\t\t\t\t\tif (index >= 0) {\r\n\t\t\t\t\t\tif (handler.comment)\r\n\t\t\t\t\t\t\thandler.comment(html.substring(4, index));\r\n\t\t\t\t\t\thtml = html.substring(index + 3);\r\n\t\t\t\t\t\tchars = false;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// end tag\r\n\t\t\t\t} else if (html.indexOf(\"</\") == 0) {\r\n\t\t\t\t\tmatch = html.match(endTag);\r\n\r\n\t\t\t\t\tif (match) {\r\n\t\t\t\t\t\thtml = html.substring(match[0].length);\r\n\t\t\t\t\t\tmatch[0].replace(endTag, parseEndTag);\r\n\t\t\t\t\t\tchars = false;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// start tag\r\n\t\t\t\t} else if (html.indexOf(\"<\") == 0) {\r\n\t\t\t\t\tmatch = html.match(startTag);\r\n\r\n\t\t\t\t\tif (match) {\r\n\t\t\t\t\t\thtml = html.substring(match[0].length);\r\n\t\t\t\t\t\tmatch[0].replace(startTag, parseStartTag);\r\n\t\t\t\t\t\tchars = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (chars) {\r\n\t\t\t\t\tindex = html.indexOf(\"<\");\r\n\r\n\t\t\t\t\tvar text = index < 0 ? html : html.substring(0, index);\r\n\t\t\t\t\thtml = index < 0 ? \"\" : html.substring(index);\r\n\r\n\t\t\t\t\tif (handler.chars)\r\n\t\t\t\t\t\thandler.chars(text);\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\t\t\t\thtml = html.replace(new RegExp(\"([\\\\s\\\\S]*?)<\\/\" + stack.last() + \"[^>]*>\"), function (all, text) {\r\n\t\t\t\t\ttext = text.replace(/<!--([\\s\\S]*?)-->|<!\\[CDATA\\[([\\s\\S]*?)]]>/g, \"$1$2\");\r\n\t\t\t\t\tif (handler.chars)\r\n\t\t\t\t\t\thandler.chars(text);\r\n\r\n\t\t\t\t\treturn \"\";\r\n\t\t\t\t});\r\n\r\n\t\t\t\tparseEndTag(\"\", stack.last());\r\n\t\t\t}\r\n\r\n\t\t\tif (html == last){\r\n\t\t\t\t// console.log(html)\r\n\t\t\t\tthrow \"Parse Error: \" + html;\r\n\t\t\t}\r\n\t\t\tlast = html;\r\n\t\t}\r\n\r\n\t\t// Clean up any remaining tags\r\n\t\tparseEndTag();\r\n\r\n\t\tfunction parseStartTag(tag, tagName, rest, unary) {\r\n\t\t\ttagName = tagName.toLowerCase();\r\n\r\n\t\t\tif (block[tagName]) {\r\n\t\t\t\twhile (stack.last() && inline[stack.last()]) {\r\n\t\t\t\t\tparseEndTag(\"\", stack.last());\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (closeSelf[tagName] && stack.last() == tagName) {\r\n\t\t\t\tparseEndTag(\"\", tagName);\r\n\t\t\t}\r\n\r\n\t\t\tunary = empty[tagName] || !!unary;\r\n\r\n\t\t\tif (!unary)\r\n\t\t\t\tstack.push(tagName);\r\n\r\n\t\t\tif (handler.start) {\r\n\t\t\t\tvar attrs = [];\r\n\r\n\t\t\t\trest.replace(attr, function (match, name) {\r\n\t\t\t\t\tvar value = arguments[2] ? arguments[2] :\r\n\t\t\t\t\t\targuments[3] ? arguments[3] :\r\n\t\t\t\t\t\targuments[4] ? arguments[4] :\r\n\t\t\t\t\t\tfillAttrs[name] ? name : \"\";\r\n\r\n\t\t\t\t\tattrs.push({\r\n\t\t\t\t\t\tname: name,\r\n\t\t\t\t\t\tvalue: value,\r\n\t\t\t\t\t\tescaped: value.replace(/(^|[^\\\\])\"/g, '$1\\\\\\\"') //\"\r\n\t\t\t\t\t});\r\n\t\t\t\t});\r\n\r\n\t\t\t\tif (handler.start)\r\n\t\t\t\t\thandler.start(tagName, attrs, unary);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction parseEndTag(tag, tagName) {\r\n\t\t\t// If no tag name is provided, clean shop\r\n\t\t\tif (!tagName)\r\n\t\t\t\tvar pos = 0;\r\n\r\n\t\t\t\t// Find the closest opened tag of the same type\r\n\t\t\telse\r\n\t\t\t\tfor (var pos = stack.length - 1; pos >= 0; pos--)\r\n\t\t\t\t\tif (stack[pos] == tagName)\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\tif (pos >= 0) {\r\n\t\t\t\t// Close all the open elements, up the stack\r\n\t\t\t\tfor (var i = stack.length - 1; i >= pos; i--)\r\n\t\t\t\t\tif (handler.end)\r\n\t\t\t\t\t\thandler.end(stack[i]);\r\n\r\n\t\t\t\t// Remove the open elements from the stack\r\n\t\t\t\tstack.length = pos;\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tthis.HTMLtoXML = function (html) {\r\n\t\tvar results = \"\";\r\n\r\n\t\tHTMLParser(html, {\r\n\t\t\tstart: function (tag, attrs, unary) {\r\n\t\t\t\tresults += \"<\" + tag;\r\n\r\n\t\t\t\tfor (var i = 0; i < attrs.length; i++)\r\n\t\t\t\t\tresults += \" \" + attrs[i].name + '=\"' + attrs[i].escaped + '\"';\r\n\t\t\t\tresults += \">\";\r\n\t\t\t},\r\n\t\t\tend: function (tag) {\r\n\t\t\t\tresults += \"</\" + tag + \">\";\r\n\t\t\t},\r\n\t\t\tchars: function (text) {\r\n\t\t\t\tresults += text;\r\n\t\t\t},\r\n\t\t\tcomment: function (text) {\r\n\t\t\t\tresults += \"<!--\" + text + \"-->\";\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn results;\r\n\t};\r\n\r\n\tthis.HTMLtoDOM = function (html, doc) {\r\n\t\t// There can be only one of these elements\r\n\t\tvar one = makeMap(\"html,head,body,title\");\r\n\r\n\t\t// Enforce a structure for the document\r\n\t\tvar structure = {\r\n\t\t\tlink: \"head\",\r\n\t\t\tbase: \"head\"\r\n\t\t};\r\n\r\n\t\tif (!doc) {\r\n\t\t\tif (typeof DOMDocument != \"undefined\")\r\n\t\t\t\tdoc = new DOMDocument();\r\n\t\t\telse if (typeof document != \"undefined\" && document.implementation && document.implementation.createDocument)\r\n\t\t\t\tdoc = document.implementation.createDocument(\"\", \"\", null);\r\n\t\t\telse if (typeof ActiveX != \"undefined\")\r\n\t\t\t\tdoc = new ActiveXObject(\"Msxml.DOMDocument\");\r\n\r\n\t\t} else\r\n\t\t\tdoc = doc.ownerDocument ||\r\n\t\t\t\tdoc.getOwnerDocument && doc.getOwnerDocument() ||\r\n\t\t\t\tdoc;\r\n\r\n\t\tvar elems = [],\r\n\t\t\tdocumentElement = doc.documentElement ||\r\n\t\t\t\tdoc.getDocumentElement && doc.getDocumentElement();\r\n\r\n\t\t// If we're dealing with an empty document then we\r\n\t\t// need to pre-populate it with the HTML document structure\r\n\t\tif (!documentElement && doc.createElement) (function () {\r\n\t\t\tvar html = doc.createElement(\"html\");\r\n\t\t\tvar head = doc.createElement(\"head\");\r\n\t\t\thead.appendChild(doc.createElement(\"title\"));\r\n\t\t\thtml.appendChild(head);\r\n\t\t\thtml.appendChild(doc.createElement(\"body\"));\r\n\t\t\tdoc.appendChild(html);\r\n\t\t})();\r\n\r\n\t\t// Find all the unique elements\r\n\t\tif (doc.getElementsByTagName)\r\n\t\t\tfor (var i in one)\r\n\t\t\t\tone[i] = doc.getElementsByTagName(i)[0];\r\n\r\n\t\t// If we're working with a document, inject contents into\r\n\t\t// the body element\r\n\t\tvar curParentNode = one.body;\r\n\r\n\t\tHTMLParser(html, {\r\n\t\t\tstart: function (tagName, attrs, unary) {\r\n\t\t\t\t// If it's a pre-built element, then we can ignore\r\n\t\t\t\t// its construction\r\n\t\t\t\tif (one[tagName]) {\r\n\t\t\t\t\tcurParentNode = one[tagName];\r\n\t\t\t\t\tif (!unary) {\r\n\t\t\t\t\t\telems.push(curParentNode);\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar elem = doc.createElement(tagName);\r\n\r\n\t\t\t\tfor (var attr in attrs)\r\n\t\t\t\t\telem.setAttribute(attrs[attr].name, attrs[attr].value);\r\n\r\n\t\t\t\tif (structure[tagName] && typeof one[structure[tagName]] != \"boolean\")\r\n\t\t\t\t\tone[structure[tagName]].appendChild(elem);\r\n\r\n\t\t\t\telse if (curParentNode && curParentNode.appendChild)\r\n\t\t\t\t\tcurParentNode.appendChild(elem);\r\n\r\n\t\t\t\tif (!unary) {\r\n\t\t\t\t\telems.push(elem);\r\n\t\t\t\t\tcurParentNode = elem;\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tend: function (tag) {\r\n\t\t\t\telems.length -= 1;\r\n\r\n\t\t\t\t// Init the new parentNode\r\n\t\t\t\tcurParentNode = elems[elems.length - 1];\r\n\t\t\t},\r\n\t\t\tchars: function (text) {\r\n\t\t\t\tcurParentNode.appendChild(doc.createTextNode(text));\r\n\t\t\t},\r\n\t\t\tcomment: function (text) {\r\n\t\t\t\t// create comment node\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn doc;\r\n\t};\r\n\r\n\tfunction makeMap(str) {\r\n\t\tvar obj = {}, items = str.split(\",\");\r\n\t\tfor (var i = 0; i < items.length; i++)\r\n\t\t\tobj[items[i]] = true;\r\n\t\treturn obj;\r\n\t}\r\n})();\r\n","\n/**\n * \n * wxml2json改造自: https://github.com/Jxck/html2json\n * \n * author: Kali-Hac(好葱)\n * organization: SCUT\n * \n * github地址: https://github.com/Kali-Hac\n * \n * for: 微信小程序wxml解析\n * detail : wxml2json库是基于html2json库写的，保留原作者的注释\n */\n(function(global) {\n  DEBUG = false;\n  var debug = DEBUG ? console.log.bind(console) : function(){};\n\n  if (typeof module === 'object' && typeof module.exports === 'object') {\n    require('../lib/Pure-JavaScript-HTML5-Parser/wxmlparser.js');\n  }\n\n  function q(v) {\n    return '\"' + v + '\"';\n  }\n\n  //Crucial Change\n  function removeDOCTYPE(html) {\n    return html\n      .replace(/<\\?xml.*\\?>\\n/, '')\n      .replace(/<!doctype.*\\>/i, '')\n      .replace(/<!DOCTYPE.*\\>/, '');\n  }\n\n  global.wxml2json = function wxml2json(html) {\n    html = removeDOCTYPE(html);\n    var bufArray = [];\n    var results = {\n      type: 'root',\n      children: [],\n    };\n    HTMLParser(html, {\n      start: function(tag, attrs, unary) {\n        debug(tag, attrs, unary);\n        // type for this element\n        var type = {\n          type: 'element',\n          tag: tag,\n        };\n        if (attrs.length !== 0) {\n          type.attr = attrs.reduce(function(pre, attr) {\n            var name = attr.name;\n            var value = attr.value;\n\n            // has multi attibutes\n            // make it array of attribute\n\n            //Crucial Change\n            // 微信小程序的属性里面可以有变量及代码，可以有空格\n            // if (value.match(/ /)) {\n            //   value = value.split(' ');\n            // }\n\n            // if attr already exists\n            // merge it\n            if (pre[name]) {\n              if (Array.isArray(pre[name])) {\n                // already array, push to last\n                pre[name].push(value);\n              } else {\n                // single value, make it array\n                pre[name] = [pre[name], value];\n              }\n            } else {\n              // not exist, put it\n              pre[name] = value;\n            }\n\n            return pre;\n          }, {});\n        }\n        if (unary) {\n          // if this tag dosen't have end tag\n          // like <img src=\"hoge.png\"/>\n          // add to parents\n          var parent = bufArray[0] || results;\n          if (parent.children === undefined) {\n            parent.children = [];\n          }\n          parent.children.push(type);\n        } else {\n          bufArray.unshift(type);\n        }\n      },\n      end: function(tag) {\n        debug(tag);\n        // merge into parent tag\n        var type = bufArray.shift();\n        if (type.tag !== tag) console.error('invalid state: mismatch end tag');\n\n        if (bufArray.length === 0) {\n          results.children.push(type);\n        } else {\n          var parent = bufArray[0];\n          if (parent.children === undefined) {\n            parent.children = [];\n          }\n          parent.children.push(type);\n        }\n      },\n      chars: function(text) {\n        debug(text);\n        var type = {\n          type: 'text',\n          text: text,\n        };\n        if (bufArray.length === 0) {\n          //Crucial Change\n          if(type.text.replace(/ /g, '').replace(/\\r/g, '').replace(/\\n/g, '').replace(/\\t/g, '') !=='' && type.text!=='')\n            results.children.push(type);\n        } else {\n          var parent = bufArray[0];\n          if (parent.children === undefined) {\n            parent.children = [];\n          }\n          //都为空格时不加入节点\n          //Crucial Change\n          if(type.text.replace(/ /g, '').replace(/\\r/g, '').replace(/\\n/g, '').replace(/\\t/g, '') !=='' && type.text!=='')\n            parent.children.push(type);\n        }\n      },\n      comment: function(text) {\n        debug(text);\n        var type = {\n          type: 'comment',\n          text: text,\n        };\n        var parent = bufArray[0];\n        //Crucial Change\n        parent = parent || []\n        if (parent.children === undefined) {\n          parent.children = [];\n        }\n        parent.children.push(type);\n      },\n    });\n    return results;\n  };\n\n  global.json2wxml = function json2wxml(json) {\n    // Empty Elements - HTML 4.01\n    var empty = ['area', 'base', 'basefont', 'br', 'col', 'frame', 'hr', 'image', 'input', 'isindex', 'link', 'meta', 'param', 'embed'];\n\n    var children = '';\n    if (json.children) {\n      children = json.children.map(function(c) {\n        return json2wxml(c);\n      }).join('');\n    }\n\n    var attr = '';\n    if (json.attr) {\n      attr = Object.keys(json.attr).map(function(key) {\n        var value = json.attr[key];\n        if (Array.isArray(value)) value = value.join(' ');\n        return key + '=' + q(value);\n      }).join(' ');\n      if (attr !== '') attr = ' ' + attr;\n    }\n\n    if (json.type === 'element') {\n      var tag = json.tag;\n      if (empty.indexOf(tag) > -1) {\n        // empty element\n        // Crucial Change\n        return '<' + json.tag + attr + '/>\\n';\n      }\n\n      // non empty element\n      // Crucial Change\n      var open = '<' + json.tag + attr + '>\\n';\n      var close = '</' + json.tag + '>\\n';\n      // Crucial Change\n      return open + children + close + '\\n';\n    }\n      // Crucial Change\n    if (json.type === 'text') {\n      return json.text + '\\n';\n    }\n      // Crucial Change\n    if (json.type === 'comment') {\n      return '<!--' + json.text + '-->\\n';\n    }\n\n    if (json.type === 'root') {\n      return children;\n    }\n  };\n})(this);\n","export * from './src';\n","export * from './taro';\n","import { writeFileSync } from 'fs-extra';\n\n\n/**\n * taro框架的文件管理器\n */\nexport class TaroFileManager {\n  // 所有文件路径列表\n  private fileNameList: string[] = [];\n  // 所有文件列表\n  private fileList: any[] = [];\n  // taro原始资源对象\n  private assets: any;\n  // taro编译环境的所有信息\n  private ctx: any;\n\n  constructor(ctx: any) {\n    this.assets = ctx.compilation.assets;\n    this.ctx = ctx;\n    this.initial();\n  }\n\n  /**\n   * 更新编译配置，当taro处于开发模式并且用户修改代码后将会被调用，用以更新编译配置\n   * @param ctx\n   */\n  public updateCtx(ctx: any) {\n    this.ctx = ctx;\n    this.assets = ctx.compilation.assets;\n  }\n\n  /**\n   * 进行一些数据的初始化\n   */\n  private initial() {\n    this.fileNameList = Object.keys(this.assets);\n    this.fileList = this.fileNameList.map(key => this.assets[key]);\n  }\n\n  /**\n   * 根据文件类型查询文件\n   * @param {string | RegExp} type    文件类型，即包含指定字符串或满足正则表达式的文件路径\n   * @param {boolean} exact           是否完全匹配，若为true,必须整个路径等于type才能匹配\n   * @returns {string[]}\n   */\n  private getFileNamesByType(type: string | RegExp, exact = false): string[] {\n    return this.fileNameList.filter(fileName => {\n      if (typeof type === 'string') {\n        if (exact) {\n          return fileName === type;\n        } else {\n          return fileName.indexOf(fileName) >= 0;\n        }\n      } else {\n        return type.exec(fileName);\n      }\n    });\n  }\n\n  /**\n   * 获取taro编译的输出目录\n   * @returns {string}\n   */\n  public getOutputPath(): string {\n    return this.ctx.compilation.compiler.outputPath;\n  }\n\n  /**\n   * 根据文件类型获取文件列表\n   * @param {string | RegExp} type\n   * @param {boolean} exact\n   * @returns {{path: string; file: any}[]}\n   */\n  public getFileListByFileType(type: string | RegExp, exact = false) {\n    const targetFileNames = this.getFileNamesByType(type, exact);\n    return targetFileNames.map(fileName => ({\n      path: fileName,\n      file: this.assets[fileName]\n    }));\n  }\n\n  /**\n   * 将文件内容输出到输出目录\n   * @param {string} path\n   * @param {string | Buffer} content\n   * @returns {boolean}\n   */\n  public outputFile(path: string, content: string | Buffer): boolean {\n\n    try {\n      writeFileSync(\n        path,\n        content\n      );\n      return true;\n    } catch (e) {\n      return false;\n    }\n\n\n  }\n}\n","import { TaroTrackLibName, TaroTrackLoggerNamespace } from '@kiner/taro-track-common';\nimport { packageName, packageNameCore, packageNameDatasource } from '@/src/plugins/src/taro/config';\n\n// 微信小程序运行时常量\nconst constantSymbol = '////injectConstant////';\nconst constantCore = `\n  exports.config = {\n    ${constantSymbol}\n  }\n`;\nexport function injectConstant() {\n  return constantCore.replace(constantSymbol,`\n    TaroTrackLoggerNamespace: ${JSON.stringify(TaroTrackLoggerNamespace)},\n    TaroTrackLibName: ${JSON.stringify(TaroTrackLibName)}\n  `);\n}\n\n// 获取目标元素位置信息的方法\nexport function getBoundingClientRectSource(): string{\n  return `\n    exports.getBoundingClientRect = function (element) {\n      return new Promise((reslove) => {\n        const query = wx.createSelectorQuery();\n        query.selectAll(element).boundingClientRect();\n        query.selectViewport().scrollOffset();\n        query.exec(res => reslove({ boundingClientRect: res[0], scrollOffset: res[1] }));\n      });\n    }\n  `;\n}\n\n// 判断点击的坐标是否落在目标元素上\nexport function getIsClickTrackAreaSource(): string{\n  return `\n    exports.isClickTrackArea = function(clickInfo, boundingClientRect, scrollOffset){\n      if (!boundingClientRect) return false;\n      const { x, y } = clickInfo.detail; // 点击的x y坐标\n      const { left, right, top, height } = boundingClientRect;\n      const { scrollTop } = scrollOffset;\n      return left < x && x < right && scrollTop + top < y && y < scrollTop + top + height;\n    }\n  `;\n}\n\n// 获取当前页面的方法\nexport function getActivePageSource(): string{\n  return `\n    exports.getActivePage = function(){\n\n      const curPages = getCurrentPages();\n      if (curPages.length) {\n        return curPages[curPages.length - 1];\n      }\n      return {};\n\n    }\n  `;\n}\n\n// 获取上一个页面的方法\nexport function getPrevPageSource(): string{\n  return `\n    exports.getPrevPage = function(){\n\n      const curPages = getCurrentPages();\n      if (curPages.length > 1) {\n        return curPages[curPages.length - 2];\n      }\n      return {};\n\n    }\n  `;\n}\n\n// TaroTrack注入代码通用日志方法\nexport function injectLogger() {\n  return `\n    exports.logger = function(msg,...rest){\n      const label = '['+exports.config.TaroTrackLoggerNamespace+':Plugin] '+msg;\n      console.groupCollapsed(label);\n      rest.forEach(item=>{\n        console.log(item);\n      });\n      console.groupEnd();\n    }\n  `;\n}\n\n// 定义在注入代码中触发行为进行上报的方法\nexport function injectTransporter() {\n  return `\n    exports.transporter = function(transporterType, baseOptions){\n      exports.logger(\"transporterOption: %s\", JSON.stringify(baseOptions))\n      const dolphinEntry = __webpack_require__(\"./node_modules/${packageName}/entry/es/index.js\");\n      const tpr = dolphinEntry.initTransporter(transporterType, {\n        baseUrl: baseOptions.baseUrl,\n        query: {\n          app_name: baseOptions.query.app_name,\n          app_version: baseOptions.query.app_version,\n          ev_type: 'web_stat'\n        }\n      });\n      return tpr;\n    }\n  `;\n}\n\n// 注入内部上报通用字段\nexport function commonBaseField() {\n  return `\n    exports.commonBaseField = async function(){\n\n      const common = __webpack_require__(\"../node_modules/${packageNameDatasource}/es/index.js\");\n      console.log(common);\n      const { getBaseFields } = common;\n      const { getWxCurrentHref, getWxSystemInfo }  = __webpack_require__(\"../node_modules/${packageNameCore}/es/index.js\");\n      const baseFields = await getBaseFields();\n      const wxSystemInfo = getWxSystemInfo();\n      return {\n        baseFields,\n        wxSystemInfo\n      };\n    }\n  `;\n}\n// 运行时获取用户信息，包括但不限于openId和unionId\nexport function getUserInfo(cookieKey: string=\"AUTH-INFO\") {\n  return `\n    exports.getUserInfo = function(){\n      const { storage }  = __webpack_require__(\"../node_modules/${packageNameCore}/es/index.js\");\n      return storage(${JSON.stringify(cookieKey)});\n    }\n  `;\n}\n\n\n/**\n * 内部调用的核心代码\n * @type {string}\n */\nexport const TaroTrackInjectLibCore = `\n  ${injectConstant()}\n  ${getActivePageSource()}\n  ${getBoundingClientRectSource()}\n  ${getIsClickTrackAreaSource()}\n  ${getPrevPageSource()}\n  ${injectLogger()}\n  ${injectTransporter()}\n  ${commonBaseField()}\n  ${getUserInfo()}\n`;\n\n\n/**\n * 注入微信开发者工具库，方便开发者在微信开发者工具中调用\n * @type {string}\n */\nexport const injectLibInWxApi = `\n\nconst timer = setInterval(()=>{\n\n  if(wx&&!wx.TaroTrack){\n    clearInterval(timer);\n\n    wx.TaroTrack = {\n      version: '0.0.1',\n      help(name){\n        const version = {\"name\":\"version\",\"API\": \"wx.TaroTrack.version\",\"用法\":\"wx.TaroTrack.version\", \"说明\": \"当前TaroTrackLib的版本号\"};\n        const help = {\"name\":\"help\",\"API\": \"wx.TaroTrack.help([API Name])\",\"用法\":\"wx.TaroTrack.help()\", \"说明\": \"显示TaroTrack的所有API用法,或根据API的name筛选显示的用户\"};\n        const showViewBySelector = {\"name\":\"showViewBySelector\",\"API\": \"wx.TaroTrack.showViewBySelector(className)\",\"用法\":\"wx.TaroTrack.showViewBySelector('.md5-1234')\", \"说明\": \"可以根据元素的md5作为class快速定位目标元素\"};\n        const cancelShowView = {\"name\":\"cancelShowView\",\"API\": \"wx.TaroTrack.cancelShowView\",\"用法\":\"wx.TaroTrack.cancelShowView()\", \"说明\": \"取消当前选中的元素\"};\n\n        let res = [version,help,showViewBySelector,cancelShowView]\n        if(!!name){\n          res = res.filter(item=>item.name===name);\n        }\n        console.table(res);\n      },\n      showViewBySelector(selector){\n        const query = wx.createSelectorQuery();\n        const nodes = query.selectAll(selector)\n        nodes.boundingClientRect();\n        query.selectViewport().scrollOffset();\n        nodes.fields({\n          dataset: true,\n          size: true,\n          scrollOffset: true,\n          properties: ['scrollX', 'scrollY'],\n          computedStyle: ['margin', 'backgroundColor'],\n          context: true,\n        });\n        query.exec(function(res){\n          exports.logger('选中元素相关信息[分别为：元素的rect信息（boundingClientRect）、视窗信息（selectViewport）、元素详细字段信息（fields）]:',...res);\n        });\n        const curPages = getCurrentPages();\n        curPages[curPages.length-1].setData({dolphinActiveElement: selector.substring(1)})\n        wx.pageScrollTo({selector: selector});\n        return \"[wx.TaroTrack]选中元素【\"+selector+\"】执行成功\";\n      },\n      cancelShowView(){\n        const curPages = getCurrentPages();\n        curPages[curPages.length-1].setData({dolphinActiveElement: ''})\n      }\n    };\n  }\n\n},60);\n\n`;\n\n// 这个库文件将会注入到微信小程序中，便于我们的注入代码能在运行时调用这些方法\nexport const TaroTrackInjectLib = `\n  ${TaroTrackInjectLibCore}\n  ${injectLibInWxApi}\n`;\n","/**\n * 在taro运行时对输出的wxml、js等资源进行一定的修饰以达到全自动监听的目的\n */\nimport { TaroTrackSourceInjector } from '@/src/plugins/src/taro/TaroTrackSourceInjector';\nimport { taroTargetVersion } from '@/src/plugins/src/taro/config';\nimport { Logger4Node } from '@kiner/taro-track-corejs';\nimport { TaroTrackLoggerNamespace } from '@kiner/taro-track-common';\nimport { TransporterType } from '@kiner/taro-track-entrypoint';\n\nconst { exec } = require('shelljs');\n\nexport interface TaroTrackPluginInitOptions {\n  transporterOptions: {\n    env: string,\n    transporterType: TransporterType,\n    cookieKey?: string,\n    appName: string,\n    appVersion: string,\n    appId?: string,\n    appNameZH?: string\n  },\n  exclude?: RegExp[]|RegExp|string[]|string\n  wxmlLHooks?: (path: String, source: string, emit: (newSource: string)=>void, type: string)=>Promise<any>\n  pageJsHooks?: (path: String, source: string, emit: (newSource: string)=>void, type: string)=>Promise<any>\n  componentJsHooks?: (path: String, source: string, emit: (newSource: string)=>void, type: string)=>Promise<any>\n  npmComponentJsHooks?: (path: String, source: string, emit: (newSource: string)=>void, type: string)=>Promise<any>\n  appJsHooks?: (path: String, source: string, emit: (newSource: string)=>void, type: string)=>Promise<any>\n  wxssHooks?: (path: String, source: string, emit: (newSource: string)=>void, type: string)=>Promise<any>\n  dolphinLibJsHooks?: (path: String, source: string, emit: (newSource: string)=>void, type: string)=>Promise<any>\n  postDataHooks?: (data: any)=>Promise<any>\n}\n\n\nconst logger: Logger4Node = new Logger4Node(TaroTrackLoggerNamespace, {\n  groupCollapsed: false\n});\n/**\n * 基于Taro的Dolphin插件，通过此入口可以在taro编译结束后对输出的源代码进行二次编译，\n * 从而实现数据自动埋点、监听、上报等功能\n *\n * 使用方式：\n *\n * 在taro项目根目录下的`config/index.js`中引入当前插件，并如下使用：\n *\n * const config = {\n *   // 省略无关配置...\n *   plugins: [\n *     new TaroTrackPlugins.TaroTrackPlugin({\n *        pageWXMLHooks(path, source, emit) {\n *          // TODO 在这里可以对wxml文件的源代码进行修改,修改完后执行emit方法并传入新的源代码\n *          console.log(\n *            `\\x1B[1m[TaroTrack]\\x1B[0m 【Plugin:pageWXMLHooks】 ${path}`\n *          );\n *\n *          // wxml已经被解析成json,可用通过更改json的属性实现更改wxml的目的\n *          // 如在index/index.wxml的第一个实际根节点（非block）上增加一个class\n *          if (path === \"pages/index/index.wxml\") {\n *            source.attr.class += \" testClass\";\n *          }\n *\n *          emit(source);\n *        },\n *        pageJsHooks(path, source, emit) {\n *          // TODO 在这里可以对页面js的源代码进行修改,修改完后执行emit方法并传入新的源代码\n *\n *          console.log(`\\x1B[1m[TaroTrack]\\x1B[0m 【Plugin:pageJsHooks】 ${path}`);\n *          emit(source);\n *        },\n *        appJsHooks(path, source, emit) {\n *          // TODO 在这里可以对appJs的源代码进行修改,修改完后执行emit方法并传入新的源代码\n *\n *          console.log(`\\x1B[1m[TaroTrack]\\x1B[0m 【Plugin:appJsHooks】 ${path}`);\n *          emit(source);\n *        },\n *        dolphinLibJsHooks(path, source, emit) {\n *          // TODO 在这里可以对dolphinLib，即sdk对小程序注入的库文件的源代码进行修改,修改完后执行emit方法并传入新的源代码\n *\n *          console.log(\n *            `\\x1B[1m[TaroTrack]\\x1B[0m 【Plugin:dolphinLibJsHooks】 ${path}`\n *          );\n *          emit(source);\n *        }\n *      })\n *   ]\n *   // 省略无关配置...\n * };\n *\n */\nexport class TaroTrackPlugin {\n\n  constructor(private options: TaroTrackPluginInitOptions={transporterOptions: {env: \"development\", transporterType: TransporterType.Console, appName: \"applet(alpha)\", appVersion: \"0.0.1\"}}) {\n\n  }\n\n  versionChecker(): Promise<string>{\n    // console.log('判断版本0');\n    return new Promise<string>(resolve => {\n      // console.log('判断版本1');\n      exec('taro --version', {silent:true,async:true}).stdout.on('data', function(data: string) {\n        // console.log('判断版本2', data.replace('\\n',''));\n        let datas = data.split(/\\s/);\n        datas = datas.filter(item=>item.match(/^\\d*\\.\\d*\\.\\d*$/));\n        data = datas[0];\n        // data = data.replace(/\\s/g,'');\n        // data = data.replace(/(\\d+\\.\\d+\\.\\d+).*/m,'').trim().replace('\\n','');\n        // console.log('获取版本',data, typeof data, taroTargetVersion, typeof taroTargetVersion);\n        if(data!==taroTargetVersion&&data){\n          console.log('\\n');\n          logger.warn(`⚠️ ============================================================================================================================`);\n          logger.warn(`⚠️ 您当前的taro版本为[v${data}],taro-track/plugins支持在[v${taroTargetVersion}]中运行，请保证taro版本与目标版本一致，以免出现不可预料的问题`);\n          logger.warn(`⚠️ ============================================================================================================================\\n`);\n          console.log('\\n');\n        }\n        resolve(data);\n      });\n    });\n  }\n\n  private TaroTrackSourceInjector: TaroTrackSourceInjector;\n  /**\n   * taro Plugin默认方法\n   * @param builder\n   */\n  async apply(builder: any): Promise<void> {\n    // 编译前钩子，可获取编译配置\n    builder.hooks.beforeBuild.tap('BuildPlugin', (config: any) => {\n      // console.log(config)\n    });\n    // 编译后钩子，可以获取输出的源码等信息\n    builder.hooks.afterBuild.tap('BuildPlugin', async (stats: any) => {\n      await this.versionChecker();\n\n      if(this.TaroTrackSourceInjector){\n        await this.TaroTrackSourceInjector.initial(stats, this.options);\n      }else{\n        this.TaroTrackSourceInjector = new TaroTrackSourceInjector(stats, this.options);\n      }\n\n    });\n  }\n}\n\n","import {\n  TaroTrackElementClassName, TaroTrackLibName, TaroTrackLoggerNamespace, TaroTrackPageEvent\n} from '@kiner/taro-track-common';\n\n\nimport { filterWXMLTaroTrackAttr, WXMLHelper } from '@/src/plugins/src/taro/WXMLHelper';\nimport { createWxModuleSourceFragment } from '@/src/plugins/src/taro/WxMoudleSourceFragment';\nimport { TaroFileManager } from '@/src/plugins/src/taro/TaroFileManager';\n// @ts-ignore\nimport { json2wxml } from 'wxml2json';\nimport { wxml2json } from './tools/wxml2json';\nimport { packageName } from '@/src/plugins/src/taro/config';\nimport { ELKLogServerHost, TestELKLogServerHost } from '@kiner/taro-track-entrypoint';\nimport { userInfo } from 'os';\nimport { Logger4Node } from '@kiner/taro-track-corejs';\nimport { TaroTrackPluginInitOptions } from '@/src/plugins/src/taro/TaroTrackPlugin';\nimport { TaroTrackInjectLib } from '@/src/plugins/src/taro/TaroTrackInjectLib';\n\nconst minify = require('uglify-js').minify;\n\nconst miniFileReg = /[\\n\\t\\r]/g;\n\nconst logger: Logger4Node = new Logger4Node(TaroTrackLoggerNamespace, {\n  groupCollapsed: false\n});\n\n/**\n * 用于往taro编译过后的wxml、js等文件中注入相关业务代码实现一些特定功能\n */\nexport class TaroTrackSourceInjector {\n  private tfm: any;\n\n  constructor(stats: any, private TaroTrackPluginInitOptions: TaroTrackPluginInitOptions) {\n    this.initial(stats, this.TaroTrackPluginInitOptions).catch(reason=>{\n      logger.error('【TaroTrackPlugin】TaroTrackSourceInjector初始化失败', reason);\n    });\n  }\n\n  async initial(stats: any, hooks: TaroTrackPluginInitOptions) {\n    this.TaroTrackPluginInitOptions = hooks;\n    logger.info('=========================TaroTrack Plugins============================');\n    logger.info('【TaroTrackPlugin】初始化...');\n    await this.initInjector(stats);\n    logger.info('【TaroTrackPlugin】完成！');\n    logger.info('=========================TaroTrack Plugins============================\\n');\n  }\n\n  /**\n   * 往wxml文件中注入事件捕获者\n   * @param root\n   * @returns {any}\n   */\n  injectTaroTrackEventCaptorInPageRoot(root: any): any {\n    let rootAttrs;\n    if (!root.attr) {\n      root.attr = {};\n    }\n    rootAttrs = root.attr;\n    rootAttrs['capture-bind:tap'] = TaroTrackPageEvent['capture-bind:tap'];\n\n    return root;\n  }\n\n  /**\n   * 在wxml中为每个真实的元素插入一个用于事件统计监听的class，\n   * 方便根据用户当前点击的坐标，匹配对应class的元素\n   * @param roots\n   */\n  injectTaroTrackElementClassNameInWXML(roots: any): Promise<any> {\n\n    return new Promise<any>(resolve => {\n      WXMLHelper.findWXMLElement(roots, ((elementName: string, element: any) => {\n        if (!element.attr) {\n          element.attr = {};\n        }\n        let elementAttrs = element.attr;\n        let elementClass = elementAttrs['class'] || '';\n\n        elementAttrs['class'] = `${elementClass} ${TaroTrackElementClassName}`;\n\n      }), true);\n      resolve(roots);\n    });\n  }\n\n  /**\n   * 注入图片onload代码监听代码\n   * @param roots\n   * @returns {Promise<any>}\n   */\n  injectTaroTrackImageOnLoadInWXML(roots: any): Promise<any> {\n\n\n    return new Promise<any>(resolve => {\n      let rootsString = JSON.stringify(roots);\n      WXMLHelper.findElementAll(roots, 'image').then(res => {\n        res.forEach(img => {\n\n\n          let imgStr = JSON.stringify(img);\n\n          // 保存用户定义的事件监听\n          const bindload = img.attr.bindload;\n          const binderror = img.attr.binderror;\n\n\n          // 将用户定义的事件监听保存在标签的dataset中，方便之后获取\n          let i;\n\n          (i = img) && (i = (i.attr || {}));\n\n          i['data-original-onload-method'] = bindload;\n          i['data-original-onerror-method'] = binderror;\n          i['data-image-src'] = i.src;\n          // 将相关的事件调用的方法改为我们注入的方法名\n          // 注：sdk会在调用我们注入的方法时调用用户自定义的事件监听，因此，无需担心影响用户自己注册的事件\n          i.bindload = TaroTrackPageEvent['bindload'];\n          i.binderror = TaroTrackPageEvent['binderror'];\n\n          // console.log(imgStr, rootsString.indexOf(JSON.stringify(img)));\n\n          // 源码字符串替换\n          rootsString = rootsString.replace(imgStr, JSON.stringify(img));\n\n\n        });\n\n        // 将源码转换成json对象\n        roots = JSON.parse(rootsString);\n\n        // 重新输出文件前，将一些临时属性删除\n        filterWXMLTaroTrackAttr(roots);\n\n        resolve(roots);\n\n      });\n\n    });\n\n  }\n\n  /**\n   * 注入文本框事件监听代码\n   * TODO 暂时不支持taro-ui的input的输入监听\n   * @param roots\n   * @returns {Promise<any>}\n   */\n  injectTaroTrackInputEventInWXML(roots: any): Promise<any> {\n\n    return new Promise<any>(resolve => {\n      let rootsString = JSON.stringify(roots);\n      WXMLHelper.findElementAll(roots, 'input').then(res => {\n        res.forEach(input => {\n\n          let inputStr = JSON.stringify(input);\n\n          const bindinput = input.attr.bindinput;\n          const bindfocus = input.attr.bindfocus;\n          const bindblur = input.attr.bindblur;\n          const bindconfirm = input.attr.bindconfirm;\n          // const bindkeyboardheightchange = input.attr.bindkeyboardheightchange;\n\n\n          let i;\n\n          (i = input) && (i = (i.attr || {}));\n\n          i['data-original-input-method'] = bindinput;\n          i['data-original-focus-method'] = bindfocus;\n          i['data-original-blur-method'] = bindblur;\n          i['data-original-confirm-method'] = bindconfirm;\n          // i['data-original-keyboardheightchange-method'] = bindkeyboardheightchange;\n          i['data-input-name'] = i.name;\n          i['data-input-placeholder'] = i.placeholder;\n          i.bindinput = TaroTrackPageEvent['bindinput'];\n          i.bindfocus = TaroTrackPageEvent['bindfocus'];\n          i.bindblur = TaroTrackPageEvent['bindblur'];\n          i.bindconfirm = TaroTrackPageEvent['bindconfirm'];\n          // i.bindkeyboardheightchange = TaroTrackPageEvent['bindkeyboardheightchange'];\n\n\n          rootsString = rootsString.replace(inputStr, JSON.stringify(input));\n\n\n        });\n\n        roots = JSON.parse(rootsString);\n\n        // 重新输出文件前，将一些临时属性删除\n        filterWXMLTaroTrackAttr(roots);\n\n        // console.log(JSON.stringify(roots, null , 4));\n\n        resolve(roots);\n\n      });\n\n    });\n\n  }\n\n  /**\n   * 在页面js中插入公共库文件代码\n   * @returns {string}\n   */\n  injectTaroTrackLibJs(): string {\n    const core = createWxModuleSourceFragment(`\n      ${TaroTrackInjectLib}\n    `);\n    return core;\n  }\n\n  /**\n   * 在taro Page中插入方法\n   * @param {string} path                           js文件路径\n   * @param {string} source                         js文件源代码\n   * @param {string} injectMethodSource             事件实现源代码\n   * @param {string} injectRegisterEventSource      事件注册源代码\n   * @param {any} injectPageData                    注入页面数据\n   * @returns {string}\n   */\n  injectTaroTrackPageEventMethod(path: string, source: string, injectMethodSource: string, injectRegisterEventSource: string, injectPageData: any= {}): string {\n    const componentPath = path.replace(/\\.js$/, '');\n\n    // 压缩代码\n    const res = minify(source, {\n      compress: false,\n      keep_fnames: false,\n      mangle: false\n    });\n    source = res.code;\n\n    const pageDataKeys = Object.keys(injectPageData).map(item=>`\"${item}\"`);\n    let pageDataKeyString = '';\n    if(pageDataKeys.length!==0){\n      pageDataKeyString += `,${pageDataKeys.join(\",\")}`;\n    }\n\n    let pageDataInitString = '';\n    if(pageDataKeys.length!==0){\n      let pageDataString = JSON.stringify(injectPageData);\n      pageDataInitString = `;this.setState(${pageDataString})`;\n    }\n\n\n    const regFragment1 = `(\\\\./src/${componentPath}.tsx\\\\?taro&type=script&parse=PAGE&.*_this\\\\.\\\\$usedState=\\\\[[^\\\\]]*)`;\n    const regFragment2 = `(.*)`;\n    const regFragment3 = `(_createClass\\\\(\\\\w*,\\\\s*\\\\[)`;\n    const regFragment4 = `(.*\\\\{key:\"_constructor\",value:function _constructor\\\\(.*\\\\)\\\\{.*this\\\\.\\\\$\\\\$refs=new\\\\s*_taroWeapp2\\\\.default\\\\.RefsArray)(\\\\}\\\\},\\\\{key)`;\n    const regFragment5 = `(.*_class\\\\.\\\\$\\\\$events\\\\s*=\\\\s*\\\\[)`;\n    const regFragment6 = `(.*componentPath\\\\s*=\\\\s*\"${componentPath}\",[_\\\\w\\\\d]*\\\\);)`;\n\n    const jsSourceReg = new RegExp(`${regFragment1}${regFragment2}${regFragment3}${regFragment4}${regFragment5}${regFragment6}`);\n    const injectLibReg = new RegExp(`(,\\\\[\\\\[)(\".*\",?)*(\\\\]\\\\]\\\\]\\\\);)$`);\n\n    // console.log(jsSourceReg.exec(res.code));\n\n\n    source = source.replace(jsSourceReg, `$1${pageDataKeyString}$2$3${injectMethodSource}$4${pageDataInitString}$5$6${injectRegisterEventSource}$7`);\n\n    // 在页面js中添加库文件依赖\n    source = source.replace(injectLibReg, `$1$2,\"${TaroTrackLibName}\"$3`);\n\n\n    return source;\n  }\n  /**\n   * 在taro-ui的组件js中插入方法\n   * @param {string} path                           js文件路径\n   * @param {string} source                         js文件源代码\n   * @param {string} injectMethodSource             事件实现源代码\n   * @param {string} injectRegisterEventSource      事件注册源代码\n   * @param {any} injectPageData                    注入页面数据\n   * @returns {string}\n   */\n  injectTaroTrackNpmComponentEventMethod(path: string, source: string, injectMethodSource: string, injectRegisterEventSource: string, injectPageData: any= {}): string {\n    // const componentPath = path.replace(/\\.js$/, '');\n\n    // 压缩代码\n    const res = minify(source, {\n      compress: false,\n      keep_fnames: false,\n      mangle: false\n    });\n    source = res.code;\n\n    const pageDataKeys = Object.keys(injectPageData).map(item=>`\"${item}\"`);\n    let pageDataKeyString = '';\n    if(pageDataKeys.length!==0){\n      pageDataKeyString += `,${pageDataKeys.join(\",\")}`;\n    }\n\n    let pageDataInitString = '';\n    if(pageDataKeys.length!==0){\n      let pageDataString = JSON.stringify(injectPageData);\n      pageDataInitString = `;this.setState(${pageDataString})`;\n    }\n\n\n    const regFragment1 = `(_this\\\\.\\\\$usedState=\\\\[[^\\\\]]*)`;\n    const regFragment2 = `(.*)`;\n    const regFragment3 = `(_createClass\\\\(\\\\w*,\\\\s*\\\\[)`;\n    const regFragment4 = `(.*\\\\{key:\"_constructor\",value:function _constructor\\\\(.*\\\\)\\\\{.*this\\\\.\\\\$\\\\$refs=new\\\\s*_taroWeapp2\\\\.default\\\\.RefsArray)(\\\\}\\\\},\\\\{key)`;\n    const regFragment5 = `(.*_class\\\\.\\\\$\\\\$events\\\\s*=\\\\s*\\\\[)`;\n    // const regFragment6 = `(.*componentPath\\\\s*=\\\\s*\"${componentPath}\",[_\\\\w\\\\d]*\\\\);)`;\n\n    const jsSourceReg = new RegExp(`${regFragment1}${regFragment2}${regFragment3}${regFragment4}${regFragment5}`);\n    const injectLibReg = new RegExp(`(,\\\\[\\\\[)(\".*\",?)*(\\\\]\\\\]\\\\]\\\\);)$`);\n\n    // console.log(jsSourceReg.test(source));\n\n    source = source.replace(jsSourceReg, `$1${pageDataKeyString}$2$3${injectMethodSource}$4${pageDataInitString}$5$6${injectRegisterEventSource}`);\n\n    // 在页面js中添加库文件依赖\n    source = source.replace(injectLibReg, `$1$2,\"${TaroTrackLibName}\"$3`);\n\n\n    return source;\n  }\n\n\n  /**\n   * 获取注入的事件监听代码\n   * @returns {{injectSourceForDefineEvent: string; injectSourceForRegisterEvent: string}}\n   */\n  private eventFragment(): {injectSourceForDefineEvent: string, injectSourceForRegisterEvent: string}{\n    const options = this.TaroTrackPluginInitOptions.transporterOptions;\n\n    // logger.info(\"debug: %s\", JSON.stringify(options));\n    // logger.info(\"debug: %s\", JSON.stringify(options.appName));\n    // logger.info(\"debug: %s\", JSON.stringify(options.appVersion));\n\n    // 以下为将注入到页面js中的用于进行相关事件统计的代码片段\n    const TaroTrackEventCollectionCore = `\n       const _es = __webpack_require__(\"./${TaroTrackLibName}.js\");\n       const { data } = _es.getActivePage();\n       const hitTargets = [];\n       _es.getBoundingClientRect(\".${TaroTrackElementClassName}\").then(async (res) => {\n          res.boundingClientRect.forEach(async (item) => {\n            const isHit = _es.isClickTrackArea(e, item, res.scrollOffset);\n            const dataset = item.dataset;\n            if(isHit){\n              hitTargets.push({\n                elem: item,\n                dataset,\n                pageData: data\n              })\n            }\n\n          });\n\n          const tpr = _es.transporter(${JSON.stringify(options.transporterType)}, {\n             baseUrl: ${JSON.stringify(options.env===\"production\"?ELKLogServerHost:TestELKLogServerHost)},\n             query: {\n               app_name: ${JSON.stringify(options.appName)},\n               app_version: ${JSON.stringify(options.appVersion)},\n               ev_type: 'web_stat'\n             }\n          });\n          const {baseFields, wxSystemInfo} = await _es.commonBaseField();\n          const userInfo = _es.getUserInfo(${JSON.stringify(options.cookieKey)});\n          const curTarget = hitTargets[hitTargets.length-1];\n          console.log('===>', curTarget);\n          tpr.send({\n            ...baseFields,\n            ev: 'et',\n            v: ${JSON.stringify(options.appVersion)},\n            app_name: ${JSON.stringify(options.appName)},\n            app_version: ${JSON.stringify(options.appVersion)},\n            ui: userInfo.unionId,\n            ext: {\n              csspath: curTarget.dataset.taroTrackCssPath,\n              TaroTrackMd5: curTarget.dataset.taroTrackMd5,\n              page_unique_id: userInfo.openId+'${JSON.stringify(Date.now())}', // 页面唯一id\n              open_id: userInfo.openId, // 用户openId\n              url: baseFields.pl, // 当前页面原始路径\n              time: Date.now(), // 页面停留时长,具体到毫秒时间戳\n              app_id: ${JSON.stringify(options.appId)}, // 小程序id\n              app_name: ${JSON.stringify(options.appNameZH)}, // 小程序名称\n              terminal: wxSystemInfo.osInfo(), // 终端类型 (如：iphone6)s\n              res_type: 1 // 资源类型（1-页面，2-视频）\n            }\n          });\n          // TODO 将元素的事件上报\n          _es.logger('点中目标元素', hitTargets);\n        });\n    `;\n\n    const injectSourceImageOnload = `\n              const _es = __webpack_require__(\"./${TaroTrackLibName}.js\");\n              _es.logger('图片加载成功', e);\n              const originalOnloadMethod = e.currentTarget.dataset.originalOnloadMethod;\n              originalOnloadMethod&&this[originalOnloadMethod].call(this, e);\n          `;\n\n    const injectSourceImageOnError = `\n              const _es = __webpack_require__(\"./${TaroTrackLibName}.js\");\n              _es.logger('图片加载失败：',e);\n              const tpr = _es.transporter(${JSON.stringify(options.transporterType)}, {\n                 baseUrl: ${JSON.stringify(options.env===\"production\"?ELKLogServerHost:TestELKLogServerHost)},\n                 query: {\n                   app_name: ${JSON.stringify(options.appName)},\n                   app_version: ${JSON.stringify(options.appVersion)},\n                   ev_type: 'web_stat'\n                 }\n              });\n              _es.commonBaseField().then(({baseFields, wxSystemInfo})=>{\n                const userInfo = _es.getUserInfo(${JSON.stringify(options.cookieKey)});\n                const curTarget = e.currentTarget;\n                tpr.send({\n                  ...baseFields,\n                  ev: 'img_error',\n                  v: ${JSON.stringify(options.appVersion)},\n                  app_name: ${JSON.stringify(options.appName)},\n                  app_version: ${JSON.stringify(options.appVersion)},\n                  ui: userInfo.unionId,\n                  ext: {\n                    csspath: curTarget.dataset.taroTrackCssPath,\n                    TaroTrackMd5: curTarget.dataset.taroTrackMd5,\n                    page_unique_id: userInfo.openId+'${JSON.stringify(Date.now())}', // 页面唯一id\n                    open_id: userInfo.openId, // 用户openId\n                    url: e.currentTarget.dataset.imageSrc, // 当前页面原始路径\n                    error_msg: e.detail.errMsg,\n                    time: Date.now(), // 页面停留时长,具体到毫秒时间戳\n                    app_id: ${JSON.stringify(options.appId)}, // 小程序id\n                    app_name: ${JSON.stringify(options.appNameZH)}, // 小程序名称\n                    terminal: wxSystemInfo.osInfo(), // 终端类型 (如：iphone6)s\n                    res_type: 1 // 资源类型（1-页面，2-视频）\n                  }\n                });\n              });\n\n              const originalOnerrorMethod = e.currentTarget.dataset.originalOnerrorMethod;\n              originalOnerrorMethod&&this[originalOnerrorMethod].call(this, e);\n          `;\n    const injectSourceInputOnInput = `\n              const _es = __webpack_require__(\"./${TaroTrackLibName}.js\");\n              _es.logger('文本框输入：',e);\n              const tpr = _es.transporter(${JSON.stringify(options.transporterType)}, {\n                 baseUrl: ${JSON.stringify(options.env===\"production\"?ELKLogServerHost:TestELKLogServerHost)},\n                 query: {\n                   app_name: ${JSON.stringify(options.appName)},\n                   app_version: ${JSON.stringify(options.appVersion)},\n                   ev_type: 'web_stat'\n                 }\n              });\n              _es.commonBaseField().then(({baseFields, wxSystemInfo})=>{\n                const userInfo = _es.getUserInfo(${JSON.stringify(options.cookieKey)});\n              const curTarget = e.currentTarget;\n              tpr.send({\n                ...baseFields,\n                ev: 'input_input',\n                v: ${JSON.stringify(options.appVersion)},\n                app_name: ${JSON.stringify(options.appName)},\n                app_version: ${JSON.stringify(options.appVersion)},\n                ui: userInfo.unionId,\n                ext: {\n                  csspath: curTarget.dataset.taroTrackCssPath,\n                  TaroTrackMd5: curTarget.dataset.taroTrackMd5,\n                  page_unique_id: userInfo.openId+'${JSON.stringify(Date.now())}', // 页面唯一id\n                  open_id: userInfo.openId, // 用户openId\n                  value: curTarget.value,\n                  cursor: curTarget.cursor,\n                  url: baseFields.pl, // 当前页面原始路径\n                  time: Date.now(), // 页面停留时长,具体到毫秒时间戳\n                  app_id: ${JSON.stringify(options.appId)}, // 小程序id\n                  app_name: ${JSON.stringify(options.appNameZH)}, // 小程序名称\n                  terminal: wxSystemInfo.osInfo(), // 终端类型 (如：iphone6)s\n                  res_type: 1 // 资源类型（1-页面，2-视频）\n                }\n              });\n              });\n\n              const originalInputMethod = e.currentTarget.dataset.originalInputMethod;\n              originalInputMethod&&this[originalInputMethod].call(this, e);\n          `;\n    const injectSourceInputOnFocus = `\n              const _es = __webpack_require__(\"./${TaroTrackLibName}.js\");\n              _es.logger('文本框获得焦点：',e);\n              const tpr = _es.transporter(${JSON.stringify(options.transporterType)}, {\n                 baseUrl: ${JSON.stringify(options.env===\"production\"?ELKLogServerHost:TestELKLogServerHost)},\n                 query: {\n                   app_name: ${JSON.stringify(options.appName)},\n                   app_version: ${JSON.stringify(options.appVersion)},\n                   ev_type: 'web_stat'\n                 }\n              });\n              _es.commonBaseField().then(({baseFields, wxSystemInfo})=>{\n                const userInfo = _es.getUserInfo(${JSON.stringify(options.cookieKey)});\n                const curTarget = e.currentTarget;\n                tpr.send({\n                  ...baseFields,\n                  ev: 'input_focus',\n                  v: ${JSON.stringify(options.appVersion)},\n                  app_name: ${JSON.stringify(options.appName)},\n                  app_version: ${JSON.stringify(options.appVersion)},\n                  ui: userInfo.unionId,\n                  ext: {\n                    csspath: curTarget.dataset.taroTrackCssPath,\n                    TaroTrackMd5: curTarget.dataset.taroTrackMd5,\n                    page_unique_id: userInfo.openId+'${JSON.stringify(Date.now())}', // 页面唯一id\n                    open_id: userInfo.openId, // 用户openId\n                    value: curTarget.value,\n                    cursor: curTarget.cursor,\n                    url: baseFields.pl, // 当前页面原始路径\n                    time: Date.now(), // 页面停留时长,具体到毫秒时间戳\n                    app_id: ${JSON.stringify(options.appId)}, // 小程序id\n                    app_name: ${JSON.stringify(options.appNameZH)}, // 小程序名称\n                    terminal: wxSystemInfo.osInfo(), // 终端类型 (如：iphone6)s\n                    res_type: 1 // 资源类型（1-页面，2-视频）\n                  }\n                });\n              });\n\n              const originalFocusMethod = e.currentTarget.dataset.originalFocusMethod;\n              originalFocusMethod&&this[originalFocusMethod].call(this, e);\n          `;\n    const injectSourceInputOnBlur = `\n              const _es = __webpack_require__(\"./${TaroTrackLibName}.js\");\n              _es.logger('文本框失去焦点：',e);\n              const tpr = _es.transporter(${JSON.stringify(options.transporterType)}, {\n                 baseUrl: ${JSON.stringify(options.env===\"production\"?ELKLogServerHost:TestELKLogServerHost)},\n                 query: {\n                   app_name: ${JSON.stringify(options.appName)},\n                   app_version: ${JSON.stringify(options.appVersion)},\n                   ev_type: 'web_stat'\n                 }\n              });\n              _es.commonBaseField().then(({baseFields, wxSystemInfo})=>{\n                const userInfo = _es.getUserInfo(${JSON.stringify(options.cookieKey)});\n                const curTarget = e.currentTarget;\n                tpr.send({\n                  ...baseFields,\n                  ev: 'input_blur',\n                  v: ${JSON.stringify(options.appVersion)},\n                  app_name: ${JSON.stringify(options.appName)},\n                  app_version: ${JSON.stringify(options.appVersion)},\n                  ui: userInfo.unionId,\n                  ext: {\n                    csspath: curTarget.dataset.taroTrackCssPath,\n                    TaroTrackMd5: curTarget.dataset.taroTrackMd5,\n                    page_unique_id: userInfo.openId+'${JSON.stringify(Date.now())}', // 页面唯一id\n                    open_id: userInfo.openId, // 用户openId\n                    value: curTarget.value,\n                    cursor: curTarget.cursor,\n                    url: baseFields.pl, // 当前页面原始路径\n                    time: Date.now(), // 页面停留时长,具体到毫秒时间戳\n                    app_id: ${JSON.stringify(options.appId)}, // 小程序id\n                    app_name: ${JSON.stringify(options.appNameZH)}, // 小程序名称\n                    terminal: wxSystemInfo.osInfo(), // 终端类型 (如：iphone6)s\n                    res_type: 1 // 资源类型（1-页面，2-视频）\n                  }\n                });\n              });\n\n\n              const originalBlurMethod = e.currentTarget.dataset.originalBlurMethod;\n              originalBlurMethod&&this[originalBlurMethod].call(this, e);\n          `;\n    const injectSourceInputOnConfirm = `\n              const _es = __webpack_require__(\"./${TaroTrackLibName}.js\");\n              _es.logger('文本框输入：',e);\n              const tpr = _es.transporter(${JSON.stringify(options.transporterType)}, {\n                 baseUrl: ${JSON.stringify(options.env===\"production\"?ELKLogServerHost:TestELKLogServerHost)},\n                 query: {\n                   app_name: ${JSON.stringify(options.appName)},\n                   app_version: ${JSON.stringify(options.appVersion)},\n                   ev_type: 'web_stat'\n                 }\n              });\n              _es.commonBaseField().then(({baseFields, wxSystemInfo})=>{\n                const userInfo = _es.getUserInfo(${JSON.stringify(options.cookieKey)});\n                const curTarget = e.currentTarget;\n                tpr.send({\n                  ...baseFields,\n                  ev: 'input_confirm',\n                  v: ${JSON.stringify(options.appVersion)},\n                  app_name: ${JSON.stringify(options.appName)},\n                  app_version: ${JSON.stringify(options.appVersion)},\n                  ui: userInfo.unionId,\n                  ext: {\n                    csspath: curTarget.dataset.taroTrackCssPath,\n                    TaroTrackMd5: curTarget.dataset.taroTrackMd5,\n                    page_unique_id: userInfo.openId+'${JSON.stringify(Date.now())}', // 页面唯一id\n                    open_id: userInfo.openId, // 用户openId\n                    value: curTarget.value,\n                    cursor: curTarget.cursor,\n                    url: baseFields.pl, // 当前页面原始路径\n                    time: Date.now(), // 页面停留时长,具体到毫秒时间戳\n                    app_id: ${JSON.stringify(options.appId)}, // 小程序id\n                    app_name: ${JSON.stringify(options.appNameZH)}, // 小程序名称\n                    terminal: wxSystemInfo.osInfo(), // 终端类型 (如：iphone6)s\n                    res_type: 1 // 资源类型（1-页面，2-视频）\n                  }\n                });\n              });\n\n              const originalConfirmMethod = e.currentTarget.dataset.originalConfirmMethod;\n              originalConfirmMethod&&this[originalConfirmMethod].call(this, e);\n          `;\n    // const injectSourceInputOnKeyboardheightchange = `\n    //           const _es = __webpack_require__(\"./${TaroTrackLibName}.js\");\n    //           _es.logger('文本框键盘高度改变：',e);\n    //           const originalKeyboardheightchangeMethod = e.currentTarget.dataset.originalKeyboardheightchangeMethod;\n    //           originalKeyboardheightchangeMethod&&this[originalKeyboardheightchangeMethod].call(this, e);\n    //       `;\n\n    const eventList = [\n      {\n        name: TaroTrackPageEvent['capture-bind:tap'],\n        core: TaroTrackEventCollectionCore\n      },\n      {\n        name: TaroTrackPageEvent['bindload'],\n        core: injectSourceImageOnload\n      },\n      {\n        name: TaroTrackPageEvent['binderror'],\n        core: injectSourceImageOnError\n      },\n      {\n        name: TaroTrackPageEvent['bindinput'],\n        core: injectSourceInputOnInput\n      },\n      {\n        name: TaroTrackPageEvent['bindfocus'],\n        core: injectSourceInputOnFocus\n      },\n      {\n        name: TaroTrackPageEvent['bindblur'],\n        core: injectSourceInputOnBlur\n      },\n      {\n        name: TaroTrackPageEvent['bindconfirm'],\n        core: injectSourceInputOnConfirm\n      },\n      // {\n      //   name: TaroTrackPageEvent['bindkeyboardheightchange'],\n      //   core: injectSourceInputOnKeyboardheightchange\n      // }\n    ];\n\n    let injectSourceForDefineEvent = '', injectSourceForRegisterEvent = '';\n\n    // 将所有需要注入到页面js中的方法拼接\n    eventList.forEach(event => {\n\n      injectSourceForDefineEvent += `\n        {\n          key: \"${event.name}\",\n          value: function ${event.name}(e) {\n            ${event.core}\n          }\n       },\n      `;\n\n      injectSourceForRegisterEvent += `\"${event.name}\",`;\n\n    });\n\n    return {\n      injectSourceForDefineEvent, injectSourceForRegisterEvent\n    };\n  }\n\n  /**\n   * 在taro编译出来的叶绵绵js中注入taro-track的事件监听函数，\n   * 使得用户点击页面是能够触发该函数并进行数据上报\n   * @param {string} path     当前需注入的页面组件的路径\n   * @param {string} source   当前页面组件的js源码\n   * @returns {string}        返回注入后的源码\n   */\n  injectTaroTrackEventCaptorInPageJs(path: string, source: string): string {\n\n    const {injectSourceForDefineEvent, injectSourceForRegisterEvent} = this.eventFragment();\n\n\n    // 调用方法进行代码注入\n    return this.injectTaroTrackPageEventMethod(path, source, injectSourceForDefineEvent, injectSourceForRegisterEvent, {dolphinActiveElement: ''});\n\n  }\n\n  private injectTaroTrackEventCaptorInNpmJs(path: string, source: string): string{\n    const {injectSourceForDefineEvent, injectSourceForRegisterEvent} = this.eventFragment();\n\n    return this.injectTaroTrackNpmComponentEventMethod(path, source, injectSourceForDefineEvent, injectSourceForRegisterEvent,{});\n  }\n\n  /**\n   * 往app.wxss文件中注入全局样式\n   * @param {string} path\n   * @param {string} source\n   * @returns {string}\n   */\n  injectTaroTrackClassInAppWxss(path: string, source: string): string{\n    return `${source||\"\"}\n      .taro-track-active-element{\n        animation: TaroTrack-ani infinite linear 2s;\n      }\n\n      @keyframes TaroTrack-ani {\n        from{\n          box-shadow: none;\n        }\n        50%{\n          box-shadow: inset 0 0 100rpx #000000, 0 0 100rpx  #000000;\n        }\n        to{\n          box-shadow: none;\n        }\n      }\n    `;\n  }\n  /**\n   * 往页面的wxss文件中注入样式\n   * @param {string} path\n   * @param {string} source\n   * @returns {string}\n   */\n  injectTaroTrackClassInPageWxss(path: string, source: string): string{\n    return `${source||\"\"}`;\n  }\n  /**\n   * 往组件的wxss文件中注入样式\n   * @param {string} path\n   * @param {string} source\n   * @returns {string}\n   */\n  injectTaroTrackClassInComponentWxss(path: string, source: string): string{\n    return `${source||\"\"}`;\n  }\n\n  /**\n   * 在app.js中注入引入TaroTrackLib.js的代码\n   * @param {string} path\n   * @param {string} source\n   * @returns {string}\n   */\n  injectTaroTrackRequireLibJs(path: string, source: string): string {\n    return `require(\"./${TaroTrackLibName}\");\\n${source}`;\n  }\n\n  /**\n   * 根据正则表达式匹配文件并并将文件路径、源代码、原始文件对象传入回调\n   * @param {RegExp} type\n   * @param handler\n   * @param notFoundHandler\n   */\n  getSourceByReg(type: RegExp, handler: (filePath: string, source: string, file: { file: any, path: string })=>void, notFoundHandler?:(type: RegExp)=>void): void{\n    const sourceList = this.tfm.getFileListByFileType(type);\n    if(sourceList.length===0){\n      notFoundHandler&&notFoundHandler(type);\n      return;\n    }\n    sourceList.forEach((jsSource: { file: any, path: string }) => {\n      const { path, file } = jsSource;\n\n      const { exclude } = this.TaroTrackPluginInitOptions;\n\n      // 若传入了排除正则，则需将符合条件的路径排除\n      if(exclude){\n        if(Array.isArray(exclude)){\n          for(let i=0,len=exclude.length;i<len;i++){\n            let exc = exclude[i];\n            if(Object.prototype.toString.call(exc)===\"[object RegExp]\"){\n              // console.log(path.match(exc));\n              if(path.match(exc)){\n                return;\n              }\n            }else{\n              if(exc===path){\n                return;\n              }\n            }\n          }\n        }else{\n          if(Object.prototype.toString.call(exclude)===\"[object RegExp]\"){\n            if(path.match(exclude)){\n              return;\n            }\n          }else{\n            if(exclude===path){\n              return;\n            }\n          }\n        }\n      }\n      // console.log(exclude, path);\n\n\n      let sourceString = '';\n      if(path.indexOf('.js')>=0){\n        sourceString = file._cachedSource || file._value;\n      }else if(path.indexOf('.wxss')>=0){\n        sourceString = file.source();\n      }else if(path.indexOf('.wxml')>=0){\n        if(path.startsWith(\"components\")){\n          sourceString = file.source();\n          sourceString = Buffer.from(sourceString).toString('utf-8');\n        }else{\n          sourceString = Buffer.from(file._value).toString('utf-8');\n        }\n      }\n      handler&&handler(path, sourceString, file);\n    });\n  }\n\n  /**\n   * 对代码进行压缩\n   * @param {string} source\n   * @returns {string}\n   */\n  public miniFile(source: string): string{\n    return source.replace(miniFileReg, '');\n  }\n\n  /**\n   * 处理所有的页面js文件，进行代码注入\n   */\n  buildPageJs(): Promise<void> {\n\n    return new Promise(resolve => {\n\n      this.getSourceByReg(/^pages(.*)\\.js$/, async (filePath: string, source: string, file: { file: any, path: string }) => {\n        logger.loading(`【PageJs:${filePath}】编译中...`);\n        const newSource = this.injectTaroTrackEventCaptorInPageJs(filePath, source);\n\n        const emit = (newSource: string) => {\n          // newSource = this.miniFile(newSource);\n          const outputPath = `${this.tfm.getOutputPath()}/${filePath}`;\n          this.tfm.outputFile(`${outputPath}`, newSource);\n          logger.success(`【PageJs:${filePath}】编译完成！`);\n          resolve();\n        };\n\n        // 执行hooks\n        if (this.TaroTrackPluginInitOptions.pageJsHooks) {\n          logger.loading(`【PageJs:${filePath}】执行【pageJsHooks】...`);\n          try{\n            await this.TaroTrackPluginInitOptions.pageJsHooks(filePath, newSource, emit, \"pagejs\");\n          }catch (e) {\n            logger.error('执行[pageJsHooks]错误', e);\n          }\n\n        } else {\n          emit(newSource);\n        }\n      },()=>resolve());\n    });\n  }\n\n  /**\n   * todo 往组件js中注入监听函数实现at-input输入监听\n   * @returns {Promise<void>}\n   */\n  buildNpmComponentJs(): Promise<void>{\n    return new Promise(resolve => {\n\n      this.getSourceByReg(/^npm\\/taro-ui\\/dist\\/weapp\\/components(.*)\\.js$/, async (filePath: string, source: string, file: { file: any, path: string }) => {\n        logger.loading(`【ComponentJs:${filePath}】编译中...`);\n        const newSource = this.injectTaroTrackEventCaptorInNpmJs(filePath, source);\n\n        const emit = (newSource: string) => {\n          // newSource = this.miniFile(newSource);\n          const outputPath = `${this.tfm.getOutputPath()}/${filePath}`;\n          this.tfm.outputFile(`${outputPath}`, newSource);\n          logger.success(`【ComponentJs:${filePath}】编译完成！`);\n          resolve();\n        };\n\n        // 执行hooks\n        if (this.TaroTrackPluginInitOptions.npmComponentJsHooks) {\n          logger.loading(`【ComponentJs:${filePath}】执行【componentJsHooks】...`);\n          try{\n            await this.TaroTrackPluginInitOptions.npmComponentJsHooks(filePath, newSource, emit, \"commonjs\");\n          }catch (e) {\n            logger.error('执行[componentJsHooks]错误', e);\n          }\n\n        } else {\n          emit(newSource);\n        }\n      }, ()=>resolve());\n    });\n  }\n\n  /**\n   * 构建TaroTrackLib.js,并在taro的输出目录生成对应文件\n   * @returns {Promise<void>}\n   */\n  buildTaroTrackLibJs(): Promise<void> {\n\n    return new Promise<void>(async resolve => {\n      logger.loading(`【TaroTrackLib:${TaroTrackLibName}.js】编译中...`);\n      const newSource = this.injectTaroTrackLibJs();\n\n      const emit = (newSource: string) => {\n        // newSource = this.miniFile(newSource);\n        const outputPath = `${this.tfm.getOutputPath()}/${TaroTrackLibName}.js`;\n        this.tfm.outputFile(`${outputPath}`, newSource);\n        logger.success(`【TaroTrackLib:${TaroTrackLibName}.js】编译完成！`);\n        resolve();\n      };\n\n\n      // 执行hooks\n      if (this.TaroTrackPluginInitOptions.dolphinLibJsHooks) {\n        logger.loading(`【TaroTrackLib:${TaroTrackLibName}】执行【commonJsHooks】...`);\n        try{\n          await this.TaroTrackPluginInitOptions.dolphinLibJsHooks(`${TaroTrackLibName}.js`, newSource, emit, \"TaroTrackLib\");\n        }catch (e) {\n          logger.error('执行[commonJsHooks]错误', e);\n        }\n\n      } else {\n        emit(newSource);\n      }\n\n    });\n  }\n\n  /**\n   * 编译app.js文件，并注入必要的代码\n   * @returns {Promise<void>}\n   */\n  buildAppJs(): Promise<void> {\n    return new Promise(resolve => {\n\n      this.getSourceByReg(/^app\\.js$/, async (filePath: string, source: string, file: { file: any, path: string }) => {\n        logger.loading(`【AppJs:${filePath}】编译中...`);\n        const newSource = this.injectTaroTrackRequireLibJs(filePath, source);\n        const emit = (newSource: string) => {\n          // newSource = this.miniFile(newSource);\n          const outputPath = `${this.tfm.getOutputPath()}/${filePath}`;\n          this.tfm.outputFile(`${outputPath}`, newSource);\n          logger.success(`【AppJs:${filePath}】编译完成！`);\n          resolve();\n        };\n\n        // 执行hooks\n        if (this.TaroTrackPluginInitOptions.appJsHooks) {\n          logger.loading(`【AppJs:${filePath}】执行【appJsHooks】...`);\n          try{\n            await this.TaroTrackPluginInitOptions.appJsHooks(filePath, newSource, emit, \"appjs\");\n          }catch (e) {\n            logger.error('执行[appJsHooks]错误', e);\n          }\n\n        } else {\n          emit(newSource);\n        }\n\n      },()=>resolve());\n\n    });\n\n  }\n\n  /**\n   * 往页面wxss和app.wxss中注入样式代码\n   * @returns {Promise<void>}\n   */\n  buildWXSS(): Promise<void>{\n    return new Promise<void>(resolve => {\n\n      this.getSourceByReg(/\\.wxss$/, async (filePath: string, source: string, file: { file: any, path: string }) => {\n        logger.loading(`【Wxss:${filePath}】编译中...`);\n        let newSource = '';\n        if(filePath.startsWith(\"pages\")){// 页面样式\n          newSource = this.injectTaroTrackClassInPageWxss(filePath, source);\n        }else if(filePath.indexOf('app.wxss')>=0){\n          newSource = this.injectTaroTrackClassInAppWxss(filePath, source);\n        }else{\n          newSource = this.injectTaroTrackClassInComponentWxss(filePath, source);\n        }\n\n        const emit = (newSource: string) => {\n          // 压缩代码\n          newSource = this.miniFile(newSource);\n          const outputPath = `${this.tfm.getOutputPath()}/${filePath}`;\n          this.tfm.outputFile(`${outputPath}`, newSource);\n          logger.success(`【Wxss:${filePath}】编译完成！`);\n          resolve();\n        };\n\n        // 执行hooks\n        if (this.TaroTrackPluginInitOptions.wxssHooks) {\n          logger.loading(`【Wxss:${filePath}】执行【wxssHooks】...`);\n          try{\n            await this.TaroTrackPluginInitOptions.wxssHooks(filePath, newSource, emit, filePath.startsWith('pages')?\"pageWxss\":\"componentWxss\");\n          }catch (e) {\n            logger.error('执行[wxssHooks]错误', e);\n          }\n\n        } else {\n          emit(newSource);\n        }\n\n      },()=>resolve());\n    });\n  }\n\n\n  /**\n   * 处理所有页面和组件的wxml,并进行代码注入\n   */\n  buildWXML(): Promise<any> {\n\n    return new Promise((resolve, reject) => {\n\n      this.getSourceByReg(/\\.wxml$/, async (filePath: string, source: string, file: { file: any, path: string }) => {\n        logger.loading(`【WXML:${filePath}】编译中...`);\n        // 将源代码字符串转换为json对象\n\n        let xml = wxml2json(source);\n        let sourceString = JSON.stringify(xml);\n\n        // 寻找当前wxml的真实根节点\n        // let roots: any[] = [];\n        // WXMLHelper.findWXMLRealRoot(xml, roots);\n        // const root = roots[0];\n        let root = xml;\n\n        try {\n\n          // console.log(source);\n          // 在页面根节点注入全局事件监听方法\n          WXMLHelper.findWXMLRealRoot(xml, async realRoot=>{\n            const realRootString = JSON.stringify(realRoot);\n            // console.log('真正的根节点', realRoot);\n            realRoot = this.injectTaroTrackEventCaptorInPageRoot(realRoot);\n\n            // 为所有的元素节点注入class:taro-track-element，方便定位点击的是哪一个元素\n            realRoot = await this.injectTaroTrackElementClassNameInWXML(realRoot);\n\n            xml = sourceString.replace(realRootString, JSON.stringify(realRoot));\n\n            xml = json2wxml(JSON.parse(xml));\n            xml = wxml2json(xml);\n\n            // 为图片注入onload方法监听图片的加载\n            xml = await this.injectTaroTrackImageOnLoadInWXML(xml);\n            // 为页面所有的input的方法添加监听\n            xml = await this.injectTaroTrackInputEventInWXML(xml);\n\n            // console.log('====>', JSON.stringify(xml, null, 4));\n\n            // console.log(xml);\n\n            // console.log(JSON.stringify(realRoot, null, 4),JSON.stringify(xml, null, 4));\n\n            const emit = (newSource: string) => {\n              // 注入已完成，将json重新转换为wxml\n              let newXml = json2wxml(newSource);\n\n              newXml = this.miniFile(newXml);\n\n              // 输出文件内容\n              const outputPath = `${this.tfm.getOutputPath()}/${filePath}`;\n              this.tfm.outputFile(`${outputPath}`, newXml);\n              logger.success(`【WXML:${filePath}】编译完成！`);\n              resolve();\n            };\n\n            // 执行hooks\n            if (this.TaroTrackPluginInitOptions.wxmlLHooks) {\n              logger.loading(`【WXML:${filePath}】执行【wxmlLHooks】...`);\n              try{\n                await this.TaroTrackPluginInitOptions.wxmlLHooks(filePath, xml, emit, filePath.startsWith('pages')?\"pageWxml\":\"componentWxml\");\n              }catch (e) {\n                logger.error('执行[wxmlLHooks]错误', e);\n                emit(xml);\n              }\n\n            } else {\n              emit(xml);\n            }\n\n          });\n        } catch (e) {\n          console.error('wxml文件解析失败', e);\n          reject(e);\n        }\n      },()=>resolve());\n\n    });\n\n  }\n\n  /**\n   * 初始化Taro文件管理器\n   * @param stats\n   */\n  initTfm(stats: any) {\n    if (!this.tfm) {\n      this.tfm = new TaroFileManager(stats);\n    } else {\n      this.tfm.updateCtx(stats);\n    }\n  }\n\n  /**\n   * 进行所有文件的处理工作\n   */\n  async build() {\n    await this.buildWXML();\n    await this.buildAppJs();\n    await this.buildTaroTrackLibJs();\n    await this.buildPageJs();\n    await this.buildNpmComponentJs();\n    await this.buildWXSS();\n  }\n\n  /**\n   * 初始化\n   * @param stats\n   */\n  async initInjector(stats: any) {\n    this.initTfm(stats);\n    await this.build();\n  }\n\n}\n\nexport const findRealRootInWXML = WXMLHelper.findWXMLRealRoot;\nexport const findElementAllInWXML = WXMLHelper.findElementAll;\nexport const findElementInWXML = WXMLHelper.findElement;\n","\nexport const WXMLTaroTrackAttr = {\n  TaroTrackInfo: 'data-taro-track-data-info',\n  parentDeepIndex: 'taro-track-parent-deep-index',\n  deepIndex: 'taro-track-deep-index',\n  tag: 'data-taro-track-tag',\n  id: 'data-taro-track-id',\n  parentCssPath: 'taro-track-parent-css-path',\n  childDeepIndex: 'taro-track-child-deep-index',\n  cssPath: 'data-taro-track-css-path',\n  text: 'data-taro-track-text',\n  md5: 'data-taro-track-md5',\n};\n\n/**\n * @date 2020-09-12\n * @author kinertang\n * @description 用户辅助操作WXML的工具类\n */\nexport class WXMLHelper {\n  private root: any;\n\n  constructor(xml: any) {\n    this.root = xml;\n  }\n\n  /**\n   * 查找wxml的真实根节点（非block）\n   * @param xml\n   * @param  handler\n   */\n  public static findWXMLRealRoot(xml: any, handler: (root: any)=>void): void {\n\n    if (xml.type === 'element' && ['cover-view', 'movable-view', 'movable-area', 'scroll-view', 'swiper', 'swiper-item', 'view'].indexOf(xml.tag) >= 0) {\n      // console.log(`发现根元素元素：`, xml);\n      handler(xml);\n      return;\n    } else if (Array.isArray(xml)) {\n      xml.forEach(child => WXMLHelper.findWXMLRealRoot(child, handler));\n    } else {\n      const children = xml.children;\n      if (children) {\n        WXMLHelper.findWXMLRealRoot(children, handler);\n      } else {\n        WXMLHelper.findWXMLRealRoot(xml, handler);\n      }\n    }\n  }\n\n  /**\n   * 递归查找所有的真实元素节点（block节点除外）\n   * 每当找到一个真实元素节点便会触发cb回调，并将当前元素的tag和当前元素作为参数传回\n   * 若cb的返回值为false时终止继续递归查询\n   * @param root\n   * @param {(elementName: string, element: any) => (boolean | void)} cb\n   * @param mask 是否在元素上添加一些标记用以数据上报\n   */\n  public static findWXMLElement(root: any, cb: (elementName: string, element: any) => boolean | void, mask: boolean = false) {\n    let TaroTrackInfo:any;\n    if (root.type === 'root'||root.type === 'element') {\n      // console.log('是否标记：', mask);\n      // 当mask为true时，默认会对所有的标签打标记，这样就可以在查找的同时进行标记，节省了重复标记的时间\n      if (mask) {\n        if (!root.attr) {\n          root.attr = {};\n        }\n        if(root.attr[WXMLTaroTrackAttr.TaroTrackInfo]){\n          try{\n            TaroTrackInfo = JSON.parse(decodeURIComponent(root.attr[WXMLTaroTrackAttr.TaroTrackInfo]));\n          }catch (e) {\n            TaroTrackInfo = {};\n          }\n\n        }else{\n          TaroTrackInfo = {};\n        }\n        if (TaroTrackInfo[WXMLTaroTrackAttr.deepIndex] === undefined) {\n          TaroTrackInfo[WXMLTaroTrackAttr.deepIndex] = 0;\n        } else {\n          TaroTrackInfo[WXMLTaroTrackAttr.deepIndex] = TaroTrackInfo[WXMLTaroTrackAttr.parentDeepIndex] + 1;\n        }\n        const csspath = `${root.tag}_${TaroTrackInfo[WXMLTaroTrackAttr.deepIndex]}${TaroTrackInfo[WXMLTaroTrackAttr.childDeepIndex] ? `_${TaroTrackInfo[WXMLTaroTrackAttr.childDeepIndex]}` : '_0'}`;\n\n        let wxForIndex = root.attr[\"wx:for-index\"];\n        let classPath = (root.attr.class || '');\n        let dynamicClassReg = /\\{\\{([^\\}]*)\\}\\}/g;\n        classPath = classPath.replace(dynamicClassReg,'');\n\n        classPath.split(' ').filter((item: string)=>!!item).join('.');\n        // classPath = '';\n        let idPath = (root.attr.id || '');\n        let parentCssPath = `${TaroTrackInfo[WXMLTaroTrackAttr.parentCssPath] ? `${TaroTrackInfo[WXMLTaroTrackAttr.parentCssPath]}>` : 'page>'}`;\n        classPath = classPath ? `.${classPath}` : '';\n        idPath = idPath?`#${idPath}`:'';\n\n        const realCssPath = `${parentCssPath}${csspath}${idPath}${classPath}`;\n\n        // console.log(root);\n        root.attr[WXMLTaroTrackAttr.tag] = TaroTrackInfo[WXMLTaroTrackAttr.tag] = root.tag;\n        // console.log(root.type, root);\n\n        if(root.children&&Array.isArray(root.children)){\n          const texts = root.children.filter((item:any)=>{\n            // console.log(item.text, dynamicClassReg.test(item.text));\n            return item.type===\"text\"\n          });\n          root.attr[WXMLTaroTrackAttr.text] = TaroTrackInfo[WXMLTaroTrackAttr.text] = texts.map((item: any)=>{\n            // if(dynamicClassReg.test(item.text)&&!wxForIndex){\n            //   return encodeURIComponent(item.text);\n            // }else{\n              return item.text.replace(/\\r\\n/g,\"\\\\n\").replace(/\\n/g,\"\");\n            // }\n\n          }).join(' ').trim().replace('\"',\"'\");\n        }\n\n\n        root.attr[WXMLTaroTrackAttr.id] = TaroTrackInfo[WXMLTaroTrackAttr.id] = root.attr.id || '';\n        // 由于插件是在node环境下运行的，因此，需要使用nodejs内置的库需要使用require\n        const crypto = require('crypto');\n        const md5 = crypto.createHash('md5');\n        md5.update(realCssPath);\n        let md5Str = md5.digest('hex');\n        md5Str = `md5-${md5Str}`;\n        let md5StrNotDynamicArg = `'${md5Str}'`;\n        if(wxForIndex){\n          md5StrNotDynamicArg = `'${md5Str}_'+${wxForIndex}`;\n          md5Str+=`_{{${wxForIndex}}}`;\n        }\n\n        // console.log(realCssPath, md5Str);\n\n        root.attr[WXMLTaroTrackAttr.md5] = TaroTrackInfo[WXMLTaroTrackAttr.md5] = md5Str;\n        if(!root.attr.class){\n          root.attr.class = '';\n        }\n        // 加上带有md5的class后，我们便可以通过在调试工具中运行以下代码获取元素的信息\n        // var query = wx.createSelectorQuery();\n        // var nodes = query.selectAll('.md5-b0df029f')\n        // nodes.boundingClientRect();\n        // nodes.fields({\n        //       dataset: true,\n        //       size: true,\n        //       scrollOffset: true,\n        //       properties: ['scrollX', 'scrollY'],\n        //       computedStyle: ['margin', 'backgroundColor'],\n        //       context: true,\n        //     });\n        // query.exec(function([rect, fields]){console.log({fields: fields[0], rect: rect[0]})});\n        // wx.pageScrollTo({selector: '.md5-b0df029f'});\n        // 或\n        // wx.TaroTrack.showViewBySelector(\".md5-71dfd94e5b6be8040bacb4098be239e4\");\n        root.attr.class += ` ${md5Str} {{dolphinActiveElement===${md5StrNotDynamicArg}?' taro-track-active-element':''}}`;\n        root.attr[WXMLTaroTrackAttr.cssPath] = TaroTrackInfo[WXMLTaroTrackAttr.cssPath] = realCssPath;\n        root.attr[WXMLTaroTrackAttr.TaroTrackInfo] = encodeURIComponent(JSON.stringify(TaroTrackInfo));\n      }\n\n      const isContinue = cb && cb(root.tag, root);\n      if (root.children && isContinue !== false) {\n        root.children.forEach((child: any, index: number) => {\n          if(mask){\n            if (!child.attr) {\n              child.attr = {};\n            }\n\n            let childTaroTrackInfo: any;\n            if(child.attr[WXMLTaroTrackAttr.TaroTrackInfo]){\n              childTaroTrackInfo = decodeURIComponent(root.attr[WXMLTaroTrackAttr.TaroTrackInfo]);\n            }else{\n              childTaroTrackInfo = {};\n            }\n            childTaroTrackInfo[WXMLTaroTrackAttr.parentCssPath] = TaroTrackInfo[WXMLTaroTrackAttr.cssPath];\n            childTaroTrackInfo[WXMLTaroTrackAttr.parentDeepIndex] = TaroTrackInfo[WXMLTaroTrackAttr.deepIndex];\n            childTaroTrackInfo[WXMLTaroTrackAttr.childDeepIndex] = index;\n            child.attr[WXMLTaroTrackAttr.TaroTrackInfo] = encodeURIComponent(JSON.stringify(childTaroTrackInfo));\n\n          }\n\n          WXMLHelper.findWXMLElement(child, cb, mask);\n        });\n      }\n    }\n  }\n\n  /**\n   * 根据id|class|tag查找元素\n   * @param root\n   * @param {string} selector\n   * @returns {Promise<any>}\n   */\n  public static findElement(root: any, selector: string): Promise<any>{\n    return new Promise<any>(resolve => {\n      if(selector.startsWith('#')){// id\n        WXMLHelper.findWXMLElement(root, ((elementName, element) => {\n          if(element.attr.id===selector.substring(1)){\n            resolve(element);\n            return false;\n          }\n        }),false);\n      }else if(selector.startsWith('.')){// class\n        WXMLHelper.findWXMLElement(root, ((elementName, element) => {\n          if(element.attr.class.split(' ').includes(selector.substring(1))){\n            resolve(element);\n            return false;\n          }\n        }),false);\n      }else{// tagName\n        WXMLHelper.findWXMLElement(root, ((elementName, element) => {\n          if(selector===elementName){\n            resolve(element);\n            return false;\n          }\n        }),false);\n      }\n    });\n  }\n  /**\n   * 根据id|class|tag查找元素\n   * @param root\n   * @param {string} selector\n   * @returns {Promise<any>}\n   */\n  public static findElementAll(root: any, selector: string): Promise<any[]>{\n    let res: any[] = [];\n    return new Promise<any[]>(resolve => {\n      // console.log('查询元素', root, selector);\n      if(selector.startsWith('#')){// id\n        WXMLHelper.findWXMLElement(root, ((elementName, element) => {\n          if(element.attr.id===selector.substring(1)){\n            res.push(element);\n          }\n        }),false);\n      }else if(selector.startsWith('.')){// class\n        WXMLHelper.findWXMLElement(root, ((elementName, element) => {\n          if(element.attr.class.split(' ').includes(selector.substring(1))){\n            res.push(element);\n          }\n        }),false);\n      }else{// tagName\n        WXMLHelper.findWXMLElement(root, ((elementName, element) => {\n          // console.log(elementName, element);\n          if(selector===elementName){\n            res.push(element);\n          }\n        }),false);\n      }\n      resolve(res);\n    });\n\n  }\n  /**\n   * 查找并更新目标元素的属性\n   * @param root\n   * @param {string} selector\n   * @param attr\n   * @returns {Promise<any>}\n   */\n  public static updateElementAttrAll(root: any, selector: string, attr: any): void{\n    if(selector.startsWith('#')){// id\n      WXMLHelper.findWXMLElement(root, ((elementName, element) => {\n        if(element.attr.id===selector.substring(1)){\n          element.attr = attr;\n        }\n      }),false);\n    }else if(selector.startsWith('.')){// class\n      WXMLHelper.findWXMLElement(root, ((elementName, element) => {\n        if(element.attr.class.split(' ').includes(selector.substring(1))){\n          element.attr = attr;\n        }\n      }),false);\n    }else{// tagName\n      WXMLHelper.findWXMLElement(root, ((elementName, element) => {\n        if(selector===elementName){\n          element.attr = attr;\n        }\n      }),false);\n    }\n\n  }\n\n}\n\n/**\n * 再重新将文件输出到wxml之前，先将一些不必要的属性去掉\n * @param root\n * @param tmp\n */\nexport function filterWXMLTaroTrackAttr(root: any){\n  if(root.attr&&root.attr[WXMLTaroTrackAttr.TaroTrackInfo]){\n    // console.log('准备删除：',key,root.attr[key]);\n    delete root.attr[WXMLTaroTrackAttr.TaroTrackInfo];\n  }\n  if(root.children){\n    root.children.forEach((child: any) => {\n      filterWXMLTaroTrackAttr(child);\n    });\n  }\n  return root;\n}\n","/**\n * 库文件源码构建器\n * @author kinertang\n * @description 本文件用于在微信小程序中创建库文件，并提供基础模版，使用者只需调用createWxModuleSourceFragment传入具体逻辑代码即可\n * 如：\n * createWxModuleSourceFragment(\n *    `\n *        exports.logger = function(msg,...rest){\n *             const label = '['+exports.config.TaroTrackLoggerNamespace+':Plugin] '+msg;\n *             console.groupCollapsed(label);\n *             rest.forEach(item=>{\n *               console.log(item);\n *             });\n *             console.groupEnd();\n *           }\n *    `\n * )\n *\n *\n */\nimport { TaroTrackLibName } from '@kiner/taro-track-common';\n\nconst injectSymbol = `/////////inject/////////`;\nconst fragment = `\n  (wx[\"webpackJsonp\"] = wx[\"webpackJsonp\"] || []).push([\n  [\"${TaroTrackLibName}\"],\n  {\n    \"./${TaroTrackLibName}.js\": function(\n      module,\n      exports,\n      __webpack_require__\n    ) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      ${injectSymbol}\n\n\n    }\n  }\n]);\n\n`;\n\nexport function createWxModuleSourceFragment(core: string): string {\n\n  return fragment.replace(injectSymbol, core);\n\n}\n","/**\n * 通过测试的taro版本，建议开发时使用指定版本的taro,以免版本不一致导致一些问题\n * 插件运行时用户taro版本不是指定版本会警告提示\n * @type {string}\n */\nexport const taroTargetVersion = '2.1.5';\nexport const packageName = '@kiner/taro-track-main';\nexport const packageNameCommon = '@kiner/taro-track-common';\nexport const packageNameCore = '@kiner/taro-track-corejs';\nexport const packageNameDatasource = '@kiner/taro-track-datasource';\nexport const packageNameEntry = '@kiner/taro-track-entrypoint';\nexport const packageNamePlugins = '@kiner/taro-track-plugins';\nexport const packageNameTransporter = '@kiner/taro-track-transporter';\n// export const packageName = '@taro-track';\n","export * from './TaroTrackPlugin';\nexport * from './TaroTrackSourceInjector';\nexport * from './TaroFileManager';\nexport * from './TaroTrackInjectLib';\nexport * from './WxMoudleSourceFragment';\nexport * from './WXMLHelper';\n\n","//Crucial Change\n// Regular Expressions for parsing tags and attributes\n//这里的startTag和attr不需要改，在2sjon文件里改就可以了\nconst startTag = /^<([-A-Za-z0-9_]+)((?:\\s+[a-zA-Z_:][-a-zA-Z0-9_:.]*(?:\\s*=\\s*(?:(?:\"[^\"]*\")|(?:'[^']*')|[^>\\s]+))?)*)\\s*(\\/?)>/,\n  endTag = /^<\\/([-A-Za-z0-9_]+)[^>]*>/,\n  attr = /([a-zA-Z_:][-a-zA-Z0-9_:.]*)(?:\\s*=\\s*(?:(?:\"((?:\\\\.|[^\"])*)\")|(?:'((?:\\\\.|[^'])*)')|([^>\\s]+)))?/g;\n\n//Crucial Change\n// Empty Elements - HTML 5\nconst empty = makeMap(\"input,image,map\");\n// empty = makeMap(\"view,scrollview,swiper,icon,text,progress,button,action-sheet,form,modal,input,progress,checkbox,toast,radio,picker,slider,navigator,switch,label,audio,map,image,video,canvas\");\n// Block Elements - HTML 5\nconst block = makeMap(\"block,view,scrollview,swiper,icon,text,progress,button,action-sheet,form,modal,input,progress,checkbox,toast,radio,picker,slider,navigator,switch,label,audio,map,image,video,canvas\");\n\n// Inline Elements - HTML 5\n// 解决button标签闭合bug\nconst inline = makeMap(\"icon,progress,input,image,map\");\n\n// const inline = makeMap(\"icon,progress,button,input,image,map\");\n// inline = makeMap(\"view,scrollview,swiper,icon,text,progress,button,action-sheet,form,modal,input,progress,checkbox,toast,radio,picker,slider,navigator,switch,label,audio,map,image,video,canvas\");\n// Elements that you can, intentionally, leave open\n// (and which close themselves)\n//微信小程序里没有可以不闭合的标签\nconst closeSelf = makeMap(\"\");\n\n// Attributes that have their values filled in disabled=\"disabled\"\n//填充的属性可以后面再解析出来\nconst fillAttrs = makeMap(\"\");\n\n// Special Elements (can contain anything)\nconst special = makeMap(\"wxxxcode-style,script,style\");\n\nexport function makeMap(str: string) {\n  const obj:any = {}, items = str.split(\",\");\n  for (let i = 0; i < items.length; i++)\n    obj[items[i]] = true;\n  return obj;\n}\n\nexport interface HtmlParserHanderStruct {\n  start(tag:string, attrs: any, unary: boolean): void;\n  end(tag: string): void;\n  chars(text: string): void;\n  comment(text: string): void;\n}\n\nexport function HTMLParser(html: string, handler:HtmlParserHanderStruct) {\n  let index, chars, match, stack:any = [], last = html;\n  stack.last = function () {\n    return this[this.length - 1];\n  };\n  while (html) {\n    chars = true;\n\n    // Make sure we're not in a script or style element\n    if (!stack.last() || !special[stack.last()]) {\n\n      // Comment\n      if (html.indexOf(\"<!--\") == 0) {\n        index = html.indexOf(\"-->\");\n        if (index >= 0) {\n          if (handler.comment)\n            handler.comment(html.substring(4, index));\n          html = html.substring(index + 3);\n          chars = false;\n        }\n\n        // end tag\n      } else if (html.indexOf(\"</\") == 0) {\n        match = html.match(endTag);\n\n        if (match) {\n          html = html.substring(match[0].length);\n          // @ts-ignore\n          match[0].replace(endTag, parseEndTag);\n          chars = false;\n        }\n\n        // start tag\n      } else if (html.indexOf(\"<\") == 0) {\n        match = html.match(startTag);\n\n        if (match) {\n          html = html.substring(match[0].length);\n          // @ts-ignore\n          match[0].replace(startTag, parseStartTag);\n          chars = false;\n        }\n      }\n\n      if (chars) {\n        index = html.indexOf(\"<\");\n\n        let text = index < 0 ? html : html.substring(0, index);\n        html = index < 0 ? \"\" : html.substring(index);\n\n        if (handler.chars)\n          handler.chars(text);\n      }\n\n    } else {\n      html = html.replace(new RegExp(\"([\\\\s\\\\S]*?)<\\/\" + stack.last() + \"[^>]*>\"), function (all, text) {\n        text = text.replace(/<!--([\\s\\S]*?)-->|<!\\[CDATA\\[([\\s\\S]*?)]]>/g, \"$1$2\");\n        if (handler.chars)\n          handler.chars(text);\n\n        return \"\";\n      });\n\n      parseEndTag(\"\", stack.last());\n    }\n\n    if (html == last){\n      // console.log(html)\n      throw \"Parse Error: \" + html;\n    }\n    last = html;\n  }\n\n  // Clean up any remaining tags\n  parseEndTag();\n\n  function parseStartTag(tag: string, tagName: string, rest: string, unary: boolean) {\n    tagName = tagName.toLowerCase();\n\n    if (block[tagName]) {\n      while (stack.last() && inline[stack.last()]) {\n        parseEndTag(\"\", stack.last());\n      }\n    }\n\n    if (closeSelf[tagName] && stack.last() == tagName) {\n      parseEndTag(\"\", tagName);\n    }\n\n    unary = empty[tagName] || !!unary;\n\n    if (!unary)\n      stack.push(tagName);\n\n    if (handler.start) {\n      const attrs:any[] = [];\n\n      // @ts-ignore\n      rest.replace(attr, function (match, name) {\n        const value = arguments[2] ? arguments[2] :\n          arguments[3] ? arguments[3] :\n            arguments[4] ? arguments[4] :\n              fillAttrs[name] ? name : \"\";\n\n        attrs.push({\n          name: name,\n          value: value,\n          escaped: value.replace(/(^|[^\\\\])\"/g, '$1\\\\\\\"') //\"\n        });\n      });\n\n      if (handler.start)\n        handler.start(tagName, attrs, unary);\n    }\n  }\n\n  function parseEndTag(tag?: string, tagName?: string) {\n    // If no tag name is provided, clean shop\n    let pos = 0;\n    if (!tagName)\n      pos = 0;\n\n    // Find the closest opened tag of the same type\n    else\n      for (pos = stack.length - 1; pos >= 0; pos--)\n        if (stack[pos] == tagName)\n          break;\n\n    if (pos >= 0) {\n      // Close all the open elements, up the stack\n      for (let i = stack.length - 1; i >= pos; i--)\n        if (handler.end)\n          handler.end(stack[i]);\n\n      // Remove the open elements from the stack\n      stack.length = pos;\n    }\n  }\n}\n","// @ts-ignore\nconst {HTMLParser} = require('./htmlParser');\n\nfunction q(v:string) {\n  return '\"' + v + '\"';\n}\n\n//Crucial Change\nfunction removeDOCTYPE(html: string) {\n  return html\n    .replace(/<\\?xml.*\\?>\\n/, '')\n    .replace(/<!doctype.*\\>/i, '')\n    .replace(/<!DOCTYPE.*\\>/, '');\n}\n\ninterface NodeStruct {\n  type?: string,\n  tag?: string,\n  attr?: Record<string, any>\n  text?: string\n  children?: NodeStruct[]\n}\n\nexport function wxml2json(html: string): any {\n  html = removeDOCTYPE(html);\n  const bufArray:NodeStruct[] = [];\n  const results:NodeStruct = {\n    type: 'root',\n    children: [],\n  };\n  HTMLParser(html, {\n    start: function(tag:string, attrs: any, unary: boolean) {\n      // type for this element\n      const type:NodeStruct = {\n        type: 'element',\n        tag: tag,\n      };\n\n      if (attrs.length !== 0) {\n        type.attr = attrs.reduce(function(pre:any, attr:any) {\n          const name = attr.name;\n          const value = attr.value;\n\n          // has multi attibutes\n          // make it array of attribute\n\n          //Crucial Change\n          // 微信小程序的属性里面可以有变量及代码，可以有空格\n          // if (value.match(/ /)) {\n          //   value = value.split(' ');\n          // }\n\n          // if attr already exists\n          // merge it\n          if (pre[name]) {\n            if (Array.isArray(pre[name])) {\n              // already array, push to last\n              pre[name].push(value);\n            } else {\n              // single value, make it array\n              pre[name] = [pre[name], value];\n            }\n          } else {\n            // not exist, put it\n            pre[name] = value;\n          }\n\n          return pre;\n        }, {});\n      }\n      if (unary) {\n        // if this tag dosen't have end tag\n        // like <img src=\"hoge.png\"/>\n        // add to parents\n        const parent = bufArray[0] || results;\n        if (parent.children === undefined) {\n          parent.children = [];\n        }\n        parent.children.push(type);\n      } else {\n        bufArray.unshift(type);\n      }\n    },\n    end: function(tag: string) {\n      // merge into parent tag\n      const type = bufArray.shift();\n      if (type.tag !== tag) console.error('invalid state: mismatch end tag');\n      if (bufArray.length === 0) {\n        results.children.push(type);\n      } else {\n        let parent = bufArray[0];\n        if (parent.children === undefined) {\n          parent.children = [];\n        }\n        parent.children.push(type);\n      }\n    },\n    chars: function(text: string) {\n      const type: NodeStruct = {\n        type: 'text',\n        text: text,\n      };\n      if (bufArray.length === 0) {\n        //Crucial Change\n        if(type.text.replace(/ /g, '').replace(/\\r/g, '').replace(/\\n/g, '').replace(/\\t/g, '') !=='' && type.text!=='')\n          results.children.push(type);\n      } else {\n        const parent = bufArray[0];\n        if (parent.children === undefined) {\n          parent.children = [];\n        }\n        //都为空格时不加入节点\n        //Crucial Change\n        if(type.text.replace(/ /g, '').replace(/\\r/g, '').replace(/\\n/g, '').replace(/\\t/g, '') !=='' && type.text!=='')\n          parent.children.push(type);\n      }\n    },\n    comment: function(text: string) {\n      const type = {\n        type: 'comment',\n        text: text,\n      };\n      const parent = bufArray[0];\n      //Crucial Change\n      let _parent:NodeStruct = parent || {};\n      if (_parent.children === undefined) {\n        _parent.children = [];\n      }\n      _parent.children.push(type);\n    },\n  });\n  return results;\n}\n","module.exports = require(\"assert\");","module.exports = require(\"child_process\");","module.exports = require(\"constants\");","module.exports = require(\"crypto\");","module.exports = require(\"events\");","module.exports = require(\"fs\");","module.exports = require(\"os\");","module.exports = require(\"path\");","module.exports = require(\"stream\");","module.exports = require(\"util\");"],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACTA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvJA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACfA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrFA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;;;;;;;;;;;;ACFA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxBA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtCA;AAAA;;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACVA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpCA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACVA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9CA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3DA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7EA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnLA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjFA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7EA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtBA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9CA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;;;;;;;;;;;;;ACHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;;;;;;;;;;;;;ACHA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnBA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1CA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACVA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxBA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxFA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7EA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9HA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChCA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;;;;;;;;;;;;ACFA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5BA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1GA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;ACDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC1BA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACxMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AClNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC7GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC7GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC/pDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3yBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrKA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvOA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5IA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9CA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC9SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC/OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACrxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACreA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACjWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACrHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACrVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC15BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACrFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACndA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC/SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC1GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACrHA;;;;;;;;;;;;ACAA;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACxMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC/EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC9GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3vUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/QA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3nBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChlDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACr6DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxwBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtQA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChCA;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACjYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACrMA;;;;;;;;;;;;;;;;;;;;;;;;;ACAA;;;;;;;;;;;;;;;;ACAA;AAMA;AAUA;AARA;AAEA;AAOA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;AAEA;AACA;AAIA;AACA;AAAA;AACA;AACA;AAGA;AACA;AA/FA;;;;;;;;;;;;;;;;ACNA;AACA;AAGA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;;;;;;;;;AASA;AACA;AAXA;AAcA;AACA;;;;;;;;AAQA;AACA;AAVA;AAaA;AACA;;;;;;;;;;AAUA;AACA;AAZA;AAeA;AACA;;;;;;;;;;AAUA;AACA;AAZA;AAeA;AACA;;;;;;;;;AASA;AACA;AAXA;AAcA;AACA;;;AAGA;;;;;;;;;;;AAWA;AACA;AAhBA;AAmBA;AACA;;;AAGA;;;AAGA;;;;;;;;AAQA;AACA;AAhBA;AAkBA;AACA;;AAEA;AACA;;AAEA;AACA;AAPA;AAcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkDA;AAGA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACnNA;AACA;AACA;AACA;AACA;AAEA;AAwBA;AACA;AACA;AAqDA;AAEA;AAAA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAAA;AACA;AApDA;;;;;;;;;;;;;;;;;;;;;;;;;ACxFA;AAKA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAKA;AAGA;AAAA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAOA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAOA;AAGA;AACA;AACA;AACA;AAGA;AAGA;AACA;AAIA;AAEA;AAEA;AACA;AACA;AAGA;AACA;AAKA;AAGA;AAGA;AAGA;AAEA;AAEA;AAEA;AAEA;AAQA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAIA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAIA;AAGA;AAEA;AAGA;AAIA;AAEA;AAEA;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AAWA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAKA;AAGA;AAGA;AACA;AAUA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAGA;AACA;AAIA;AAGA;AAGA;AACA;AAOA;AACA;AAOA;AACA;;;AAGA;;;;;;;;;;;;;;AAcA;AACA;;AAEA;AACA;;;;;AAKA;;;;;;AAMA;AACA;AACA;;;;;AAKA;;;;AAIA;AACA;;;;;;;;AAQA;AAEA;AACA;;;;AAIA;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;AAKA;;;;;AAKA;AACA;AACA;;;;;AAKA;;;;;AAKA;AACA;;;;;;;;;AASA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;AAKA;;;;;AAKA;AACA;AACA;;;;;AAKA;;;;;;AAMA;AACA;;;;;;;;;AASA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;AAKA;;;;;AAKA;AACA;AACA;;;;;AAKA;;;;;;AAMA;AACA;;;;;;;;;AASA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;AAKA;;;;;AAKA;AACA;AACA;;;;;AAKA;;;;;;AAMA;AACA;;;;;;;;;;AAUA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;AAKA;;;;;AAKA;AACA;AACA;;;;;AAKA;;;;;;AAMA;AACA;;;;;;;;;AASA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AAEA;AAGA;AAEA;;AAEA;AACA;AACA;;;AAGA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AASA;AAEA;AAIA;AAEA;AAEA;AACA;AAEA;AACA;AAQA;AACA;;;;;;;;;;;;;;;;AAgBA;AACA;AAOA;AACA;AACA;AAOA;AACA;AACA;AAQA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AAKA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AAMA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AAAA;AACA;AACA;AAEA;AACA;AAMA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AAAA;AACA;AACA;AAEA;AAEA;AAEA;AAMA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAMA;AAEA;AAEA;AACA;AAGA;AACA;AAMA;AAEA;AAIA;AACA;AAEA;AAGA;AAEA;AAEA;AACA;AAGA;AAEA;AAQA;AAEA;AAEA;AAGA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAMA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAKA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAMA;;AACA;AACA;AACA;AAAA;AAEA;AArkCA;AAukCA;AACA;AACA;;;;;;;;;;;;;;;;ACrmCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AAGA;AACA;AACA;AAOA;AAEA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAUA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAGA;AAGA;AACA;AAEA;AACA;AACA;AAIA;AAGA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAiBA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AArQA;AA4QA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA;;;;;;;;;;;;;;;;AC3QA;AAEA;AACA;;AAEA;;AAEA;;;;;;;;;;;AAWA;AACA;AACA;;;;;AAKA;AAEA;AAEA;AAEA;AAJA;;;;;;;;;;;;;;;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACFA;AAMA;AAGA;AAIA;AAOA;AAIA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AALA;AAcA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAGA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAGA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;;AAIA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AA1IA;;;;;;;;;;;;;;;;AC7CA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAaA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA7GA;;;;;;;;;;;;ACvBA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;A","sourceRoot":""}